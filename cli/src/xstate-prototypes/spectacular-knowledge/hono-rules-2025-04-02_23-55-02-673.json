{
  "rules": [
    {
      "reasoning": "This rule is important as it demonstrates how to use the language detector feature in Hono for internationalization (i18n) and locale-specific content. It shows how to import the necessary modules and use them to detect language from query string, cookie, and header, with a fallback to English.",
      "ruleFile": "## Importing and Using Language Detector in Hono\n\nThis code demonstrates how to import and use the language detector feature in Hono. This is useful for internationalization (i18n) and locale-specific content.\n\n### Code Snippet:\n\n```ts\nimport { Hono } from 'hono'\nimport { languageDetector } from 'hono/language'\n```\n\n### How it Works:\n\n1. The `Hono` module is imported from the 'hono' package.\n2. The `languageDetector` module is imported from 'hono/language'.\n3. These modules can then be used to detect language from query string, cookie, and header, with a fallback to English.\n\n### Important Notes:\n\n- The order of detection is query string, cookie, and header by default.\n- It's important to specify the supported languages when using the language detector.\n\n### References:\n\n- [Hono Documentation](https://hono.bespoken.io/)\n\n### Common Use Cases:\n\n- Internationalization (i18n)\n- Locale-specific content",
      "ruleTitle": "Importing and Using Language Detector in Hono",
      "sourcePath": "docs/middleware/builtin/language.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the languageDetector middleware in Hono to detect the language from the query string, cookie, and header. It also shows how to set a fallback language and how to retrieve the detected language in a route handler. This is a common requirement in web applications that need to support multiple languages.",
      "ruleFile": "## Language Detection in Hono\n\nThis code demonstrates how to use the `languageDetector` middleware in Hono to detect the language from the query string, cookie, and header. It also shows how to set a fallback language and how to retrieve the detected language in a route handler.\n\n```ts\nconst app = new Hono()\n\napp.use(\n  languageDetector({\n    supportedLanguages: ['en', 'ar', 'ja'],\n    fallbackLanguage: 'en',\n  })\n)\n\napp.get('/', (c) => {\n  const lang = c.get('language')\n  return c.text(`Hello! Your language is ${lang}`)\n})\n```\n\n### How it works\n\nThe `languageDetector` middleware is used with the Hono application. It is configured with an array of supported languages and a fallback language. The middleware will try to detect the language from the query string, cookie, and header (in that order). If it cannot detect a language, it will use the fallback language.\n\nIn the route handler, the detected language can be retrieved with `c.get('language')`.\n\n### Important notes\n\n- The `supportedLanguages` array must include the `fallbackLanguage`.\n\n### References\n\n- [Hono documentation](https://hono.beyondnifty.com/)\n\n### Common use cases\n\n- Building a multilingual web application",
      "ruleTitle": "Language Detection in Hono",
      "sourcePath": "docs/middleware/builtin/language.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle language detection and localization in Hono. It shows how to set up a fallback language and how to retrieve the language from different sources such as path, query parameter, cookie, and header.",
      "ruleFile": "## Language Detection and Localization in Hono\n\nThis code snippet demonstrates how to handle language detection and localization in Hono. It shows how to set up a fallback language and how to retrieve the language from different sources.\n\n### Code Snippet\n\n```sh\n# Via path\ncurl http://localhost:8787/ar/home\n\n# Via query parameter\ncurl http://localhost:8787/?lang=ar\n\n# Via cookie\ncurl -H 'Cookie: language=ja' http://localhost:8787/\n\n# Via header\ncurl -H 'Accept-Language: ar,en;q=0.9' http://localhost:8787/\n```\n\n### How it Works\n\nThe Hono framework allows you to specify a fallback language that will be used if no language is specified by the client. The language can be specified in several ways: via the path, a query parameter, a cookie, or a header.\n\n### Important Notes\n\nThe order of precedence for language detection is as follows: querystring, cookie, header. This means that if a language is specified in both the querystring and the cookie, the language from the querystring will be used.\n\n### References\n\n- [Hono Documentation](https://hono.bouzuya.net/)\n\n### Common Use Cases\n\nThis pattern is commonly used in web applications that need to support multiple languages.",
      "ruleTitle": "Language Detection and Localization in Hono",
      "sourcePath": "docs/middleware/builtin/language.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up language detection in a Hono application. It shows the default configuration for language detection, including the order of sources to check for language preference (query string, cookie, header), the specific keys to look for in each source, and the fallback language to use if no preference is found. Understanding this rule can help developers to effectively internationalize their applications, providing a better user experience for users of different languages.",
      "ruleFile": "## Language Detection in Hono\n\nThis code snippet demonstrates how to set up language detection in a Hono application. The `DEFAULT_OPTIONS` object defines the default configuration for language detection.\n\n```ts\nexport const DEFAULT_OPTIONS: DetectorOptions = {\n  order: ['querystring', 'cookie', 'header'],\n  lookupQueryString: 'lang',\n  lookupCookie: 'language',\n  lookupFromHeaderKey: 'accept-language',\n  lookupFromPathIndex: 0,\n  caches: ['cookie'],\n  ignoreCase: true,\n  fallbackLanguage: 'en',\n  supportedLanguages: ['en'],\n  cookieOptions: {\n    sameSite: 'Strict',\n    secure: true,\n    maxAge: 365 * 24 * 60 * 60,\n    httpOnly: true,\n  },\n  debug: false,\n}\n```\n\n### How it Works\n\nThe `order` array defines the sequence of sources that the detector will check for a language preference. It will first check the query string, then the cookie, and finally the header. The `lookup*` properties define the specific keys to look for in each source.\n\nIf no language preference is found, the detector will fall back to the language specified by `fallbackLanguage`.\n\n### Important Notes\n\n- The `caches` array specifies which sources to cache the detected language in. In this case, the language will be cached in the cookie.\n- The `ignoreCase` property determines whether the detector should ignore case when matching languages.\n\n### References\n\n- [Hono Documentation](https://hono.bouzuya.net/)\n\n### Common Use Cases\n\n- Internationalizing a Hono application\n- Providing a localized user experience",
      "ruleTitle": "Setting Up Language Detection in Hono",
      "sourcePath": "docs/middleware/builtin/language.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure the language detection order in Hono. It shows how to prioritize URL path detection over other methods like cookies, query strings, and headers. This is useful in applications that need to support multiple languages and have a specific preference for how the language should be detected.",
      "ruleFile": "## Custom Language Detection Order in Hono\n\nThis code snippet demonstrates how to configure the language detection order in Hono. It prioritizes URL path detection over other methods like cookies, query strings, and headers.\n\n```ts\napp.use(\n  languageDetector({\n    order: ['path', 'cookie', 'querystring', 'header'],\n    lookupFromPathIndex: 0, // /en/profile â†’ index 0 = 'en'\n    supportedLanguages: ['en', 'ar'],\n    fallbackLanguage: 'en',\n  })\n)\n```\n\n### How it works\n\nThe `order` array determines the priority of language detection methods. The `lookupFromPathIndex` option is used to specify the index of the language code in the URL path. The `supportedLanguages` array lists the languages supported by the application. If no valid language is detected, the `fallbackLanguage` is used.\n\n### Important notes\n\n- The `order` array should contain at least one method.\n- The `lookupFromPathIndex` should be a valid index in the URL path.\n- The `supportedLanguages` should contain valid language codes.\n- The `fallbackLanguage` should be a valid language code and must be included in the `supportedLanguages` array.\n\n### References\n\n- [Hono Documentation](https://hono.bouzuya.net/)\n\n### Common use cases\n\n- Multilingual applications\n- Applications that prioritize URL path for language detection",
      "ruleTitle": "Custom Language Detection Order in Hono",
      "sourcePath": "docs/middleware/builtin/language.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure language detection in a Hono application. It shows how to normalize complex language codes (e.g., en-US to en) and set supported languages and a fallback language. This is crucial for applications that support multiple languages and need to adapt the user interface based on the user's language preference.",
      "ruleFile": "## Language Detection Configuration in Hono\n\nThis code snippet demonstrates how to configure language detection in a Hono application. It shows how to normalize complex language codes and set supported languages and a fallback language.\n\n```ts\napp.use(\n  languageDetector({\n    convertDetectedLanguage: (lang) => lang.split('-')[0],\n    supportedLanguages: ['en', 'ja'],\n    fallbackLanguage: 'en',\n  })\n)\n```\n\n### How it works\n\n1. `convertDetectedLanguage`: This function is used to normalize complex language codes. It splits the detected language code by '-' and returns the first part. For example, it converts 'en-US' to 'en'.\n2. `supportedLanguages`: This is an array of supported language codes. In this example, 'en' and 'ja' are supported.\n3. `fallbackLanguage`: This is the default language that will be used if the detected language is not supported.\n\n### Important notes\n\n- The `languageDetector` middleware must be used before any other middleware that needs to know the user's language preference.\n\n### References\n\n- [Hono Documentation](https://hono.beeceptor.com/docs)\n\n### Common use cases\n\n- Multilingual applications that need to adapt the user interface based on the user's language preference.",
      "ruleTitle": "Configuring Language Detection in Hono",
      "sourcePath": "docs/middleware/builtin/language.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure language detection and cookie settings in Hono. It shows how to specify supported languages, fallback language, cookie options, and how to enable or disable caching and debugging. Understanding this rule is crucial for internationalization and localization of applications, as well as for managing user sessions securely.",
      "ruleFile": "## Language Detection and Cookie Configuration in Hono\n\nThis code snippet demonstrates how to configure language detection and cookie settings in Hono.\n\n```ts\napp.use(\n  languageDetector({\n    lookupCookie: 'app_lang',\n    caches: ['cookie'],\n    cookieOptions: {\n      path: '/',\n      sameSite: 'Lax',\n      secure: true,\n      maxAge: 86400 * 365,\n      httpOnly: true,\n      domain: '.example.com',\n    },\n  })\n)\n```\n\n### How it works\n\n1. `lookupCookie: 'app_lang'` - This sets the name of the cookie to be used for language detection.\n2. `caches: ['cookie']` - This enables caching of the detected language in cookies.\n3. `cookieOptions` - This is used to specify various options for the cookie.\n\n### Important notes\n\n- `sameSite: 'Lax'` - This sets the SameSite attribute of the cookie to 'Lax', which means the cookie will only be sent in a first-party context and not with cross-origin requests.\n- `secure: true` - This ensures that the cookie is only sent over HTTPS.\n- `httpOnly: true` - This makes the cookie inaccessible via JavaScript, providing protection against cross-site scripting (XSS) attacks.\n\n### References\n\n- [Hono Documentation](https://www.eclipse.org/hono/docs/)\n\n### Common use cases\n\n- Internationalization and localization of applications\n- Managing user sessions securely",
      "ruleTitle": "Configuring Language Detection and Cookie Settings in Hono",
      "sourcePath": "docs/middleware/builtin/language.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to disable cookie caching in Hono. Caching can be useful for performance, but there may be situations where it is necessary to disable it, such as when the data is sensitive and should not be stored, or when the data changes frequently and the cache would serve stale data.",
      "ruleFile": "## Disabling Cookie Caching in Hono\n\nIn Hono, you can disable cookie caching by setting the `caches` option to `false` in the `languageDetector` function.\n\nHere is a code snippet demonstrating this:\n\n```ts\nlanguageDetector({\n  caches: false,\n})\n```\n\nWhen `caches` is set to `false`, Hono will not store any cookies. This means that every time a request is made, Hono will not have any stored data to refer to and will have to process the request as if it is the first time.\n\nThis can be useful in situations where the data is sensitive and should not be stored, or when the data changes frequently and the cache would serve stale data. However, keep in mind that disabling caching can impact performance, as Hono will have to process every request from scratch.\n\n### References\n\n- [Hono Documentation](https://hono.bouzuya.net/)\n\n### Common Use Cases\n\n- When dealing with sensitive data that should not be stored\n- When the data changes frequently and the cache would serve stale data",
      "ruleTitle": "Disabling Cookie Caching in Hono",
      "sourcePath": "docs/middleware/builtin/language.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to enable debugging in Hono's language detector. Debugging is a crucial part of development and testing, as it allows developers to trace the execution of a program and find and fix bugs. In this case, setting the 'debug' option to 'true' will log the detection steps, which can be helpful in understanding how the language detector is working and diagnosing any issues.",
      "ruleFile": "## Enabling Debugging in Hono's Language Detector\n\nThis code snippet demonstrates how to enable debugging in Hono's language detector.\n\n```ts\nlanguageDetector({\n  debug: true, // Shows: \"Detected from querystring: ar\"\n})\n```\n\nBy setting the 'debug' option to 'true', the language detector will log the detection steps. This can be useful for understanding how the language detector is working and diagnosing any issues.\n\n### How it Works\n\nWhen the 'debug' option is set to 'true', the language detector will log the detection steps to the console. This includes the source of the detected language (e.g., 'Detected from querystring: ar').\n\n### Important Notes\n\n- Debugging should generally be disabled in production environments, as it can expose sensitive information and negatively impact performance.\n\n### References\n\n- [Hono Documentation](https://www.example.com)\n\n### Common Use Cases\n\n- Debugging issues with language detection\n- Understanding how the language detector is working",
      "ruleTitle": "Enabling Debugging in Hono's Language Detector",
      "sourcePath": "docs/middleware/builtin/language.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to implement language detection and localization in Hono. It shows how to define supported languages and normalize detected languages for consistency. This is crucial for applications that need to support multiple languages and provide localized content to users.",
      "ruleFile": "## Language Detection and Localization in Hono\n\nThe following code snippets demonstrate how to implement language detection and localization in Hono.\n\n```ts\napp.get('/:lang/home', (c) => {\n  const lang = c.get('language') // 'en', 'ar', etc.\n  return c.json({ message: getLocalizedContent(lang) })\n})\n```\n\nThis snippet shows how to retrieve the language from the request context and return localized content.\n\n```ts\nlanguageDetector({\n  supportedLanguages: ['en', 'en-GB', 'ar', 'ar-EG'],\n  convertDetectedLanguage: (lang) => lang.replace('_', '-'), // Normalize\n})\n```\n\nThis snippet demonstrates how to define supported languages and normalize detected languages for consistency.\n\n### How it Works\n\n1. The `languageDetector` function is called with an object that specifies the supported languages and a function to normalize the detected language.\n2. The `convertDetectedLanguage` function replaces underscores with hyphens in the detected language code to ensure consistency.\n\n### Important Notes\n\n- The `languageDetector` function and the `convertDetectedLanguage` function are part of the Hono framework's internationalization (i18n) support.\n\n### References\n\n- [Hono Documentation](https://hono.boutique/docs)\n\n### Common Use Cases\n\n- Providing localized content to users based on their language preference or location.",
      "ruleTitle": "Implementing Language Detection and Localization in Hono",
      "sourcePath": "docs/middleware/builtin/language.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'compress' middleware in Hono. The 'compress' middleware is used to automatically compress the response body, which can significantly reduce the size of the data being sent over the network, leading to faster response times. However, it's important to note that this middleware uses 'CompressionStream', which is not yet supported in bun.",
      "ruleFile": "## Using the 'compress' Middleware in Hono\n\nThis code snippet demonstrates how to use the 'compress' middleware in Hono to automatically compress the response body.\n\n```ts\nimport { Hono } from 'hono'\nimport { compress } from 'hono/compress'\n\nconst app = new Hono()\n\napp.use(compress())\n```\n\n### How it Works\n\nThe 'compress' middleware uses 'CompressionStream' to compress the response body. This can significantly reduce the size of the data being sent over the network, leading to faster response times.\n\n### Important Notes\n\nThis middleware uses 'CompressionStream', which is not yet supported in bun. Therefore, it should not be used if you are using bun.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common Use Cases\n\nThis middleware is commonly used in applications where large amounts of data are being sent over the network and faster response times are desired.",
      "ruleTitle": "Using the 'compress' Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/compress.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'compress' middleware in the Hono web framework. It shows how to import the necessary modules and apply the middleware to the Hono application. This is a common practice in web development to reduce the size of the response body and hence, increase the speed of a web application.",
      "ruleFile": "## Hono Compression Middleware Usage\n\nThis rule demonstrates how to use the 'compress' middleware in the Hono web framework.\n\n### Code Snippet\n\n```ts\nimport { Hono } from 'hono'\nimport { compress } from 'hono/compress'\n\nconst app = new Hono()\n\napp.use(compress())\n```\n\n### How it Works\n\n1. Import the necessary modules from 'hono' and 'hono/compress'.\n2. Create a new Hono application.\n3. Use the 'compress' middleware in the Hono application.\n\n### Important Notes\n\n- The 'compress' middleware uses 'CompressionStream' which is not yet supported in bun.\n- The 'compress' middleware allows for response compression using either 'gzip' or 'deflate'. If not defined, both are allowed.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common Use Cases\n\n- Use this middleware when you want to reduce the size of the response body and increase the speed of your web application.",
      "ruleTitle": "Using Compression Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/compress.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to conditionally enable timing in Hono. It shows how to use a function to determine whether or not to enable timing based on the request method. This can be useful in scenarios where you only want to measure the time taken for certain types of requests, such as POST requests.",
      "ruleFile": "## Conditionally Enabling Timing in Hono\n\nIn Hono, you can conditionally enable timing for your requests. This can be done by passing a function to the `enabled` option in the `timing` middleware. This function receives the request context and should return a boolean indicating whether or not to enable timing.\n\nHere's an example of how to enable timing only for POST requests:\n\n```ts\nconst app = new Hono()\n\napp.use(\n  '*',\n  timing({\n    // c: Context of the request\n    enabled: (c) => c.req.method === 'POST',\n  })\n)\n```\n\nIn this example, the `enabled` function checks if the request method is 'POST'. If it is, timing is enabled for that request.\n\n### Important Notes\n\n- The `enabled` function should return a boolean.\n- The `enabled` function is called for every request, so it should be as lightweight as possible to avoid impacting performance.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common Use Cases\n\n- Conditionally enabling timing based on request method, headers, or other request properties.",
      "ruleTitle": "Conditionally Enabling Timing in Hono",
      "sourcePath": "docs/middleware/builtin/timing.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import the IP Restriction Middleware in Hono. This middleware is used to limit access to resources based on the user's IP address, which is crucial for security purposes.",
      "ruleFile": "## IP Restriction Middleware Import in Hono\n\nThis code demonstrates how to import the IP Restriction Middleware in Hono. This middleware is used to limit access to resources based on the user's IP address.\n\n```ts\nimport { Hono } from 'hono'\nimport { ipRestriction } from 'hono/ip-restriction'\n```\n\n### How it works\n\nThe `import` statements are used to include the `Hono` and `ipRestriction` modules from the 'hono' and 'hono/ip-restriction' packages respectively.\n\n### Important notes\n\n- Make sure the 'hono' and 'hono/ip-restriction' packages are installed in your project before importing them.\n- The 'ipRestriction' middleware should be used judiciously as it can block access to legitimate users if not configured properly.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/docs)\n\n### Common use cases\n\n- Restricting access to certain resources based on the user's IP address.\n- Implementing IP-based rate limiting.",
      "ruleTitle": "Importing IP Restriction Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/ip-restriction.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to implement IP restriction in Hono. It shows how to use the 'ipRestriction' middleware to allow or deny access to certain IP addresses. This is crucial for security purposes, as it can prevent unauthorized access to the application.",
      "ruleFile": "## IP Restriction in Hono\n\nThis code demonstrates how to implement IP restriction in Hono using the 'ipRestriction' middleware.\n\n```ts\nimport { Hono } from 'hono'\nimport { getConnInfo } from 'hono/bun'\nimport { ipRestriction } from 'hono/ip-restriction'\n\nconst app = new Hono()\n\napp.use(\n  '*',\n  ipRestriction(getConnInfo, {\n    denyList: [],\n    allowList: ['127.0.0.1', '::1'],\n  })\n)\n\napp.get('/', (c) => c.text('Hello Hono!'))\n```\n\n### How it works\n\nThe 'ipRestriction' middleware is used with the 'app.use' method to apply the IP restriction to all routes ('*'). The 'getConnInfo' function is passed as the first argument to 'ipRestriction', and an object with 'denyList' and 'allowList' properties is passed as the second argument. The 'denyList' property is an array of IP addresses that are denied access, and the 'allowList' property is an array of IP addresses that are allowed access.\n\n### Important notes\n\n- The 'getConnInfo' function should be imported from the appropriate module for your environment.\n- The 'denyList' and 'allowList' arrays can be modified to suit your needs.\n\n### References\n\n- [ConnInfo helper](/docs/helpers/conninfo)\n\n### Common use cases\n\n- Restricting access to local development environment\n- Preventing unauthorized access to certain routes",
      "ruleTitle": "Implementing IP Restriction in Hono",
      "sourcePath": "docs/middleware/builtin/ip-restriction.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to implement IP restrictions using the Hono framework. It shows how to use the 'ipRestriction' middleware and the 'getConnInfo' helper to restrict access to the application based on IP addresses. This is a crucial aspect of securing web applications, as it allows developers to control who can access their application based on their IP address.",
      "ruleFile": "## IP Restriction in Hono Framework\n\nThis code snippet demonstrates how to implement IP restrictions in a web application using the Hono framework. The 'ipRestriction' middleware and the 'getConnInfo' helper from the ConnInfo helper are used to achieve this.\n\n```ts\nimport { getConnInfo } from 'hono/deno'\nimport { ipRestriction } from 'hono/ip-restriction'\n\n//...\n\napp.use(\n  '*',\n  ipRestriction(getConnInfo, {\n    // ...\n  })\n)\n```\n\n### How it Works\n\nThe 'getConnInfo' helper is passed as the first argument to the 'ipRestriction' middleware. This helper provides the connection information necessary for the middleware to determine the IP address of the incoming request.\n\nThe 'ipRestriction' middleware then uses this information to restrict access based on the IP address. The specific IP addresses or ranges to be restricted can be specified in the options object passed as the second argument to the middleware.\n\n### Important Notes\n\n- The 'getConnInfo' helper used may vary depending on the environment. The example shown is for Deno.\n\n- The IP addresses can be specified in various formats including static IP addresses, CIDR notation, or using '*' to represent all addresses.\n\n### References\n\n- [ConnInfo helper](/docs/helpers/conninfo)\n\n### Common Use Cases\n\n- Restricting access to an application based on IP addresses for security purposes.",
      "ruleTitle": "Implementing IP Restrictions in Hono Framework",
      "sourcePath": "docs/middleware/builtin/ip-restriction.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the IP restriction feature in Hono. It shows how to deny access to a specific IP range and how to customize the error message when access is denied.",
      "ruleFile": "## IP Restriction in Hono\n\nThis code snippet demonstrates how to use the IP restriction feature in Hono. It shows how to deny access to a specific IP range and how to customize the error message when access is denied.\n\n```ts\napp.use(\n  '*',\n  ipRestriction(\n    getConnInfo,\n    {\n      denyList: ['192.168.2.0/24'],\n    },\n    async (remote, c) => {\n      return c.text(`Blocking access from ${remote.addr}`, 403)\n    }\n  )\n)\n```\n\n### How it works\n\nThe `app.use` function is used to apply the IP restriction middleware to all routes (`'*'`). The `ipRestriction` function takes three arguments: the connection information function (`getConnInfo`), the IP restriction options, and an error handling function.\n\nThe IP restriction options object has a `denyList` property, which is an array of IP addresses or ranges to deny access to. In this case, all IP addresses in the range '192.168.2.0/24' are denied access.\n\nThe error handling function is called when access is denied. It takes two arguments: the remote connection information and the context object. It returns a custom error message and status code.\n\n### Important notes\n\n- The IP restriction middleware should be applied before any other middleware or routes.\n- The `denyList` can contain both IPv4 and IPv6 addresses and ranges.\n\n### References\n\n- [Hono documentation](https://hono.bouzuya.net/)\n\n### Common use cases\n\n- Restricting access to your application based on IP address or range.\n- Customizing the error message when access is denied.",
      "ruleTitle": "Using IP Restriction in Hono",
      "sourcePath": "docs/middleware/builtin/ip-restriction.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to limit the size of the body in a POST request using the Hono web framework. This is crucial in scenarios where you want to prevent clients from sending large amounts of data to the server, which could potentially lead to server overload or other issues.",
      "ruleFile": "## Hono Body Limit Usage\n\nThis code demonstrates how to limit the size of the body in a POST request using the Hono web framework.\n\n```ts\nimport { Hono } from 'hono'\nimport { bodyLimit } from 'hono/body-limit'\n\nconst app = new Hono()\n\napp.post(\n  '/upload',\n  bodyLimit({\n    maxSize: 50 * 1024, // 50kb\n    onError: (c) => {\n      return c.text('overflow :(', 413)\n    },\n  }),\n  async (c) =>\n```\n\n### How it works\n\nThe `bodyLimit` function is imported from 'hono/body-limit' and is used as middleware in the POST route. It checks the size of the body against the `maxSize` specified (in this case, 50kb). If the body size exceeds the `maxSize`, the `onError` function is executed.\n\n### Important notes\n\n- The `maxSize` is specified in bytes.\n- The `onError` function should return a response to the client. In this case, it returns a text response with the message 'overflow :(' and a 413 (Payload Too Large) HTTP status code.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/)\n\n### Common use cases\n\n- Limiting the size of file uploads in a file upload route.\n- Preventing large amounts of data from being sent to the server in a form submission route.",
      "ruleTitle": "Limiting Body Size in Hono POST Requests",
      "sourcePath": "docs/middleware/builtin/body-limit.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to limit the size of the body in a POST request using the Hono web framework. This is crucial in scenarios where you want to prevent users from uploading files that are too large, which could potentially overload the server or take a long time to process.",
      "ruleFile": "## Limiting Body Size in Hono\n\nThis code snippet demonstrates how to limit the size of the body in a POST request using the Hono web framework.\n\n```ts\nconst app = new Hono()\n\napp.post(\n  '/upload',\n  bodyLimit({\n    maxSize: 50 * 1024, // 50kb\n    onError: (c) => {\n      return c.text('overflow :(', 413)\n    },\n  }),\n  async (c) => {\n    const body = await c.req.parseBody()\n    if (body['file'] instanceof File) {\n      console.log(`Got file sized: ${body['file'].size}`)\n    }\n    return c.text('pass :)')\n  }\n)\n```\n\nIn this example, the `bodyLimit` middleware is used to limit the size of the body in the POST request to 50KB. If the size of the body exceeds this limit, an error handler is executed, returning a 413 (Payload Too Large) status code and a custom error message.\n\nThis is a useful technique for preventing users from uploading files that are too large, which could potentially overload the server or take a long time to process.\n\n### Important Notes\n\n- The `maxSize` option is required and specifies the maximum size of the body in bytes.\n- The `onError` option is a function that is executed when the size of the body exceeds the `maxSize`.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common Use Cases\n\n- Limiting the size of file uploads in a file upload endpoint.",
      "ruleTitle": "Limiting Body Size in Hono",
      "sourcePath": "docs/middleware/builtin/body-limit.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set the maximum request body size in Hono and Bun. By default, Hono and Bun limit the size of the request body to prevent denial of service (DoS) attacks. However, in some cases, you may need to accept larger requests. This rule shows how to increase this limit.",
      "ruleFile": "## Setting the Maximum Request Body Size in Hono and Bun\n\nIn Hono and Bun, the default maximum request body size is set to prevent denial of service (DoS) attacks. However, there may be cases where you need to accept larger requests. To do this, you need to set the `maxRequestBodySize` property.\n\nHere is an example of how to do this:\n\n```ts\nexport default {\n  port: process.env['PORT'] || 3000,\n  fetch: app.fetch,\n  maxRequestBodySize: 1024 * 1024 * 200, // your value here\n}\n```\n\nIn this code snippet, the `maxRequestBodySize` is set to 200MiB. You can adjust this value according to your needs.\n\n### How it Works\n\nThe `maxRequestBodySize` property sets the maximum size of the request body that Hono and Bun will accept. If a request exceeds this size, Hono and Bun will respond with a status code of `413` and terminate the connection.\n\n### Important Notes\n\n- Be careful when increasing the `maxRequestBodySize`. Setting this value too high can make your application vulnerable to DoS attacks.\n- The `maxRequestBodySize` is specified in bytes.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n- [Bun Documentation](https://bun.dev/)\n\n### Common Use Cases\n\n- Accepting file uploads that are larger than the default maximum request body size.",
      "ruleTitle": "Setting the Maximum Request Body Size in Hono and Bun",
      "sourcePath": "docs/middleware/builtin/body-limit.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set the maximum request body size in Hono. This is crucial for controlling the amount of data that can be sent in a single request, preventing potential overflows or resource exhaustion.",
      "ruleFile": "## Setting Maximum Request Body Size in Hono\n\nThis code snippet demonstrates how to set the maximum request body size in Hono. This is done using the `maxRequestBodySize` property.\n\n```ts\nBun.serve({\n  fetch(req, server) {\n    return app.fetch(req, { ip: server.requestIP(req) })\n  },\n  maxRequestBodySize: 1024 * 1024 * 200, // your value here\n})\n```\n\n### How it works\n\nThe `maxRequestBodySize` property is set to the desired limit in bytes. In this example, it is set to 200MB.\n\n### Important notes\n\n- The value for `maxRequestBodySize` should be set according to the specific needs of your application.\n- Be aware that setting a very high limit can potentially lead to resource exhaustion if large amounts of data are sent in a single request.\n\n### References\n\n- [Hono Documentation](https://hono.bouzuya.net/)\n\n### Common use cases\n\n- Limiting the size of file uploads\n- Preventing large payloads from overloading the server",
      "ruleTitle": "Setting Maximum Request Body Size in Hono",
      "sourcePath": "docs/middleware/builtin/body-limit.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to implement basic authentication in a Hono application. Basic authentication is a simple authentication scheme built into the HTTP protocol. The client sends HTTP requests with the Authorization header that contains the word Basic word followed by a space and a base64-encoded string username:password. For an application to be secure, it is crucial to implement some form of authentication, and this rule provides an example of how to do so using the Hono framework.",
      "ruleFile": "## Basic Authentication in Hono\n\nThis rule demonstrates how to implement basic authentication in a Hono application.\n\n```ts\nimport { Hono } from 'hono'\nimport { basicAuth } from 'hono/basic-auth'\n\nconst app = new Hono()\n\napp.use(\n  '/auth/*',\n  basicAuth({\n    username: 'hono',\n    password: 'acoolproject',\n  })\n)\n\napp.get('/auth/page', (c) => {\n  return c.text('You are authorized')\n})\n```\n\n### How it works\n\nThe `basicAuth` function from 'hono/basic-auth' is used as a middleware for the '/auth/*' route. This function takes an object with a username and password. Any request to '/auth/*' will need to include these credentials in the Authorization header to be successful.\n\n### Important notes\n\n- The username and password are hardcoded in this example, but in a real-world application, you would likely want to check these credentials against a database.\n\n### References\n\n- [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#basic_authentication_scheme)\n\n### Common use cases\n\n- Protecting routes that should only be accessible to authenticated users.",
      "ruleTitle": "Implementing Basic Authentication in Hono",
      "sourcePath": "docs/middleware/builtin/basic-auth.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'verifyUser' option in the basicAuth middleware of Hono framework. This option allows developers to manually verify the user credentials, providing an additional layer of security and flexibility.",
      "ruleFile": "## Hono Basic Authentication with Manual User Verification\n\nIn Hono, you can manually verify user credentials using the 'verifyUser' option in the basicAuth middleware. This provides an additional layer of security and flexibility.\n\nHere is a code snippet demonstrating this:\n\n```ts\nconst app = new Hono()\n\napp.use(\n  basicAuth({\n    verifyUser: (username, password, c) => {\n      return (\n        username === 'dynamic-user' && password === 'hono-password'\n      )\n    },\n  })\n)\n```\n\nIn the above code, the 'verifyUser' function checks if the username is 'dynamic-user' and the password is 'hono-password'. If both conditions are met, the function returns true, indicating that the user is authenticated.\n\n### Important Notes\n\n- The 'verifyUser' function should return a boolean value.\n- The 'verifyUser' function is called with three arguments: username, password, and the context object.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common Use Cases\n\n- Manually verifying user credentials in applications that require custom authentication logic.",
      "ruleTitle": "Hono Basic Authentication with Manual User Verification",
      "sourcePath": "docs/middleware/builtin/basic-auth.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define multiple users with basic authentication in Hono. It shows how to pass arbitrary parameters containing objects defining more `username` and `password` pairs. It also highlights that other parameters can only be defined in the first object.",
      "ruleFile": "## Defining Multiple Users with Basic Authentication in Hono\n\nThis code snippet demonstrates how to define multiple users with basic authentication in Hono. It shows how to pass arbitrary parameters containing objects defining more `username` and `password` pairs.\n\n```ts\napp.use(\n  '/auth/*',\n  basicAuth(\n    {\n      username: 'hono',\n      password: 'acoolproject',\n      // Define other params in the first object\n      realm: 'www.example.com',\n    },\n    {\n      username: 'hono-admin',\n      password: 'super-secure',\n      // Cannot redefine other params here\n    },\n    {\n      username: 'hono-user-1',\n      password: 'a-secret',\n      // Or here\n    }\n  )\n)\n```\n\n### How it works\n\nThe `basicAuth` function is used as a middleware in the application. It takes an arbitrary number of objects as arguments, each representing a user. Each object should contain a `username` and `password` pair. Other parameters can only be defined in the first object.\n\n### Important notes\n\n- Other parameters can only be defined in the first object.\n- The `username` and `password` pairs are hardcoded in this example, but they can also be loaded from a configuration file or a database.\n\n### References\n\n- [Hono Documentation](https://www.hono.com/docs)\n\n### Common use cases\n\n- Defining multiple users for basic authentication in a Hono application.",
      "ruleTitle": "Defining Multiple Users with Basic Authentication in Hono",
      "sourcePath": "docs/middleware/builtin/basic-auth.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the JWT middleware in the Hono web framework. JWT (JSON Web Tokens) are a popular method of handling authentication and authorization in web applications. Understanding how to correctly import and utilize the JWT middleware in Hono is crucial for securing routes and endpoints in a Hono-based application.",
      "ruleFile": "## Importing and Using JWT Middleware in Hono\n\nThis code demonstrates how to import and use the JWT middleware in the Hono web framework.\n\n```ts\nimport { Hono } from 'hono'\nimport { jwt } from 'hono/jwt'\nimport type { JwtVariables } from 'hono/jwt'\n```\n\n### How it works\n\n1. The `Hono` object is imported from the 'hono' package. This is the main object used to create a new Hono application.\n2. The `jwt` middleware is imported from 'hono/jwt'. This middleware is used to handle JWT authentication and authorization.\n3. The `JwtVariables` type is imported from 'hono/jwt'. This type is used to infer the type of the JWT payload.\n\n### Important notes\n\n- The JWT middleware must be used on routes that require authentication or authorization.\n- The `JwtVariables` type should be used to infer the type of the JWT payload.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n- [JWT](https://jwt.io/introduction/)\n\n### Common use cases\n\n- Protecting routes or endpoints that require user authentication or authorization.",
      "ruleTitle": "Importing and Using JWT Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/jwt.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use JWT (JSON Web Tokens) for authentication in Hono. It shows how to import the necessary modules, define the JWT variables, apply the JWT middleware to specific routes, and how to retrieve the JWT payload.",
      "ruleFile": "## JWT Authentication in Hono\n\nThis code snippet demonstrates how to use JWT for authentication in Hono.\n\n```ts\nimport { Hono } from 'hono'\nimport { jwt } from 'hono/jwt'\nimport type { JwtVariables } from 'hono/jwt'\n\ntype Variables = JwtVariables\n\nconst app = new Hono<{ Variables: Variables }>()\n\napp.use(\n  '/auth/*',\n  jwt({\n    secret: 'it-is-very-secret',\n  })\n)\n\napp.get('/auth/page', (c) => {\n  return c.text('You are authorized')\n})\n```\n\n### How it works\n\n1. Import the necessary modules from Hono and JWT.\n2. Define the JWT variables.\n3. Initialize a new Hono application with the defined JWT variables.\n4. Apply the JWT middleware to all routes under '/auth'.\n5. Define a GET route '/auth/page' that returns a text response.\n\n### Important notes\n\n- The secret used in the JWT middleware should be kept secure and not exposed.\n\n### References\n\n- [Hono JWT Documentation](https://hono.bayrell.org/docs/en/jwt)\n\n### Common use cases\n\n- Protecting routes or endpoints that require authentication.\n- Retrieving and using JWT payload data.",
      "ruleTitle": "Using JWT Authentication in Hono",
      "sourcePath": "docs/middleware/builtin/jwt.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use JWT (JSON Web Tokens) for authentication in Hono. It shows how to set up a middleware for a specific route pattern ('/auth/*') to check for valid JWTs, and how to extract the payload from a valid JWT.",
      "ruleFile": "## Using JWT for Authentication in Hono\n\nThis code snippet demonstrates how to use JWT (JSON Web Tokens) for authentication in Hono.\n\n```ts\nconst app = new Hono()\n\napp.use(\n  '/auth/*',\n  jwt({\n    secret: 'it-is-very-secret',\n  })\n)\n\napp.get('/auth/page', (c) => {\n  const payload = c.get('jwtPayload')\n  return c.json(payload) // eg: { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022 }\n})\n```\n\n### How it works\n\n1. A new Hono app is created.\n2. A middleware is set up for the route pattern '/auth/*'. This middleware uses the `jwt()` function to check for valid JWTs in the request. The secret used for decoding the JWT is 'it-is-very-secret'.\n3. A GET route '/auth/page' is set up. In the route handler, the payload of the JWT is extracted using `c.get('jwtPayload')` and returned as a JSON response.\n\n### Important notes\n\n- The `jwt()` function is just a middleware function. If you want to use an environment variable (eg: `c.env.JWT_SECRET`), you can use it as follows:\n\n```js\napp.use('/auth/*', (c, next) => {\n  const jwtMiddleware = jwt({ secret: c.env.JWT_SECRET })\n  return jwtMiddleware(c, next)\n})\n```\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n- [JWT](https://jwt.io/)\n\n### Common use cases\n\n- Protecting routes that require authentication\n- Extracting user information from JWTs",
      "ruleTitle": "Using JWT for Authentication in Hono",
      "sourcePath": "docs/middleware/builtin/jwt.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the jwt middleware function in Hono with an environment variable for the secret key. This is a common practice to secure sensitive data like the secret key for JWT authentication.",
      "ruleFile": "## Using JWT Middleware with Environment Variable for Secret Key\n\nThis code snippet demonstrates how to use the `jwt()` middleware function in Hono with an environment variable for the secret key. This is a common practice to secure sensitive data like the secret key for JWT authentication.\n\n```js\napp.use('/auth/*', (c, next) => {\n  const jwtMiddleware = jwt({\n    secret: c.env.JWT_SECRET,\n  })\n  return jwtMiddleware(c, next)\n})\n```\n\n### How it Works\n\nThe `jwt()` function is a middleware that is used to authenticate HTTP requests using JSON Web Tokens. In this code snippet, the `jwt()` function is used with an environment variable `c.env.JWT_SECRET` for the secret key. This is done to secure the secret key, as it is sensitive data.\n\n### Important Notes\n\n- The `jwt()` function is just a middleware function. It can be used with any route.\n- The secret key for the `jwt()` function should be stored securely. In this code snippet, it is stored as an environment variable.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs)\n\n### Common Use Cases\n\n- Authenticating HTTP requests using JSON Web Tokens.\n- Securing sensitive data like the secret key for JWT authentication.",
      "ruleTitle": "Using JWT Middleware with Environment Variable for Secret Key in Hono",
      "sourcePath": "docs/middleware/builtin/jwt.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the jsxRenderer and useRequestContext functions from the Hono framework. The jsxRenderer function allows you to render JSX components directly in the c.render() function, without the need for using c.setRenderer(). The useRequestContext function enables access to instances of Context within components. Understanding this rule is crucial for rendering JSX components and accessing context in a Hono application.",
      "ruleFile": "## Importing and Using jsxRenderer and useRequestContext in Hono\n\nThis code demonstrates how to import and use the jsxRenderer and useRequestContext functions from the Hono framework.\n\n```ts\nimport { Hono } from 'hono'\nimport { jsxRenderer, useRequestContext } from 'hono/jsx-renderer'\n```\n\n### How it works\n\n1. The jsxRenderer function allows you to render JSX components directly in the c.render() function, without the need for using c.setRenderer().\n2. The useRequestContext function enables access to instances of Context within components.\n\n### Important notes\n\n- The jsxRenderer and useRequestContext functions are imported from 'hono/jsx-renderer', not 'hono'.\n\n### References\n\n- [Hono Documentation](https://hono.bayfrontcloud.com/)\n\n### Common use cases\n\n- Rendering JSX components in a Hono application.\n- Accessing context within components in a Hono application.",
      "ruleTitle": "Importing and Using jsxRenderer and useRequestContext in Hono",
      "sourcePath": "docs/middleware/builtin/jsx-renderer.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the jsxRenderer in the Hono framework to render JSX components. It also shows how to use the 'useRequestContext' function to access the context within components. This is crucial for building dynamic web applications with Hono.",
      "ruleFile": "## Hono JSX Renderer Usage\n\nThis rule demonstrates how to use the jsxRenderer in the Hono framework to render JSX components.\n\n```jsx\nimport { Hono } from 'hono'\nimport { jsxRenderer, useRequestContext } from 'hono/jsx-renderer'\n\nconst app = new Hono()\n\napp.get(\n  '/page/*',\n  jsxRenderer(({ children }) => {\n    return (\n      <html>\n        <body>\n          <header>Menu</header>\n          <div>{children}</div>\n        </body>\n      </html>\n    )\n  })\n)\n\napp.get('/page/about', (c) => {\n  return c.render(<h1>About me!</h1>)\n})\n```\n\n### How it works\n\n1. First, the Hono and jsxRenderer modules are imported.\n2. A new Hono application is created.\n3. The jsxRenderer is used to define a route handler for '/page/*'. This handler returns a JSX component.\n4. Another route handler is defined for '/page/about'. This handler uses the context's render method to return a JSX component.\n\n### Important notes\n\n- The jsxRenderer allows for the use of JSX in Hono, which is not natively supported.\n- The 'useRequestContext' function can be used to access the context within components.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common use cases\n\n- Building dynamic web applications with Hono.\n- Using JSX to define route handlers in Hono.",
      "ruleTitle": "Using jsxRenderer in Hono",
      "sourcePath": "docs/middleware/builtin/jsx-renderer.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'docType' option in the jsxRenderer function of the Hono framework. This option allows developers to control whether a DOCTYPE is added at the beginning of the HTML or not, and if so, what type of DOCTYPE to add. This can be useful in cases where the developer wants to control the document type declaration for the rendered HTML.",
      "ruleFile": "## Using the 'docType' option in jsxRenderer\n\nThis code snippet demonstrates how to use the 'docType' option in the jsxRenderer function of the Hono framework.\n\n```tsx\napp.use(\n  '*',\n  jsxRenderer(\n    ({ children }) => {\n      return (\n        <html>\n          <body>{children}</body>\n        </html>\n      )\n    },\n    { docType: false }\n  )\n)\n```\n\nIn this example, the 'docType' option is set to 'false', which means that a DOCTYPE will not be added at the beginning of the HTML.\n\n### How it works\n\nThe jsxRenderer function takes two arguments: a render function and an options object. The render function is used to generate the HTML content, and the options object can be used to control various aspects of the rendering process, including the document type declaration.\n\n### Important notes\n\n- The 'docType' option can be set to 'false' to prevent a DOCTYPE from being added, or it can be set to a string to specify a particular DOCTYPE.\n\n### References\n\n- [Hono documentation](https://hono.bokuweb.me/)\n\n### Common use cases\n\n- When you want to control the document type declaration for the rendered HTML.",
      "ruleTitle": "Using the 'docType' option in jsxRenderer",
      "sourcePath": "docs/middleware/builtin/jsx-renderer.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'stream' option in the jsxRenderer function in Hono framework to render a streaming response. It also shows how to create an asynchronous component and how to use the Suspense component for fallback UI during loading.",
      "ruleFile": "## Rule: Use of 'stream' option in jsxRenderer for streaming responses\n\nThis rule demonstrates how to use the 'stream' option in the jsxRenderer function in Hono framework to render a streaming response. It also shows how to create an asynchronous component and how to use the Suspense component for fallback UI during loading.\n\n### Code Snippet:\n\n```tsx\nconst AsyncComponent = async () => {\n  await new Promise((r) => setTimeout(r, 1000)) // sleep 1s\n  return <div>Hi!</div>\n}\n\napp.get(\n  '*',\n  jsxRenderer(\n    ({ children }) => {\n      return (\n        <html>\n          <body>\n            <h1>SSR Streaming</h1>\n            {children}\n          </body>\n        </html>\n      )\n    },\n    { stream: true }\n  )\n)\n\napp.get('/', (c) => {\n  return c.render(\n    <Suspense fallback={<div>loading...</div>}>\n      <AsyncComponent />\n    </Suspense>\n  )\n})\n```\n\n### How it works:\n\n1. An asynchronous component 'AsyncComponent' is created which returns a div element after a delay of 1 second.\n2. The jsxRenderer function is used with the 'stream' option set to true to render a streaming response.\n3. The Suspense component is used to provide a fallback UI (loading...) while the AsyncComponent is loading.\n\n### Important notes:\n\nWhen the 'stream' option is set to true, the following headers are added:\n\n```ts\n{\n  'Transfer-Encoding': 'chunked',\n  'Content-Type': 'text/html; charset=UTF-8',\n  'Content-Encoding': 'Identity'\n}\n```\n\n### References:\n\n- [Hono jsxRenderer documentation](https://hono.bayfront.cloud/Reference/Server/builtin/jsx-renderer)\n\n### Common use cases:\n\n- When you want to render a streaming response in your Hono application.\n- When you want to provide a fallback UI while an asynchronous component is loading.",
      "ruleTitle": "Using 'stream' option in jsxRenderer for Streaming Responses in Hono",
      "sourcePath": "docs/middleware/builtin/jsx-renderer.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to render JSX components in Hono using the Suspense and AsyncComponent. It also shows how to set headers for the response and how to use the Layout component for nested layouts. Understanding this rule is crucial for managing asynchronous operations and improving the user experience during data fetching or code splitting, as well as for structuring the application layout in a nested manner.",
      "ruleFile": "## Hono JSX Rendering, Headers Setting and Nested Layouts\n\nIn Hono, you can render JSX components using the `render` method. If you have components that might take some time to render, you can use the `Suspense` component to display a fallback content until the component is ready. Here is an example:\n\n```ts\napp.get('/', (c) => {\n  return c.render(\n    <Suspense fallback={<div>loading...</div>}>\n      <AsyncComponent />\n    </Suspense>\n  )\n})\n```\n\nWhen rendering the JSX, Hono can also set certain headers for the response. By default, if `true` is set, the following headers are added:\n\n```ts\n{\n  'Transfer-Encoding': 'chunked',\n  'Content-Type': 'text/html; charset=UTF-8',\n  'Content-Encoding': 'Identity'\n}\n```\n\nYou can customize these headers by specifying the Record values.\n\nHono also supports nested layouts through the `Layout` component. You can use this component to nest your application layouts as needed.\n\n```tsx\napp.use(\n  jsxRenderer(({ children }) => {\n    re\n```\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common Use Cases\n\n- Rendering JSX components in Hono\n- Setting headers for the response\n- Using nested layouts in Hono",
      "ruleTitle": "Rendering JSX, Setting Headers and Using Nested Layouts in Hono",
      "sourcePath": "docs/middleware/builtin/jsx-renderer.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the jsxRenderer in Hono for creating nested layouts. It shows how to use the children and Layout props to create a nested structure of components, which is a common pattern in React and JSX-based frameworks. This pattern is useful for creating complex UI structures in a modular and reusable way.",
      "ruleFile": "## Rule File\n\nThis rule demonstrates how to use the jsxRenderer in Hono to create nested layouts. The jsxRenderer is a middleware that allows you to use JSX syntax in your Hono applications.\n\nHere is the code snippet:\n\n```tsx\napp.use(\n  jsxRenderer(({ children }) => {\n    return (\n      <html>\n        <body>{children}</body>\n      </html>\n    )\n  })\n)\n\nconst blog = new Hono()\nblog.use(\n  jsxRenderer(({ children, Layout }) => {\n    return (\n      <Layout>\n        <nav>Blog Menu</nav>\n        <div>{children}</div>\n      </Layout>\n    )\n  })\n)\n\napp.route('/blog', blog)\n```\n\nIn this snippet, the jsxRenderer is used to create a layout for the application. The children prop is used to render the nested components inside the layout. The Layout component is used to wrap the nested components, creating a nested structure.\n\nImportant notes:\n\n- The jsxRenderer is a middleware, so it should be used with the app.use() method.\n- The children and Layout props are standard in React and JSX-based frameworks, and they are used to create nested structures.\n\nCommon use cases:\n\n- Creating complex UI structures in a modular and reusable way.\n- Using JSX syntax in Hono applications.",
      "ruleTitle": "Creating Nested Layouts with jsxRenderer in Hono",
      "sourcePath": "docs/middleware/builtin/jsx-renderer.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `useRequestContext()` function in Hono to access the request context within a JSX component. This is useful when you need to display or use request-specific data within your components.",
      "ruleFile": "## Using `useRequestContext()` in Hono\n\nThe `useRequestContext()` function in Hono allows you to access the request context within a JSX component. This is useful when you need to display or use request-specific data within your components.\n\nHere is a code snippet demonstrating its usage:\n\n```tsx\nimport { useRequestContext, jsxRenderer } from 'hono/jsx-renderer'\n\nconst app = new Hono()\napp.use(jsxRenderer())\n\nconst RequestUrlBadge: FC = () => {\n  const c = useRequestContext()\n  return <b>{c.req.url}</b>\n}\n\napp.get('/page/info', (c) => {\n  return c.render(\n    <div>\n      You are accessing: <RequestUrlBadge />\n    </div>\n  )\n})\n```\n\nIn this example, `useRequestContext()` is used within the `RequestUrlBadge` component to access the request URL. This URL is then displayed within a bold (`<b>`) HTML element.\n\nNote: You can't use `useRequestContext()` with the Deno's `precompile` JSX option. Use the `react-jsx` instead.\n\nCommon use cases for this function include displaying the request URL, path, headers, or other request-specific data within your components.",
      "ruleTitle": "Using `useRequestContext()` in Hono to Access Request Context within JSX Components",
      "sourcePath": "docs/middleware/builtin/jsx-renderer.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates the correct JSX configuration for Hono framework. It shows how to set up the compiler options to use 'react-jsx' instead of 'precompile' for JSX. This is crucial because 'useRequestContext()' cannot be used with Deno's 'precompile' JSX option.",
      "ruleFile": "## JSX Configuration in Hono Framework\n\nIn Hono framework, the JSX configuration is set in the compiler options. It is important to use 'react-jsx' instead of 'precompile' for JSX. This is because 'useRequestContext()' cannot be used with Deno's 'precompile' JSX option.\n\nHere is the correct configuration:\n\n```json\n\"compilerOptions\": {\n     \"jsx\": \"react-jsx\",\n     \"jsxImportSource\": \"hono/jsx\"\n   }\n }\n```\n\n### How it works\n\nThe 'jsx' option in the compiler options is set to 'react-jsx'. This allows the use of 'useRequestContext()' in Hono.\n\nThe 'jsxImportSource' option is set to 'hono/jsx'. This specifies the module to be used as the source of JSX-related functions.\n\n### Important notes\n\n- 'useRequestContext()' cannot be used with Deno's 'precompile' JSX option.\n- Always use 'react-jsx' for JSX in Hono.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.io/)\n\n### Common use cases\n\n- Setting up JSX configuration in Hono framework.",
      "ruleTitle": "Setting Up JSX Configuration in Hono Framework",
      "sourcePath": "docs/middleware/builtin/jsx-renderer.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the ContextRenderer interface in Hono to pass additional content to the renderer. This is particularly useful when you want to modify the contents of the head tag depending on the page. The rule also shows how to use the jsxRenderer function to return a JSX element and how to use the render method to render a JSX element with specific properties.",
      "ruleFile": "## Rule: Using ContextRenderer to Pass Additional Content to the Renderer in Hono\n\nThis rule demonstrates how to use the `ContextRenderer` interface in Hono to pass additional content to the renderer. This is particularly useful when you want to modify the contents of the head tag depending on the page.\n\nHere is the code snippet:\n\n```tsx\ndeclare module 'hono' {\n  interface ContextRenderer {\n    (\n      content: string | Promise<string>,\n      props: { title: string }\n    ): Response\n  }\n}\n\nconst app = new Hono()\n\napp.get(\n  '/page/*',\n  jsxRenderer(({ children, title }) => {\n    return (\n      <html>\n        <head>\n          <title>{title}</title>\n        </head>\n        <body>\n          <header>Menu</header>\n          <div>{children}</div>\n        </body>\n      </html>\n    )\n  })\n)\n\napp.get('/page/favorites', (c) => {\n  return c.render(\n    <div>\n      <ul>\n        <li>Eating sushi</li>\n        <li>Watching baseball games</li>\n      </ul>\n    </div>,\n    {\n      title: 'My favorites',\n    }\n  )\n})\n```\n\n### How it works\n\n1. The `ContextRenderer` interface is declared with a function that takes a content (which can be a string or a Promise that resolves to a string) and a props object with a title property.\n2. The `jsxRenderer` function is used in the `app.get` method to return a JSX element.\n3. The `render` method is used in another `app.get` method to render a JSX element with specific properties.\n\n### Important notes\n\n- The `ContextRenderer` interface allows you to pass additional content to the renderer, which can be useful for modifying the contents of the head tag depending on the page.\n- The `jsxRenderer` function and the `render` method are used to render JSX elements.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.io/)\n\n### Common use cases\n\n- Modifying the contents of the head tag depending on the page\n- Rendering JSX elements with specific properties",
      "ruleTitle": "Using ContextRenderer to Pass Additional Content to the Renderer in Hono",
      "sourcePath": "docs/middleware/builtin/jsx-renderer.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the Pretty JSON middleware in Hono to enable JSON pretty print for JSON response body. This is useful for improving the readability of JSON responses, especially when dealing with large and complex JSON objects.",
      "ruleFile": "## Pretty JSON Middleware in Hono\n\nPretty JSON middleware in Hono enables '_JSON pretty print_' for JSON response body. By simply adding `?pretty` to the URL query param, the JSON strings are prettified.\n\nHere is an example:\n\n```js\n// GET /\n{\"project\":{\"name\":\"Hono\",\"repository\":\"https://github.com/honojs/hono\"}}\n```\n\nWhen the `?pretty` query parameter is added to the URL, the JSON response will be prettified:\n\n```js\n// GET /?pretty\n{\n  \"project\": {\n    \"name\": \"Hono\",\n    \"repository\": \"https://github.com/honojs/hono\"\n  }\n}\n```\n\n### How it works\n\nThe Pretty JSON middleware intercepts the JSON response and formats it in a more readable way if the `?pretty` query parameter is present in the URL.\n\n### Important notes\n\n- The Pretty JSON middleware should be used judiciously as it adds overhead to the response time, especially for large JSON objects.\n\n### References\n\n- [Hono Documentation](https://github.com/honojs/hono)\n\n### Common use cases\n\n- Debugging: The Pretty JSON middleware can be very useful during development and debugging when you need to inspect the JSON response.\n- API Documentation: It can also be used in API documentation to present the JSON response in a more readable way.",
      "ruleTitle": "Using Pretty JSON Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/pretty-json.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'prettyJSON' function in Hono to format JSON responses for better readability. By adding '?pretty' to the URL query parameter, the JSON strings are formatted in a more readable way, which can be particularly useful during debugging or when presenting data to end users.",
      "ruleFile": "## Prettifying JSON Responses in Hono\n\nIn Hono, you can use the 'prettyJSON' function to format JSON responses. This can be done by adding '?pretty' to the URL query parameter. The JSON strings will then be formatted in a more readable way.\n\nHere is an example of how to use it:\n\n```ts\nimport { Hono } from 'hono'\nimport { prettyJSON } from 'hono/pretty-json'\n\nconst app = new Hono()\n\napp.use(prettyJSON()) // With options: prettyJSON({ space: 4 })\n```\n\nAnd here is an example of the result:\n\n```js\n// GET /?pretty\n{\n  \"project\": {\n    \"name\": \"Hono\",\n    \"repository\": \"https://github.com/honojs/hono\"\n  }\n}\n```\n\nThis feature can be particularly useful during debugging or when presenting data to end users.\n\n### Important notes\n\n- The 'prettyJSON' function is part of the 'hono/pretty-json' package, so make sure to import it before using it.\n- You can customize the amount of space used for indentation by passing an object with a 'space' property to the 'prettyJSON' function. The default value is 2.\n\n### References\n\n- [Hono Documentation](https://honojs.com/docs)\n\n### Common use cases\n\n- Debugging: Prettifying JSON can make it easier to spot errors or inconsistencies in the data.\n- User interface: If you're presenting JSON data directly to the end user, prettifying it can make it more readable and user-friendly.",
      "ruleTitle": "Prettifying JSON Responses in Hono",
      "sourcePath": "docs/middleware/builtin/pretty-json.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'prettyJSON' middleware in Hono to format JSON responses. This is useful for improving the readability of JSON responses, especially during development and debugging.",
      "ruleFile": "## Using prettyJSON Middleware in Hono\n\nThis code snippet demonstrates how to use the 'prettyJSON' middleware in Hono to format JSON responses.\n\n```ts\nimport { Hono } from 'hono'\nimport { prettyJSON } from 'hono/pretty-json'\n\nconst app = new Hono()\n\napp.use(prettyJSON()) // With options: prettyJSON({ space: 4 })\napp.get('/', (c) => {\n  return c.json({ message: 'Hono!' })\n})\n```\n\n### How it works\n\n1. Import the 'Hono' and 'prettyJSON' modules from the 'hono' package.\n2. Create a new Hono application.\n3. Use the 'prettyJSON' middleware in the Hono application. You can optionally pass an options object to the 'prettyJSON' function to customize the formatting. For example, 'prettyJSON({ space: 4 })' will use 4 spaces for indentation.\n4. Define a GET route that returns a JSON response.\n\n### Important notes\n\n- The 'prettyJSON' middleware should be used before defining the routes that return JSON responses.\n\n### References\n\n- [Hono Documentation](https://github.com/honojs/hono)\n\n### Common use cases\n\n- Improving the readability of JSON responses during development and debugging.",
      "ruleTitle": "Using prettyJSON Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/pretty-json.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the Request ID Middleware in Hono. The Request ID Middleware generates a unique ID for each request, which can be used in handlers and middleware. This is useful for tracking requests and debugging.",
      "ruleFile": "## Request ID Middleware in Hono\n\nThis code demonstrates how to import and use the Request ID Middleware in Hono. The Request ID Middleware generates a unique ID for each request, which can be used in handlers and middleware.\n\n```ts\nimport { Hono } from 'hono'\nimport { requestId } from 'hono/request-id'\n```\n\nAfter importing, you can use the Request ID Middleware in your Hono application. You can access the Request ID through the `requestId` variable in the handlers and middleware to which the Request ID Middleware is applied.\n\nThis feature is useful for tracking requests and debugging. It can also be used to log request data, correlate logs for specific requests, and more.\n\n### References\n\n- [Hono Documentation](https://hono.bosch.io/docs/)\n\n### Common Use Cases\n\n- Tracking requests\n- Debugging\n- Logging request data\n- Correlating logs for specific requests",
      "ruleTitle": "Using Request ID Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/request-id.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'RequestIdVariables' type in Hono to explicitly specify the type of variables. It also shows how to set up a new Hono application with these variables. This is crucial for type safety and ensuring that the correct data types are used throughout the application.",
      "ruleFile": "## Using RequestIdVariables in Hono\n\nThis code snippet demonstrates how to use the 'RequestIdVariables' type in Hono to explicitly specify the type of variables. This is crucial for type safety and ensuring that the correct data types are used throughout the application.\n\n```ts\nimport type { RequestIdVariables } from 'hono/request-id'\n\nconst app = new Hono<{\n  Variables: RequestIdVariables\n}>()\n```\n\n### How it works\n\n1. The 'RequestIdVariables' type is imported from 'hono/request-id'.\n2. A new Hono application is set up, with the 'Variables' type explicitly set to 'RequestIdVariables'.\n\n### Important notes\n\n- This is a good practice for ensuring type safety in your Hono application.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- When setting up a new Hono application and you want to ensure type safety.",
      "ruleTitle": "Using RequestIdVariables for Type Safety in Hono",
      "sourcePath": "docs/middleware/builtin/request-id.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use bearer authentication in Hono. Bearer authentication is a common method used in APIs to authenticate HTTP requests. The rule shows how to add the 'Authorization' header with 'Bearer {token}' as the header value in the request.",
      "ruleFile": "## Bearer Authentication in Hono\n\nThis code demonstrates how to use bearer authentication in Hono. Bearer authentication is a common method used in APIs to authenticate HTTP requests.\n\n```sh\ncurl -H 'Authorization: Bearer honoiscool' http://localhost:8787/auth/page\n```\n\nIn this example, 'honoiscool' is the bearer token. This token is added in the 'Authorization' header of the HTTP request.\n\n### How it works\n\nThe HTTP client adds the 'Authorization' header with 'Bearer {token}' as the header value in the request. The server then verifies this token to authenticate the request.\n\n### Important notes\n\nYour `token` must match the regex `/[A-Za-z0-9._~+/-]+=*/`, otherwise a 400 error will be returned.\n\n### References\n\n- [Hono Documentation](https://www.eclipse.org/hono/docs/)\n\n### Common use cases\n\nThis method is commonly used when you want to authenticate HTTP requests in your Hono application.",
      "ruleTitle": "Using Bearer Authentication in Hono",
      "sourcePath": "docs/middleware/builtin/bearer-auth.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the 'bearerAuth' module from the Hono framework for handling Bearer token authentication. It is a common practice in web development to secure endpoints using Bearer token authentication, and this rule provides a clear example of how to implement this in Hono.",
      "ruleFile": "## Importing and Using Bearer Authentication in Hono\n\nThis code snippet demonstrates how to import and use the 'bearerAuth' module from the Hono framework for handling Bearer token authentication.\n\n```ts\nimport { Hono } from 'hono'\nimport { bearerAuth } from 'hono/bearer-auth'\n```\n\n### How it works\n\n1. The 'Hono' object is imported from the 'hono' package. This is the main object that is used to interact with the Hono framework.\n2. The 'bearerAuth' module is imported from 'hono/bearer-auth'. This module provides functionality for handling Bearer token authentication.\n\n### Important notes\n\nYour `token` must match the regex `/[A-Za-z0-9._~+/-]+=*/`, otherwise a 400 error will be returned. Notably, this regex accommodates both URL-safe Base64 and standard Base64.\n\n### References\n\n- Hono Documentation: [https://hono.bjss.com/docs](https://hono.bjss.com/docs)\n\n### Common use cases\n\n- Securing endpoints with Bearer token authentication.\n- Validating Bearer tokens in requests.",
      "ruleTitle": "Importing and Using Bearer Authentication in Hono",
      "sourcePath": "docs/middleware/builtin/bearer-auth.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to implement bearer token authentication in Hono. It shows how to restrict access to specific routes and methods using a bearer token. This is crucial for securing your application and ensuring that only authorized users can access certain parts of your application.",
      "ruleFile": "## Bearer Token Authentication in Hono\n\nThis code snippet demonstrates how to implement bearer token authentication in Hono. It shows how to restrict access to specific routes and methods using a bearer token.\n\n```ts\nconst app = new Hono()\n\nconst token = 'honoiscool'\n\napp.use('/api/*', bearerAuth({ token }))\n\napp.get('/api/page', (c) => {\n  return c.json({ message: 'You are authorized' })\n})\n```\n\n### How it works\n\n1. A new Hono application is created.\n2. A bearer token is defined.\n3. The `app.use` method is used to apply the `bearerAuth` middleware to all routes starting with '/api/'. This middleware checks if the request contains the correct bearer token.\n4. If the request contains the correct bearer token, the user is authorized and can access the '/api/page' route.\n\n### Important notes\n\n- The `bearerAuth` middleware does not require the bearer token to be a JWT, just that it matches the above regex.\n- This code snippet does not handle the case where the request does not contain a bearer token or contains an incorrect bearer token. In a real application, you would need to handle these cases and return appropriate error responses.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common use cases\n\n- Restricting access to certain routes in your application.\n- Implementing token-based authentication.",
      "ruleTitle": "Bearer Token Authentication in Hono",
      "sourcePath": "docs/middleware/builtin/bearer-auth.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to implement bearer token authentication in Hono. It shows how to restrict access to specific routes and methods using a token, and how to implement multiple tokens for different levels of access.",
      "ruleFile": "## Bearer Token Authentication in Hono\n\nThis code snippet demonstrates how to implement bearer token authentication in Hono. It shows how to restrict access to specific routes and methods using a token, and how to implement multiple tokens for different levels of access.\n\n```ts\nconst app = new Hono()\n\nconst token = 'honoiscool'\n\napp.get('/api/page', (c) => {\n  return c.json({ message: 'Read posts' })\n})\n\napp.post('/api/page', bearerAuth({ token }), (c) => {\n  return c.json({ message: 'Created post!' }, 201)\n})\n```\n\n### How it works\n\nThe `bearerAuth` middleware is used to restrict access to the POST route. It checks if the request includes the correct bearer token in the Authorization header. If the token is correct, the request is allowed to proceed. If not, the request is rejected.\n\n### Important notes\n\n- The `bearerAuth` middleware should be used on any routes that require authentication.\n- The token should be kept secret and secure.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Restricting access to certain routes or methods to authenticated users.\n- Implementing different levels of access using multiple tokens.",
      "ruleTitle": "Implementing Bearer Token Authentication in Hono",
      "sourcePath": "docs/middleware/builtin/bearer-auth.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to implement multiple tokens for different levels of access in Hono. It shows how to restrict certain HTTP methods to a privileged token, while allowing read access to any valid token. This is crucial for maintaining security and access control in web applications.",
      "ruleFile": "## Implementing Multiple Tokens for Different Access Levels in Hono\n\nThis code snippet demonstrates how to implement multiple tokens for different levels of access in Hono. It shows how to restrict certain HTTP methods to a privileged token, while allowing read access to any valid token.\n\n```ts\nconst app = new Hono()\n\nconst readToken = 'read'\nconst privilegedToken = 'read+write'\nconst privilegedMethods = ['POST', 'PUT', 'PATCH', 'DELETE']\n\napp.on('GET', '/api/page/*', async (c, next) => {\n  // List of valid tokens\n  const bearer = bearerAuth({ token: [readToken, privilegedToken] })\n  return bearer(c, next)\n})\napp.on(privilegedMethods, '/api/page/*', async (c, next) => {\n  // Single valid privileged token\n  const bearer = bearerAuth({ token: privilegedToken })\n  return bearer(c, next)\n})\n\n// Define handlers for GET, POST, etc.\n```\n\n### How it works\n\nThe `app.on` method is used to define handlers for different HTTP methods and paths. The `bearerAuth` function is used to authenticate the request using the provided tokens.\n\n### Important notes\n\n- The `bearerAuth` function takes an object with a `token` property, which can be a single token or an array of tokens.\n- The `privilegedMethods` array contains the HTTP methods that require the privileged token.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Implementing different levels of access in a web application\n- Restricting certain actions to privileged users",
      "ruleTitle": "Implementing Multiple Tokens for Different Access Levels in Hono",
      "sourcePath": "docs/middleware/builtin/bearer-auth.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the bearerAuth middleware in Hono to authenticate requests using bearer tokens. It shows how to define a custom token verification function, which is useful when you need to implement custom logic for token validation, such as checking the token against a dynamic value or a database.",
      "ruleFile": "## Bearer Token Authentication in Hono\n\nThis code snippet demonstrates how to use the `bearerAuth` middleware in Hono to authenticate requests using bearer tokens. It also shows how to define a custom token verification function.\n\n```ts\nconst app = new Hono()\n\napp.use(\n  '/auth-verify-token/*',\n  bearerAuth({\n    verifyToken: async (token, c) => {\n      return token === 'dynamic-token'\n    },\n  })\n)\n```\n\nIn this example, the `verifyToken` function checks if the provided token equals the string 'dynamic-token'. If it does, the function returns `true`, indicating that the token is valid.\n\n### How it works\n\nThe `bearerAuth` middleware intercepts incoming requests and checks the Authorization header for a bearer token. If a token is found, it is passed to the `verifyToken` function for validation.\n\n### Important notes\n\n- The `verifyToken` function should return a boolean indicating whether the token is valid or not.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Protecting routes or endpoints that require authentication.\n- Implementing custom logic for token validation.",
      "ruleTitle": "Using Bearer Token Authentication in Hono",
      "sourcePath": "docs/middleware/builtin/bearer-auth.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the combine functions from the Hono web framework. These functions are used to control the execution of middleware in the application, allowing for more complex logic and control flow.",
      "ruleFile": "## Importing and Using Combine Functions in Hono\n\nIn Hono, the `combine` module provides three functions that control the execution of middleware: `some`, `every`, and `except`.\n\n```ts\nimport { Hono } from 'hono'\nimport { some, every, except } from 'hono/combine'\n```\n\n### How it Works\n\n- `some` runs only one of the given middleware.\n- `every` runs all given middleware.\n- `except` runs all given middleware only if a condition is not met.\n\n### Important Notes\n\nThese functions are used to create complex access control rules and other logic in your Hono application.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common Use Cases\n\n- Restricting access to certain routes based on user roles or permissions.\n- Running specific middleware only under certain conditions.",
      "ruleTitle": "Importing and Using Combine Functions in Hono",
      "sourcePath": "docs/middleware/builtin/combine.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'combine' middleware in Hono to create complex access control rules. It shows how to use the 'some' and 'every' functions to combine different middleware functions and create a rule that requires either all or some conditions to be met.",
      "ruleFile": "## Hono Combine Middleware Usage\n\nThis code snippet demonstrates how to use the 'combine' middleware in Hono to create complex access control rules. It shows the usage of 'some' and 'every' functions to combine different middleware functions.\n\n```ts\nimport { Hono } from 'hono'\nimport { bearerAuth } from 'hono/bearer-auth'\nimport { getConnInfo } from 'hono/cloudflare-workers'\nimport { every, some } from 'hono/combine'\nimport { ipRestriction } from 'hono/ip-restriction'\nimport { rateLimit } from '@/my-rate-limit'\n\nconst app = new Hono()\n\napp.use(\n  '*',\n  some(\n    every(\n      ipRestriction(getConnInfo, { allowList: ['192.168.0.2'] }),\n      bearerAuth({ token })\n    ),\n    // If both conditions are met, rateLimit will not execute.\n    rateLimit()\n  )\n)\n\napp.get('/', (c) => c.text('Hello Hono!'))\n```\n\nIn this code:\n- 'some' function runs the first middleware that returns true. Middleware is applied in order, and if any middleware exits successfully, subsequent middleware will not run.\n- 'every' function runs all middleware and requires all to return true.\n\nThis pattern is useful when you want to apply multiple conditions for a route and want either all or some of them to be met.",
      "ruleTitle": "Using Combine Middleware in Hono for Complex Access Control Rules",
      "sourcePath": "docs/middleware/builtin/combine.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'some' function from Hono's 'combine' module to control the execution of middleware in a Hono application. It shows how to conditionally apply middleware based on the result of a previous middleware function, in this case, skipping rate limiting if the client has a valid token.",
      "ruleFile": "## Using 'some' to Control Middleware Execution in Hono\n\nThis code demonstrates how to use the 'some' function from Hono's 'combine' module to control the execution of middleware in a Hono application. The 'some' function runs the first middleware that returns true, and if any middleware exits successfully, subsequent middleware will not run.\n\n```ts\nimport { some } from 'hono/combine'\nimport { bearerAuth } from 'hono/bearer-auth'\nimport { myRateLimit } from '@/rate-limit'\n\n// If client has a valid token, skip rate limiting.\n// Otherwise, apply rate limiting.\napp.use(\n  '/api/*',\n  some(bearerAuth({ token }), myRateLimit({ limit: 100 }))\n)\n```\n\nIn this example, if the 'bearerAuth' middleware function returns true (indicating that the client has a valid token), the 'myRateLimit' middleware function will not run, effectively skipping rate limiting for clients with a valid token.\n\n### Important Notes\n\n- The order of middleware functions passed to 'some' matters, as they are applied in order.\n- The 'some' function is part of Hono's 'combine' module, which provides functions for controlling middleware execution.\n\n### References\n\n- [Hono Documentation](https://hono.bjacobel.com/docs)\n\n### Common Use Cases\n\n- Conditionally applying middleware based on the result of a previous middleware function.\n- Skipping certain middleware functions for specific requests or clients.",
      "ruleTitle": "Controlling Middleware Execution with 'some' in Hono",
      "sourcePath": "docs/middleware/builtin/combine.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'some' and 'every' functions from Hono's 'combine' module to control the execution of middleware. It shows how to conditionally apply middleware based on the result of a check function. This is useful for applying different middleware under different conditions, improving the flexibility and control of the application.",
      "ruleFile": "## Using 'some' and 'every' from Hono's 'combine' module to control middleware execution\n\nThis code snippet demonstrates how to use the 'some' and 'every' functions from Hono's 'combine' module to control the execution of middleware.\n\n```ts\nimport { some, every } from 'hono/combine'\nimport { bearerAuth } from 'hono/bearer-auth'\nimport { myCheckLocalNetwork } from '@/check-local-network'\nimport { myRateLimit } from '@/rate-limit'\n\n// If client is in local network, skip authentication and rate limiting.\n// Otherwise, apply authentication and rate limiting.\napp.use(\n  '/api/*',\n  some(\n    myCheckLocalNetwork(),\n    every(bearerAuth({ token }), myRateLimit({ limit: 100 }))\n  )\n)\n```\n\n### How it works\n\nThe 'some' function runs the provided middleware until one of them does not throw an error. In this case, it first checks if the client is in the local network. If it is, the 'every' function is not executed.\n\nThe 'every' function runs all the provided middleware in order and stops if any of them throw an error. In this case, it applies the 'bearerAuth' and 'myRateLimit' middleware.\n\n### Important notes\n\n- The order of middleware in the 'every' function matters. If the 'bearerAuth' middleware throws an error, the 'myRateLimit' middleware will not run.\n\n### References\n\n- [Hono documentation](https://hono.bjss.com/docs)\n\n### Common use cases\n\n- Conditionally applying middleware based on the result of a check function\n- Controlling the order and execution of middleware",
      "ruleTitle": "Controlling Middleware Execution with 'some' and 'every' in Hono",
      "sourcePath": "docs/middleware/builtin/combine.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'except' function from Hono's 'combine' module to exclude certain routes from middleware application. In this case, it's used to bypass authentication for public API routes. This is a common use case in web development where certain routes are public and do not require authentication, while others do.",
      "ruleFile": "## Using 'except' function to exclude routes from middleware application\n\nThis code snippet demonstrates how to use the 'except' function from Hono's 'combine' module to exclude certain routes from middleware application. In this case, it's used to bypass authentication for public API routes.\n\n```ts\nimport { except } from 'hono/combine'\nimport { bearerAuth } from 'hono/bearer-auth'\n\n// If client is accessing public API, skip authentication.\n// Otherwise, require a valid token.\napp.use('/api/*', except('/api/public/*', bearerAuth({ token })))\n```\n\n### How it works\n\nThe 'except' function takes two arguments: a condition and a middleware function. If the condition is met (in this case, if the route matches '/api/public/*'), the middleware function is not applied. This allows for selective application of middleware based on the route.\n\n### Important notes\n\n- The condition can be a string or a function.\n- If multiple targets need to be matched, pass them as an array.\n\n### References\n\n- [Hono documentation](https://hono.bouzuya.net/)\n\n### Common use cases\n\n- Bypassing authentication for public API routes\n- Applying specific middleware only to certain routes",
      "ruleTitle": "Excluding Routes from Middleware Application in Hono",
      "sourcePath": "docs/middleware/builtin/combine.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to implement Cross-Origin Resource Sharing (CORS) in Hono using middleware. CORS is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated. It's a crucial aspect of web security and is necessary when building APIs that are accessed from different origins.",
      "ruleFile": "## Implementing CORS in Hono using Middleware\n\nThis code snippet demonstrates how to implement Cross-Origin Resource Sharing (CORS) in Hono using middleware.\n\n### Code Snippet:\n\n```ts\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\n\nconst app = new Hono()\n\n// CORS should be called before the route\napp.use('/api/*', cors())\napp.use(\n  '/api2/*',\n  cors({\n    origin: 'http://example.com',\n    allowHeaders: ['X-Custom-Header']\n  })\n)\n```\n\n### How it works:\n\n1. Import the necessary modules from Hono.\n2. Create a new Hono application.\n3. Use the `app.use()` function to apply the CORS middleware to specific routes.\n\n### Important notes:\n\n- The CORS middleware should be called before defining the route.\n- You can customize the CORS configuration by passing an options object to the `cors()` function.\n\n### References:\n\n- [Hono Documentation](https://hono.beyondco.de/)\n\n### Common use cases:\n\n- Building APIs that need to be accessed from different origins.\n- Implementing web security measures in your Hono application.",
      "ruleTitle": "Implementing CORS in Hono using Middleware",
      "sourcePath": "docs/middleware/builtin/cors.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to implement Cross-Origin Resource Sharing (CORS) in Hono using middleware. CORS is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated. It's a crucial aspect of web security and is necessary when building APIs that are accessed from different origins.",
      "ruleFile": "## Implementing CORS in Hono\n\nThis code snippet demonstrates how to implement Cross-Origin Resource Sharing (CORS) in Hono using middleware.\n\n```ts\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\n\nconst app = new Hono()\n\n// CORS should be called before the route\napp.use('/api/*', cors())\napp.use(\n  '/api2/*',\n  cors({\n    origin: 'http://example.com',\n    allowHeaders: ['X-Custom-Header', 'Upgrade-Insecure-Requests'],\n    allowMethods: ['POST', 'GET', 'OPTIONS'],\n    exposeHeaders: ['Content-Length', 'X-Kuma-Revision'],\n    maxAge: 600,\n    credentials: true,\n  })\n)\n\napp.all('/api/abc', (c) => {\n  return c.json({ success: true })\n})\napp.all('/api2/abc', (c) => {\n  return c.json({ success: true })\n})\n```\n\n### How it works\n\nThe `cors()` function is used as middleware in the application. It should be called before the route that needs to implement CORS. The function takes an optional configuration object where you can specify the origin, allowed headers, allowed methods, exposed headers, max age for the preflight request, and whether credentials are included in the requests.\n\n### Important notes\n\n- The `cors()` function should be called before the route.\n- The configuration object passed to the `cors()` function is optional.\n\n### References\n\n- [Hono Documentation](https://hono.beyondx.io/docs)\n\n### Common use cases\n\n- Implementing CORS in APIs that are accessed from different origins.",
      "ruleTitle": "Implementing CORS in Hono",
      "sourcePath": "docs/middleware/builtin/cors.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up Cross-Origin Resource Sharing (CORS) in Hono. CORS is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated. It's a crucial aspect of web security and is essential for any server serving resources to clients on different domains.",
      "ruleFile": "## Setting Up CORS in Hono\n\nThis code snippet demonstrates how to set up Cross-Origin Resource Sharing (CORS) in Hono.\n\n```ts\napp.use(\n  '/api3/*',\n  cors({\n    origin: ['https://example.com', 'https://example.com'],\n  })\n)\n\n// Or you can use \"function\"\napp.use(\n  '/api4/*',\n  cors({\n    // `c` is a `Context` object\n    origin: (origin, c) => {\n      return origin.endsWith('.example.com')\n        ? origin\n        : 'http://example.com'\n    },\n  })\n)\n```\n\n### How it works\n\nThe `app.use` function is used to set up middleware functions in Hono. In this case, it's being used to set up CORS. The `cors` function takes an options object, which can include an `origin` property. This property can be a string, an array of strings, or a function that returns a string. The value(s) represent the domain(s) that are allowed to access the server's resources.\n\n### Important notes\n\n- The `origin` function receives two arguments: the origin of the request and the context object. You can use this function to dynamically determine the allowed origin.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/latest/)\n\n### Common use cases\n\n- Allowing specific trusted domains to access your server's resources.\n- Dynamically determining the allowed origin based on the request.",
      "ruleTitle": "Setting Up CORS in Hono",
      "sourcePath": "docs/middleware/builtin/cors.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use CORS middleware in Hono framework. CORS (Cross-Origin Resource Sharing) is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated. It's a crucial aspect of web security and should be properly implemented in any web application.",
      "ruleFile": "## Using CORS Middleware in Hono\n\nThis code snippet demonstrates how to use CORS middleware in Hono framework. CORS (Cross-Origin Resource Sharing) is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated.\n\n```ts\napp.use('*', async (c, next) => {\n  const corsMiddlewareHandler = cors({\n    origin: c.env.CORS_ORIGIN,\n  })\n  return corsMiddlewareHandler(c, next)\n})\n```\n\n### How it works\n\nThe `app.use` function is used to apply the CORS middleware to every route (`*`). The middleware is configured with an origin that is retrieved from the environment variables (`c.env.CORS_ORIGIN`). This allows for flexibility as the origin can be easily changed depending on the environment the application is running in.\n\n### Important notes\n\n- The CORS middleware should be applied before any other middleware that needs to be protected.\n- The origin should be a trusted domain to prevent potential security risks.\n\n### References\n\n- [CORS on MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)\n\n### Common use cases\n\n- Protecting routes that serve sensitive data.\n- Allowing cross-origin requests in development environment.",
      "ruleTitle": "Using CORS Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/cors.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the CSRF protection middleware in the Hono framework. CSRF (Cross-Site Request Forgery) is a type of attack that tricks the victim into submitting a malicious request. It uses the identity and privileges of the victim to perform an undesired function on their behalf. In Hono, CSRF protection can be added to the application by using the 'csrf' middleware. This rule also shows how to specify origins using the 'origin' option, which is useful in environments where browsers do not send 'Origin' headers, or environments that use reverse proxies to remove 'Origin' headers.",
      "ruleFile": "## CSRF Protection in Hono\n\nThis code demonstrates how to use the CSRF protection middleware in Hono.\n\n```ts\nimport { Hono } from 'hono'\nimport { csrf } from 'hono/csrf'\n\nconst app = new Hono()\n\napp.use(csrf())\n\n// Specifying origins with using `origin` option\n// string\napp.use(csrf({ origin: 'myapp.example.com' }))\n\n// string[]\napp.use(\n  csrf({\n```\n\n### How it works\n\n1. Import the 'Hono' and 'csrf' modules.\n2. Create a new Hono application.\n3. Use the 'csrf' middleware in the application.\n4. Specify the origins using the 'origin' option if necessary.\n\n### Important notes\n\n- In environments where browsers do not send 'Origin' headers, or environments that use reverse proxies to remove 'Origin' headers, use the 'origin' option to specify the origins.\n\n### References\n\n- [Hono CSRF Middleware](https://hono.beyondco.de/middleware/csrf.html)\n\n### Common use cases\n\n- Protecting your Hono application from CSRF attacks.\n- Specifying origins in environments where 'Origin' headers are not sent or removed.",
      "ruleTitle": "Using CSRF Protection Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/csrf.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use CSRF protection in Hono framework. CSRF (Cross-Site Request Forgery) is a type of attack that tricks the victim into submitting a malicious request. It uses the identity and privileges of the victim to perform an undesired function on their behalf. The rule shows how to import and use the CSRF middleware, and how to specify origins using the `origin` option in different ways: as a string, as an array of strings, or as a function.",
      "ruleFile": "## CSRF Protection in Hono\n\nIn Hono, you can use CSRF protection middleware to protect your application from Cross-Site Request Forgery attacks. Here is how you can do it:\n\n```ts\nimport { Hono } from 'hono'\nimport { csrf } from 'hono/csrf'\n\nconst app = new Hono()\n\napp.use(csrf())\n\n// Specifying origins with using `origin` option\n// string\napp.use(csrf({ origin: 'myapp.example.com' }))\n\n// string[]\napp.use(\n  csrf({\n    origin: ['myapp.example.com', 'development.myapp.example.com'],\n  })\n)\n\n// Function\n// It is strongly recommended that the protocol be verified to ensure a match to `$`.\n// You should *never* do a forward match.\napp.use(\n  '*',\n  csrf({\n    origin: (origin) =>\n      /https://(\\w+.)?myapp.example.com$/.test(origin),\n  })\n)\n```\n\n### How it works\n\nThe `csrf()` function is a middleware that adds CSRF protection to your application. You can specify the origins that are allowed to make requests to your application using the `origin` option. The `origin` option can be a string, an array of strings, or a function that returns a boolean.\n\n### Important notes\n\n- It is strongly recommended to verify the protocol in the function form of the `origin` option to ensure a match to `$`. You should never do a forward match.\n\n### References\n\n- [Hono CSRF middleware](https://hono.com/docs/csrf)\n\n### Common use cases\n\n- Protecting your application from CSRF attacks\n- Restricting the origins that can make requests to your application",
      "ruleTitle": "Using CSRF Protection in Hono",
      "sourcePath": "docs/middleware/builtin/csrf.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'jwk' middleware in Hono framework to handle JSON Web Key Set (JWKS) for authentication. This is a common practice in securing routes in a Hono application.",
      "ruleFile": "## Importing and Using 'jwk' Middleware in Hono\n\nThis code demonstrates how to import and use the 'jwk' middleware in Hono for handling JSON Web Key Set (JWKS) for authentication.\n\n```ts\nimport { Hono } from 'hono'\nimport { jwk } from 'hono/jwk'\n\nconst app = new Hono()\n\napp.use(\n  '/auth/*',\n  jwk({\n    jwks_uri: `https://${backendServer}/.well-known/jwks.json`,\n  })\n)\n\napp.get('/auth/page', (c) => {\n  return c.text('You are authenticated')\n})\n```\n\n### How it works\n\n1. The 'jwk' middleware is imported from 'hono/jwk'.\n2. A new Hono application is created.\n3. The 'jwk' middleware is used on all routes starting with '/auth/'. The middleware is configured with the URI of the JWKS.\n4. When a GET request is made to '/auth/page', if the request is authenticated, a text response 'You are authenticated' is returned.\n\n### Important notes\n\n- The 'jwk' middleware requires a valid JWKS URI to function correctly.\n\n### References\n\n- [Hono Documentation](https://hono.beyondnlp.com)\n\n### Common use cases\n\n- Securing routes in a Hono application with JWT authentication.",
      "ruleTitle": "Using 'jwk' Middleware for Authentication in Hono",
      "sourcePath": "docs/middleware/builtin/jwk.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'jwk' middleware in the Hono framework for authentication. The 'jwk' middleware is used to validate JSON Web Tokens (JWTs) from a JSON Web Key Set (JWKS) endpoint. This is a common practice in securing routes in a web application.",
      "ruleFile": "## Hono Framework: Using 'jwk' Middleware for Authentication\n\nThis code demonstrates how to use the 'jwk' middleware in the Hono framework for authentication. The 'jwk' middleware is used to validate JSON Web Tokens (JWTs) from a JSON Web Key Set (JWKS) endpoint.\n\n```ts\nimport { Hono } from 'hono'\nimport { jwk } from 'hono/jwk'\n\nconst app = new Hono()\n\napp.use(\n  '/auth/*',\n  jwk({\n    jwks_uri: `https://${backendServer}/.well-known/jwks.json`,\n  })\n)\n\napp.get('/auth/page', (c) => {\n  return c.text('You are authorized')\n})\n```\n\n### How it works\n\n1. The 'jwk' middleware is imported from 'hono/jwk'.\n2. A new Hono application is created.\n3. The 'jwk' middleware is used on all routes starting with '/auth'. It validates JWTs using the JWKS endpoint specified.\n4. If the JWT is valid, the user is authorized and can access the '/auth/page' route.\n\n### Important notes\n\n- The 'jwk' middleware requires a JWKS endpoint to validate JWTs.\n- The JWKS endpoint is usually provided by the authentication server.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Securing routes in a web application with JWT authentication.",
      "ruleTitle": "Using 'jwk' Middleware for Authentication in Hono Framework",
      "sourcePath": "docs/middleware/builtin/jwk.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the jwk middleware in Hono to authenticate routes and extract JWT payload. It shows how to secure a route and how to retrieve the JWT payload from the context object.",
      "ruleFile": "## Using jwk Middleware for Authentication in Hono\n\nThis code snippet demonstrates how to use the jwk middleware in Hono to authenticate routes and extract JWT payload. The jwk middleware is used to secure the '/auth/*' route. The middleware is configured with the URI of the JSON Web Key Set (JWKS) which contains the public keys used to verify any JSON Web Token (JWT) issued by the authorization server.\n\n```ts\nconst app = new Hono()\n\napp.use(\n  '/auth/*',\n  jwk({\n    jwks_uri: `https://${backendServer}/.well-known/jwks.json`,\n  })\n)\n\napp.get('/auth/page', (c) => {\n  const payload = c.get('jwtPayload')\n  return c.json(payload) // eg: { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022 }\n})\n```\n\nIn the '/auth/page' route handler, the JWT payload is retrieved from the context object using the 'get' method and returned as a JSON response.\n\n### Important Notes\n\n- The jwk middleware must be configured with the correct JWKS URI.\n- The JWT payload can be retrieved from the context object in the route handler.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common Use Cases\n\n- Securing routes with JWT authentication.\n- Extracting JWT payload for user identification or authorization.",
      "ruleTitle": "Using jwk Middleware for Authentication and JWT Payload Extraction in Hono",
      "sourcePath": "docs/middleware/builtin/jwk.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use context storage in Hono. Context storage is a crucial feature in Hono that allows developers to store and retrieve context data across different parts of their application. This is especially useful in scenarios where state needs to be shared across different middleware or routes.",
      "ruleFile": "## Importing and Using Context Storage in Hono\n\nThis code snippet demonstrates how to import and use context storage in Hono.\n\n```ts\nimport { Hono } from 'hono'\nimport { contextStorage, getContext } from 'hono/context-storage'\n```\n\n### How it works\n\n1. The `Hono` object is imported from the `hono` package.\n2. The `contextStorage` and `getContext` functions are imported from `hono/context-storage`.\n\n### Important notes\n\n- The `getContext()` function will return the current Context object if the `contextStorage()` is applied as a middleware.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common use cases\n\n- Storing and retrieving state across different middleware or routes.",
      "ruleTitle": "Importing and Using Context Storage in Hono",
      "sourcePath": "docs/middleware/builtin/context-storage.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the contextStorage middleware in Hono to store and retrieve context-specific data. It shows how to set a variable in the context and how to retrieve it later, even outside of the handler. This is useful in scenarios where you need to pass data between different parts of your application without directly linking them.",
      "ruleFile": "## Using contextStorage in Hono\n\nThe `contextStorage` middleware in Hono allows you to store and retrieve context-specific data. This can be useful when you need to pass data between different parts of your application without directly linking them.\n\nHere is an example of how to use it:\n\n```ts\ntype Env = {\n  Variables: {\n    message: string\n  }\n}\n\nconst app = new Hono<Env>()\n\napp.use(contextStorage())\n\napp.use(async (c, next) => {\n  c.set('message', 'Hello!')\n  await next()\n})\n\n// You can access the variable outside the handler.\nconst getMessage = () => {\n  return getContext<Env>().var.message\n}\n\napp.get('/', (c) => {\n  return c.text(getMessage())\n})\n```\n\nIn this example, we first define an environment type `Env` with a `message` variable. We then create a new Hono application and use the `contextStorage` middleware. In the next middleware, we set the `message` variable in the context to 'Hello!'. Finally, we define a function `getMessage` that retrieves the `message` variable from the context and use it in a route handler.\n\n### Important notes\n\n- The `contextStorage` middleware must be used before any middleware that wants to use the context storage.\n- The `getContext` function can be used to retrieve the current context object.\n\n### References\n\n- [Hono documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Passing data between middleware and route handlers\n- Storing request-specific data",
      "ruleTitle": "Using contextStorage to Store and Retrieve Data in Hono",
      "sourcePath": "docs/middleware/builtin/context-storage.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use context storage in Hono to access bindings outside the handler. This is useful in Cloudflare Workers where you may need to access and manipulate bindings such as KV storage.",
      "ruleFile": "## Accessing Bindings Outside the Handler in Hono\n\nIn Hono, you can use context storage to access bindings outside the handler. This is particularly useful in Cloudflare Workers where you may need to access and manipulate bindings such as KV storage.\n\nHere is a code snippet demonstrating this:\n\n```ts\ntype Env = {\n  Bindings: {\n    KV: KVNamespace\n  }\n}\n\nconst app = new Hono<Env>()\n\napp.use(contextStorage())\n\nconst setKV = (value: string) => {\n  return getContext<Env>().env.KV.put('key', value)\n}\n```\n\nIn this code:\n\n1. We define a type `Env` that includes a `Bindings` property with a `KV` property of type `KVNamespace`.\n2. We create a new Hono app with the `Env` type.\n3. We use the `contextStorage` middleware.\n4. We define a `setKV` function that uses `getContext` to access the `KV` binding and put a value.\n\n### Important Notes\n\n- `contextStorage` is a middleware provided by Hono that allows you to access the context outside the handler.\n- `getContext` is a function provided by Hono that allows you to access the context.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common Use Cases\n\n- Storing and retrieving data in KV storage in Cloudflare Workers.",
      "ruleTitle": "Accessing Bindings Outside the Handler in Hono",
      "sourcePath": "docs/middleware/builtin/context-storage.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the cache module from the Hono framework. Caching can significantly improve the performance of an application by storing the result of expensive computations or frequently accessed data. In this context, the rule shows how to set up caching in a Hono application, which is a crucial aspect of optimizing web applications.",
      "ruleFile": "## Importing and Using Cache in Hono\n\nThis rule demonstrates how to import and use the cache module from the Hono framework.\n\n```ts\nimport { Hono } from 'hono'\nimport { cache } from 'hono/cache'\n```\n\nAfter importing the necessary modules, you can use the `cache` function in your application routes. The `cache` function takes an object as an argument, where you can specify the cache name and cache control directives.\n\n```ts\napp.get(\n  '*',\n  cache({\n    cacheName: 'my-app',\n    cacheControl: 'max-age=3600',\n  })\n)\n```\n\nIn this example, the cache name is 'my-app' and the cache control directive is 'max-age=3600', which means the cached data will be considered fresh for 3600 seconds.\n\n### Important Notes\n\n- Deno does not respect headers, so if you need to update the cache, you will need to implement your own mechanism.\n\n### References\n\n- [Hono Documentation](https://hono.bsd.ac/docs)\n\n### Common Use Cases\n\n- Caching responses for frequently accessed routes\n- Storing the result of expensive computations to improve performance",
      "ruleTitle": "Importing and Using Cache in Hono",
      "sourcePath": "docs/middleware/builtin/cache.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to manage request timeouts in a Hono application. It shows how to set a maximum duration for requests and how to use the timeout middleware with both default and custom settings. This is crucial in maintaining the performance and responsiveness of the application.",
      "ruleFile": "## Managing Request Timeouts in Hono\n\nThis code demonstrates how to manage request timeouts in a Hono application. It shows how to set a maximum duration for requests and how to use the timeout middleware with both default and custom settings.\n\n### Code Snippet:\n\n```ts\nimport { Hono } from 'hono'\nimport { timeout } from 'hono/timeout'\n\nconst app = new Hono()\n\n// Applying a 5-second timeout\napp.use('/api', timeout(5000))\n```\n\n### How it works\n\nThe `timeout` function from 'hono/timeout' is used as a middleware in the Hono application. It is applied to the '/api' route and sets a maximum duration of 5 seconds for any request to this route.\n\n### Important notes\n\n- The timeout value is specified in milliseconds.\n\n### References\n\n- Hono Documentation: [Managing Request Timeouts](https://hono.bespoken.io/docs/managing-request-timeouts/)\n\n### Common use cases\n\n- Ensuring that requests to certain routes do not exceed a specified duration to maintain the performance and responsiveness of the application.",
      "ruleTitle": "Managing Request Timeouts in Hono",
      "sourcePath": "docs/middleware/builtin/timeout.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to apply a timeout middleware to a specific route in Hono. This is crucial in managing server resources and preventing long-running requests from consuming too much server time.",
      "ruleFile": "## Hono Timeout Middleware Usage\n\nThis code demonstrates how to apply a timeout middleware to a specific route in Hono. This is useful in managing server resources and preventing long-running requests from consuming too much server time.\n\n```ts\nconst app = new Hono()\n\n// Applying a 5-second timeout\napp.use('/api', timeout(5000))\n\n// Handling a route\napp.get('/api/data', async (c) => {\n  // Your route handler logic\n  return c.json({ data: 'Your data here' })\n})\n```\n\n### How it works\n\nThe `timeout` function from 'hono/timeout' is used as a middleware for the '/api' route. This function will automatically end any request to '/api' that takes longer than 5000 milliseconds (5 seconds) to complete.\n\n### Important notes\n\n- The timeout middleware should be applied before the route handler to ensure it takes effect.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common use cases\n\n- Applying a timeout to resource-intensive API endpoints to prevent server overload.",
      "ruleTitle": "Applying Timeout Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/timeout.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set a timeout for a specific route and handle the timeout exception in Hono. This is crucial in managing long running processes and ensuring that the server does not get stuck waiting for a response that may never come.",
      "ruleFile": "## Setting a Timeout and Handling Timeout Exception in Hono\n\nIn Hono, you can set a timeout for a specific route using the `timeout` middleware. If the specified duration is exceeded, the middleware will automatically reject the promise and potentially throw an error. You can also customize the exception that is thrown when a timeout occurs.\n\nHere is an example of how to do this:\n\n```ts\nimport { HTTPException } from 'hono/http-exception'\n\n// Custom exception factory function\nconst customTimeoutException = (context) =>\n  new HTTPException(408, {\n    message: `Request timeout after waiting ${context.req.headers.get(\n      'Duration'\n    )} seconds. Please try again later.`,\n  })\n\n// for Static Exception Message\n// const customTimeoutException = new HTTPException(408, {\n//   message: 'Operation timed out. Please try again later.'\n// });\n\n// Applying a 1-minute timeout with a custom exception\napp.use('/api/long-process', timeout(60000, customTimeoutException))\n\napp.get('/api/long-process', async (c) => {\n  // Simulate a long process\n  await new Promise((resolve) => setTimeout(resolve, 61000))\n  return c.json({ data: 'This usually takes longer' })\n})\n```\n\n### How it works\n\nThe `timeout` middleware is applied to the `/api/long-process` route with a duration of 60000 milliseconds (1 minute). If the process takes longer than this, a custom `HTTPException` is thrown with a status code of 408 (Request Timeout) and a custom message.\n\n### Important notes\n\n- The duration for the timeout can be specified in milliseconds.\n- You can customize the exception that is thrown when a timeout occurs by providing a factory function or a static exception message.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common use cases\n\n- Long running processes that may potentially exceed a reasonable response time.\n- Routes that need to enforce a strict response time limit.",
      "ruleTitle": "Setting a Timeout and Handling Timeout Exception in Hono",
      "sourcePath": "docs/middleware/builtin/timeout.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle timeouts in Hono with streaming Server-Sent Events (SSE). It shows how to set a timeout for a stream, close the stream when the timeout is reached, and handle the event when a client closes the connection. This is crucial for maintaining efficient and responsive server-client communication.",
      "ruleFile": "## Handling Timeouts in Hono with Streaming Server-Sent Events (SSE)\n\nThe following code snippet demonstrates how to handle timeouts in Hono with streaming Server-Sent Events (SSE).\n\n```ts\napp.get('/sse', async (c) => {\n  let id = 0\n  let running = true\n  let timer: number | undefined\n\n  return streamSSE(c, async (stream) => {\n    timer = setTimeout(() => {\n      console.log('Stream timeout reached, closing stream')\n      stream.close()\n    }, 3000) as unknown as number\n\n    stream.onAbort(async () => {\n      console.log('Client closed connection')\n      running = false\n      clearTimeout(timer)\n    })\n\n    while (running) {\n      const message = `It is ${new Date().toISOString()}`\n      await stream.writeSSE({\n        data: message,\n        event: 'time-update',\n        id: String(id++),\n      })\n      await stream.sleep(1000)\n    }\n  })\n})\n```\n\n### How it works\n\n1. A timeout is set for the stream using `setTimeout`. If the timeout is reached, the stream is closed.\n2. The `onAbort` event handler is set for the stream. If the client closes the connection, the `running` flag is set to false and the timeout is cleared.\n3. While the `running` flag is true, the server sends a Server-Sent Event to the client every second.\n\n### Important notes\n\n- The timeout middleware cannot be used with streams. Thus, use `stream.close` and `setTimeout` together.\n- Be cautious about the order of middleware, especially when using error-handling or other timing-related middleware, as it might affect the behavior of this timeout middleware.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common use cases\n\n- Real-time applications that require server-client communication with a timeout.",
      "ruleTitle": "Handling Timeouts in Hono with Streaming Server-Sent Events (SSE)",
      "sourcePath": "docs/middleware/builtin/timeout.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the logger middleware in the Hono web framework. Logger middleware is crucial for tracking and debugging the flow of requests and responses in your application. It logs details of each request, which can be useful for debugging and monitoring purposes.",
      "ruleFile": "## Logger Middleware in Hono\n\nThis code demonstrates how to use the logger middleware in Hono.\n\n```ts\nimport { Hono } from 'hono'\nimport { logger } from 'hono/logger'\n\nconst app = new Hono()\n\napp.use(logger())\napp.get('/', (c) => c.text('Hello Hono!'))\n```\n\n### How it works\n\n1. Import the Hono framework and the logger middleware.\n2. Create a new Hono application.\n3. Use the logger middleware in your application with `app.use(logger())`.\n4. Define a route for your application. In this case, a GET request to the root URL will return 'Hello Hono!'.\n\n### Important notes\n\n- The logger middleware logs the details of each request, which can be useful for debugging and monitoring purposes.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common use cases\n\n- Use the logger middleware in your Hono application to log details of each request for debugging and monitoring purposes.",
      "ruleTitle": "Using Logger Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/logger.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a custom logger function in Hono. Custom loggers can be used to format and display log messages in a way that suits the specific needs of the application. This can be particularly useful for debugging and monitoring purposes.",
      "ruleFile": "## Custom Logger in Hono\n\nThis code snippet demonstrates how to set up a custom logger function in Hono. The logger function takes a message and an arbitrary number of additional string arguments, which are then printed to the console.\n\n```ts\nexport const customLogger = (message: string, ...rest: string[]) => {\n  console.log(message, ...rest)\n}\n\napp.use(logger(customLogger))\n```\n\n### How it works\n\nThe `customLogger` function is defined with two parameters: `message` and `...rest`. The `message` parameter is the main log message, while `...rest` is an array of additional string arguments. These arguments are spread into the `console.log` function, allowing for multiple arguments to be logged at once.\n\nThe `customLogger` function is then passed to the `app.use` method, which adds it as a middleware to the application. This means that the `customLogger` function will be called for every request to the application, allowing for comprehensive logging.\n\n### Important notes\n\n- The `...rest` parameter uses the rest parameter syntax, which allows for an arbitrary number of arguments to be passed to the function.\n- The `customLogger` function is added as a middleware using the `app.use` method. This means that it will be called for every request to the application.\n\n### References\n\n- [Hono documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Debugging: Custom loggers can be used to log specific information about requests, which can be useful for debugging purposes.\n- Monitoring: Custom loggers can also be used to monitor the state of the application, such as the number of requests or the response times.",
      "ruleTitle": "Setting Up a Custom Logger in Hono",
      "sourcePath": "docs/middleware/builtin/logger.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to implement a custom logger in Hono. Logging is a critical part of any application for debugging and tracking purposes. By creating a custom logger, developers can control what information gets logged and how it is formatted.",
      "ruleFile": "## Custom Logger in Hono\n\nThis code demonstrates how to implement a custom logger in Hono. Logging is a critical part of any application for debugging and tracking purposes. By creating a custom logger, developers can control what information gets logged and how it is formatted.\n\n```ts\nexport const customLogger = (message: string, ...rest: string[]) => {\n  console.log(message, ...rest)\n}\n\napp.use(logger(customLogger))\n```\n\nIn the route:\n\n```ts\napp.post('/blog', (c) => {\n  // Routing logic\n\n  customLogger('Blog saved:', `Path: ${blog.url},`, `ID: ${blog.id}`)\n  // Output\n  // <-- POST /blog\n  // Blog saved: Path: /blog/example, ID: 1\n  // --> POST /blog 201 93ms\n\n  // Return Context\n})\n```\n\n### How it works\n\nThe `customLogger` function is defined to log a message along with any additional arguments. It is then used as a middleware in the Hono application using `app.use()`. In the route, the `customLogger` is used to log information about the blog post.\n\n### Important notes\n\n- The `customLogger` can be used in any part of the application where logging is required.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common use cases\n\n- Logging request and response data\n- Debugging application errors",
      "ruleTitle": "Implementing a Custom Logger in Hono",
      "sourcePath": "docs/middleware/builtin/logger.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the ETag middleware in Hono. ETag headers are part of HTTP, the web protocol. They are used to determine whether the client's cached version of the content is the same as that of the server. If the ETag received from the server matches the one the client has, the content is not downloaded again, saving bandwidth.",
      "ruleFile": "## ETag Middleware Usage in Hono\n\nThis code demonstrates how to use the ETag middleware in Hono.\n\n```ts\nimport { Hono } from 'hono'\nimport { etag } from 'hono/etag'\n\nconst app = new Hono()\n\napp.use('/etag/*', etag())\napp.get('/etag/abc', (c) => {\n  return c.text('Hono is cool')\n})\n```\n\n### How it works\n\n1. Import the Hono and etag modules.\n2. Create a new Hono application.\n3. Use the etag middleware for any routes that match '/etag/*'.\n4. Define a GET route '/etag/abc' that returns a text response.\n\n### Important notes\n\n- The ETag middleware automatically generates an ETag for the response based on the response body.\n- If the client sends an 'If-None-Match' request header with the same ETag, the server will respond with a 304 Not Modified status and no body.\n\n### References\n\n- [Hono Documentation](https://hono.bjubnes.com/docs)\n\n### Common use cases\n\n- Use the ETag middleware when you want to enable client-side caching and save bandwidth.",
      "ruleTitle": "Using ETag Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/etag.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'secureHeaders' middleware in the Hono framework to simplify the setup of security headers. It shows how to import the necessary modules, use the middleware with default settings, and how to suppress unnecessary headers by setting them to false. This is crucial for enhancing the security of web applications by controlling the activation and deactivation of specific security headers.",
      "ruleFile": "## Importing and Using 'secureHeaders' Middleware in Hono\n\nThis code demonstrates how to import and use the 'secureHeaders' middleware in Hono to simplify the setup of security headers.\n\n```ts\nimport { Hono } from 'hono'\nimport { secureHeaders } from 'hono/secure-headers'\n```\n\nYou can use the middleware with the optimal settings by default.\n\n```ts\nconst app = new Hono()\napp.use(secureHeaders())\n```\n\nYou can also suppress unnecessary headers by setting them to false.\n\nThis middleware is inspired in part by the capabilities of Helmet, and it allows you to control the activation and deactivation of specific security headers. This is crucial for enhancing the security of your web applications.\n\n### Important Notes\n\n- Always ensure to import the necessary modules before using them.\n- Use the middleware with the default settings unless there's a need to suppress some headers.\n\n### References\n\n- [Hono Documentation](https://hono.bespoken.io/)\n\n### Common Use Cases\n\n- Enhancing the security of web applications by controlling the activation and deactivation of specific security headers.",
      "ruleTitle": "Importing and Using 'secureHeaders' Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/secure-headers.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to activate specific security headers in Hono. Security headers are a fundamental part of web security. When set correctly, they can make your application more resistant to common web vulnerabilities. By setting them to false, you can suppress unnecessary headers, providing a more streamlined and secure application.",
      "ruleFile": "## Activating Specific Security Headers in Hono\n\nThis code demonstrates how to activate specific security headers in Hono. Security headers are a crucial part of web security and can make your application more resistant to common web vulnerabilities.\n\n### Code Snippet\n\n```ts\nimport { Hono } from 'hono'\nimport { secureHeaders } from 'hono/secure-headers'\n\nconst app = new Hono()\napp.use(secureHeaders())\n```\n\n### How it Works\n\nThe `secureHeaders()` function is imported from the 'hono/secure-headers' module and used as middleware in the Hono application. By default, it applies optimal settings for security headers.\n\n### Important Notes\n\nYou can suppress unnecessary headers by setting them to false, as shown below:\n\n```ts\nconst app = new Hono()\napp.use(\n  '*',\n  secureHeaders({\n    xFrameOptions: false,\n    xXssProtection: false,\n  })\n)\n```\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common Use Cases\n\n- Enhancing the security of your web application by activating specific security headers.\n- Suppressing unnecessary headers for a more streamlined application.",
      "ruleTitle": "Activating Specific Security Headers in Hono",
      "sourcePath": "docs/middleware/builtin/secure-headers.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the secure-headers middleware in Hono to manage HTTP headers for security. It shows how to suppress unnecessary headers by setting them to false, which can be crucial for optimizing security settings and performance in a Hono application.",
      "ruleFile": "# Using Secure Headers Middleware in Hono\n\nThis code demonstrates how to use the secure-headers middleware in Hono to manage HTTP headers for security.\n\n## Code Snippet\n\n```ts\nconst app = new Hono()\napp.use(\n  '*',\n  secureHeaders({\n    xFrameOptions: false,\n    xXssProtection: false,\n  })\n)\n```\n\n## How it Works\n\nIn this code snippet, the `secureHeaders` function is used as a middleware in the Hono application. The function is called with an object as an argument, which specifies the HTTP headers to be suppressed (set to false).\n\n## Important Notes\n\n- The `secureHeaders` function can be used to set, suppress, or modify HTTP headers for security.\n- The headers are set globally for all routes in the application (indicated by the '*' wildcard).\n\n## References\n\n- [Hono Documentation](https://hono.bryntum.com/docs)\n\n## Common Use Cases\n\n- Suppressing unnecessary HTTP headers for security or performance optimization in a Hono application.",
      "ruleTitle": "Using Secure Headers Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/secure-headers.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set secure headers in Hono. Secure headers help to protect your application from certain types of attacks and vulnerabilities. The rule shows how to override default header values using a string, which can be useful for customizing security settings.",
      "ruleFile": "## Setting Secure Headers in Hono\n\nThis code demonstrates how to set secure headers in Hono. Secure headers help to protect your application from certain types of attacks and vulnerabilities.\n\n```ts\nconst app = new Hono()\napp.use(\n  '*',\n  secureHeaders({\n    strictTransportSecurity:\n      'max-age=63072000; includeSubDomains; preload',\n    xFrameOptions: 'DENY',\n    xXssProtection: '1',\n  })\n)\n```\n\nIn this example, the `strictTransportSecurity`, `xFrameOptions`, and `xXssProtection` headers are set. These headers can help to prevent clickjacking attacks, cross-site scripting attacks, and enforce secure (HTTPS) connections.\n\n### How it Works\n\nThe `app.use` function is used to apply middleware to the Hono application. The `secureHeaders` function is a middleware function that sets the specified headers.\n\n### Important Notes\n\n- The `secureHeaders` function takes an object as an argument. Each property in this object corresponds to a header that should be set.\n- The value of each property can be a boolean or a string. If the value is `false`, the header will not be set. If the value is a string, the header will be set with that value.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common Use Cases\n\n- Setting secure headers to protect your application from attacks and vulnerabilities.",
      "ruleTitle": "Setting Secure Headers in Hono",
      "sourcePath": "docs/middleware/builtin/secure-headers.md",
      "category": "builtin"
    },
    {
      "reasoning": "The order of middleware specification in Hono can affect the final outcome of the headers. This rule is important because it demonstrates how the order of middleware usage can manipulate the same header differently. In the given example, when secureHeaders() is used before poweredBy(), the 'x-powered-by' header is removed. But when poweredBy() is used before secureHeaders(), the 'x-powered-by' header is added. This can have significant implications on the security and functionality of the application.",
      "ruleFile": "## Middleware Order Matters in Hono\n\nIn Hono, the order in which middleware is specified can affect the final outcome of the headers. This is especially important when dealing with middleware that manipulates the same header.\n\nConsider the following examples:\n\n```ts\nconst app = new Hono()\napp.use(secureHeaders())\napp.use(poweredBy())\n```\n\nIn this case, secureHeaders() operates first and the 'x-powered-by' header is removed.\n\n```ts\nconst app = new Hono()\napp.use(poweredBy())\napp.use(secureHeaders())\n```\n\nIn this case, poweredBy() operates first and the 'x-powered-by' header is added.\n\nThis demonstrates that the order of middleware usage can have significant implications on the security and functionality of the application. Therefore, it's crucial to be cautious about the order of specification when dealing with middleware in Hono.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common Use Cases\n\n- Setting up security headers in a Hono application\n- Manipulating headers in a Hono application",
      "ruleTitle": "Middleware Order Matters in Hono",
      "sourcePath": "docs/middleware/builtin/secure-headers.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates the order of middleware usage in Hono and how it affects the final outcome. In this case, the order of using 'secureHeaders()' and 'poweredBy()' middleware determines whether the 'x-powered-by' header is included or not.",
      "ruleFile": "## Middleware Order in Hono\n\nIn Hono, the order of middleware usage is significant and can affect the final outcome. This is demonstrated in the following code snippets:\n\n```ts\nconst app = new Hono()\napp.use(secureHeaders())\napp.use(poweredBy())\n```\n\nIn the above case, the 'secureHeaders()' middleware operates first and removes the 'x-powered-by' header. Then, the 'poweredBy()' middleware operates but does not add the 'x-powered-by' header as it has already been removed.\n\n```ts\nconst app = new Hono()\napp.use(poweredBy())\napp.use(secureHeaders())\n```\n\nIn this case, the 'poweredBy()' middleware operates first and adds the 'x-powered-by' header. Then, the 'secureHeaders()' middleware operates but does not remove the 'x-powered-by' header as it has already been added.\n\n### How it works\n\nIn Hono, middleware functions are executed in the order they are used in the application. Therefore, the order of middleware usage can affect the final outcome.\n\n### Important notes\n\n- The order of middleware usage is significant in Hono.\n- The 'secureHeaders()' middleware removes the 'x-powered-by' header.\n- The 'poweredBy()' middleware adds the 'x-powered-by' header.\n\n### References\n\n- [Hono Documentation](https://hono.bespoken.io/)\n\n### Common use cases\n\n- Configuring headers in a Hono application.\n- Understanding the order of middleware execution in Hono.",
      "ruleTitle": "Middleware Order in Hono",
      "sourcePath": "docs/middleware/builtin/secure-headers.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to add a nonce (a random string that can only be used once) to a `script` or `style` element in Hono. This is a crucial aspect of Content Security Policy (CSP) which helps to prevent Cross-Site Scripting (XSS) attacks by allowing only scripts and styles that have a specific nonce value to be executed or applied.",
      "ruleFile": "This code snippet demonstrates how to add a nonce to a `script` or `style` element in Hono. The nonce is imported from `hono/secure-headers` and added to a `scriptSrc` or `styleSrc`. The nonce value can be predefined or generated by a function. The nonce value is then retrieved using `c.get('secureHeadersNonce')`.\n\nCode Snippet:\n```tsx\nimport { secureHeaders, NONCE } from 'hono/secure-headers'\nimport type { SecureHeadersVariables } from 'hono/secure-headers'\n\ntype Variables = SecureHeadersVariables\n\nconst app = new Hono<{ Variables: Variables }>()\n\napp.get(\n  '*',\n  secureHeaders({\n    contentSecurityPolicy: {\n      scriptSrc: [NONCE, 'https://allowed1.example.com'],\n    },\n  })\n)\n\napp.get('/', (c) => {\n  return c.html(\n    <html>\n      <body>\n        {/** contents */}\n        <script\n          src='/js/client.js'\n          nonce={c.get('secureHeadersNonce')}\n        />\n      </body>\n    </html>\n  )\n})\n```\n\nThis works by setting the nonce value to `scriptSrc` in the `secureHeaders` function. The nonce value is then retrieved in the `c.get('secureHeadersNonce')` function. This ensures that only scripts and styles with the specific nonce value can be executed or applied, enhancing the security of the web application.\n\nImportant Note: Always ensure that the nonce value is unique and random for each request to prevent potential security vulnerabilities.\n\nReferences: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce\n\nCommon Use Cases: This is commonly used in web applications that need to enhance their security by preventing XSS attacks.",
      "ruleTitle": "Adding a Nonce to a Script or Style Element in Hono",
      "sourcePath": "docs/middleware/builtin/secure-headers.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to generate and use a nonce value for secure headers in Hono. Nonce values are used to provide a layer of security that helps prevent replay attacks. In this example, a nonce value is generated for each request and used in the Content Security Policy for a script source. This ensures that the script can only be executed once, providing an additional layer of security.",
      "ruleFile": "## Generating and Using Nonce for Secure Headers in Hono\n\nIn Hono, you can generate and use a nonce value for secure headers. This is particularly useful for providing an additional layer of security by preventing replay attacks. Here's how you can do it:\n\n```tsx\nconst app = new Hono<{ Variables: { myNonce: string } }>()\n\nconst myNonceGenerator: ContentSecurityPolicyOptionHandler = (c) => {\n  const nonce = Math.random().toString(36).slice(2)\n  c.set('myNonce', nonce)\n  return `'nonce-${nonce}'`\n}\n\napp.get('*', secureHeaders({ contentSecurityPolicy: { scriptSrc: [myNonceGenerator, 'https://allowed1.example.com'], }, }))\n\napp.get('/', (c) => {\n  return c.html(\n    <html>\n      <body>\n        <script src='/js/client.js' nonce={c.get('myNonce')} />\n      </body>\n    </html>\n  )\n})\n```\n\n### How it works\n\n1. A new Hono app is created with a variable for the nonce.\n2. A nonce generator function is defined. This function is called on every request, generating a new nonce value and setting it in the context.\n3. The nonce generator is used in the Content Security Policy for a script source in the secure headers middleware.\n4. The nonce value is retrieved from the context and used in a script tag in the response.\n\n### Important notes\n\n- The nonce value should be unpredictable and generated anew for each request to prevent replay attacks.\n\n### References\n\n- [Hono Documentation](https://hono.boutique/docs/)\n\n### Common use cases\n\n- Use this pattern when you need to add an additional layer of security to your scripts by ensuring they can only be executed once per request.",
      "ruleTitle": "Generating and Using Nonce for Secure Headers in Hono",
      "sourcePath": "docs/middleware/builtin/secure-headers.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set the Permission-Policy header in Hono. The Permission-Policy header allows you to control which features and APIs can be used in the browser. This is crucial for security and privacy reasons, as it allows the developer to limit the capabilities of certain APIs, thereby reducing the potential attack surface.",
      "ruleFile": "## Setting Permission-Policy Header in Hono\n\nThe code snippet demonstrates how to set the Permission-Policy header in Hono. This header allows you to control which features and APIs can be used in the browser.\n\n```ts\nconst app = new Hono()\napp.use(\n  '*',\n  secureHeaders({\n    permissionsPolicy: {\n      fullscreen: ['self'],\n      bluetooth: ['none'],\n      payment: ['self', 'https://example.com'],\n      syncXhr: [],\n      camera: false,\n      microphone: true,\n      geolocation: ['*'],\n      usb: ['self', 'https://a.example.com', 'https://b.example.com'],\n      accelerometer: ['https://*.example.com'],\n      gyroscope: ['src'],\n      magnetometer: [\n        'https://a.example.com',\n        'https://b.example.com',\n      ],\n    },\n  })\n)\n```\n\n### How it works\n\nThe `secureHeaders` middleware is used to set the headers. The `permissionsPolicy` object is passed as an argument, where each key-value pair represents a feature and its allowed sources.\n\n### Important notes\n\n- The values can be a string, a boolean, or an array of strings.\n- The `self` keyword refers to the origin from which the document was served.\n- The `none` keyword means that the feature is disabled.\n\n### References\n\n- [MDN Web Docs - Feature Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy)\n\n### Common use cases\n\n- Limiting the capabilities of certain APIs for security reasons.\n- Controlling the features that can be used in the browser.",
      "ruleTitle": "Setting Permission-Policy Header in Hono",
      "sourcePath": "docs/middleware/builtin/secure-headers.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle trailing slashes in URLs using Hono's built-in functions `appendTrailingSlash` and `trimTrailingSlash`. This is crucial for URL normalization and can prevent potential issues related to content duplication and SEO.",
      "ruleFile": "## Hono: Handling Trailing Slashes in URLs\n\nIn Hono, you can use the `appendTrailingSlash` and `trimTrailingSlash` functions to manage trailing slashes in URLs. This is useful for URL normalization and can help avoid issues related to content duplication and SEO.\n\n### Import\n\n```ts\nimport { Hono } from 'hono'\nimport {\n  appendTrailingSlash,\n  trimTrailingSlash,\n} from 'hono/trailing-slash'\n```\n\n### Usage\n\nYou can use `appendTrailingSlash` to add a trailing slash to a URL if the content was not found. Similarly, `trimTrailingSlash` can be used to remove the trailing slash.\n\n```ts\nimport { Hono } from 'hono'\nimport { appendTrailingSlash } from 'hono/trailing-slash'\n\nconst app = new Hono()\n\napp.get('/about/me', appendTrailingSlash())\n```\n\nIn this example, a GET request to `/about/me` will be redirected to `/about/me/`.\n\n### Important Notes\n\n- These functions should be used carefully as improper use can lead to issues such as infinite redirects.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common Use Cases\n\n- URL normalization\n- Preventing content duplication",
      "ruleTitle": "Handling Trailing Slashes in URLs with Hono",
      "sourcePath": "docs/middleware/builtin/trailing-slash.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important because it demonstrates how to handle trailing slashes in URLs using Hono web framework. It shows how to append or trim trailing slashes from URLs which is crucial for consistent routing and SEO.",
      "ruleFile": "## Handling Trailing Slashes in Hono\n\nThis code demonstrates how to append or trim trailing slashes in URLs using Hono web framework.\n\n### Code Snippet\n\n```ts\nimport { Hono } from 'hono'\nimport { appendTrailingSlash } from 'hono/trailing-slash'\n\nconst app = new Hono({ strict: true })\n\napp.use(appendTrailingSlash())\napp.get('/about/me/', (c) => c.text('With Trailing Slash'))\n```\n\n### How it works\n\nThe `appendTrailingSlash` function from 'hono/trailing-slash' is used as a middleware in the Hono application. This function appends a trailing slash to the URL if it doesn't already have one.\n\n### Important notes\n\n- The `strict` option in the Hono constructor must be set to `true` for the trailing slash functions to work.\n\n### References\n\n- [Hono Documentation](https://hono.beyondnlp.com)\n\n### Common use cases\n\n- Ensuring consistent URL structure for SEO\n- Redirecting users to the correct URL",
      "ruleTitle": "Handling Trailing Slashes in Hono",
      "sourcePath": "docs/middleware/builtin/trailing-slash.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the methodOverride middleware in Hono to override the HTTP method of a request. This is useful when the client doesn't support certain HTTP methods, like DELETE or PUT, and instead sends a POST request with the intended method specified in a `_method` field.",
      "ruleFile": "## Method Override in Hono\n\nThis code demonstrates how to use the `methodOverride` middleware in Hono to override the HTTP method of a request.\n\n```ts\nimport { Hono } from 'hono'\nimport { methodOverride } from 'hono/method-override'\n\nconst app = new Hono()\n\n// If no options are specified, the value of `_method` in the form,\n// e.g. DELETE, is used as the method.\napp.use('/posts', methodOverride({ app }))\n```\n\n### How it works\n\nThe `methodOverride` middleware checks for a `_method` field in the request. If found, it changes the HTTP method of the request to the value of the `_method` field.\n\n### Important notes\n\n- This is useful when the client doesn't support certain HTTP methods, like DELETE or PUT, and instead sends a POST request with the intended method specified in a `_method` field.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common use cases\n\n- RESTful APIs where the client may not support all HTTP methods.",
      "ruleTitle": "Using Method Override Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/method-override.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the methodOverride middleware in Hono. This middleware allows you to use HTTP verbs such as DELETE or PUT in places where the client doesn't support it. This is particularly useful when dealing with HTML forms, which only support GET and POST methods.",
      "ruleFile": "## Using methodOverride Middleware in Hono\n\nThis code snippet demonstrates how to use the `methodOverride` middleware in Hono. This middleware allows you to use HTTP verbs such as DELETE or PUT in places where the client doesn't support it.\n\n```ts\nconst app = new Hono()\n\n// If no options are specified, the value of `_method` in the form,\n// e.g. DELETE, is used as the method.\napp.use('/posts', methodOverride({ app }))\n\napp.delete('/posts', (c) => {\n  // ....\n})\n```\n\n### How it works\n\nThe `methodOverride` middleware checks for the presence of a `_method` property in the form data. If it exists, it overrides the original HTTP method with the value of `_method`. In this example, if a form submits a POST request with `_method` set to DELETE, the middleware will change the request to a DELETE request.\n\n### Important notes\n\n- The `methodOverride` middleware should be used before any middleware that needs to know the method of the request.\n\n### References\n\n- [Hono documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common use cases\n\n- Handling form submissions that need to use HTTP verbs other than GET and POST.",
      "ruleTitle": "Using methodOverride Middleware in Hono",
      "sourcePath": "docs/middleware/builtin/method-override.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the method override feature in Hono to handle HTTP methods like DELETE which are not supported by HTML forms. This is a common workaround in web development to overcome the limitations of HTML forms.",
      "ruleFile": "## Method Override in Hono\n\nSince HTML forms cannot send a DELETE method, you can put the value `DELETE` in the property named `_method` and send it. And the handler for `app.delete()` will be executed.\n\nHere is an example of how to do it:\n\n```html\n<form action=\"/posts\" method=\"POST\">\n  <input type=\"hidden\" name=\"_method\" value=\"DELETE\" />\n  <input type=\"text\" name=\"id\" />\n</form>\n```\n\nAnd in your Hono application:\n\n```ts\nimport { methodOverride } from 'hono/method-override'\n\nconst app = new Hono()\napp.use('/posts', methodOverride({ app }))\n\napp.delete('/posts', () => {\n  // ...\n})\n```\n\nThis works by using a hidden input field with the name `_method` in your HTML form. When the form is submitted, Hono will check for this field and if it exists, it will override the method of the request with its value.\n\nThis is a common use case when you need to perform actions like deleting a resource from a server, which requires a DELETE method.\n\nReferences:\n- [Hono Documentation](https://hono.bouzuya.net/)\n\n",
      "ruleTitle": "Using Method Override in Hono",
      "sourcePath": "docs/middleware/builtin/method-override.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to override methods in Hono using different options such as form, header, and query. This is useful when you want to change the default behavior of a method or use a different method based on certain conditions.",
      "ruleFile": "## Method Override in Hono\n\nIn Hono, you can override methods using different options. This can be useful when you want to change the default behavior of a method or use a different method based on certain conditions.\n\nHere is a code snippet demonstrating this:\n\n```ts\napp.use('/posts', methodOverride({ app, form: '_custom_name' }))\napp.use('/posts', methodOverride({ app, header: 'X-METHOD-OVERRIDE' }))\napp.use('/posts', methodOverride({ app, query: '_method' }))\n```\n\nIn the above code:\n\n- `app` is the instance of `Hono` used in your application.\n- `form` is an optional key with a value that overrides the default method.\n- `header` is another optional key that can be used to override the method.\n- `query` is yet another optional key that can be used for method overriding.\n\n### Important Notes\n\n- The `app` option is required while the `form`, `header`, and `query` options are optional.\n- The `form`, `header`, and `query` options can be used to customize the method overriding behavior based on your application's requirements.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common Use Cases\n\n- Changing the default behavior of a method based on certain conditions.\n- Using a different method based on the request's form data, headers, or query parameters.",
      "ruleTitle": "Method Override in Hono",
      "sourcePath": "docs/middleware/builtin/method-override.md",
      "category": "builtin"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono web framework. It shows how to initialize a new Hono application and define a simple route that responds with a text message. This is a fundamental pattern in Hono and most web frameworks, and understanding it is crucial for building web applications.",
      "ruleFile": "## Creating a Basic Hono Application\n\nThis code snippet demonstrates how to create a basic 'Hello World' application using the Hono web framework.\n\n```ts\nimport { Hono } from 'jsr:@hono/hono'\nimport { handle } from 'jsr:@hono/hono/netlify'\n\nconst app = new Hono()\n\napp.get('/', (c) => {\n  return c.text('Hello Hono!')\n})\n\nexport default handle(app)\n```\n\n### How it works\n\n1. The `Hono` class is imported from the 'jsr:@hono/hono' module.\n2. The `handle` function is imported from the 'jsr:@hono/hono/netlify' module.\n3. A new instance of `Hono` is created.\n4. A GET route for the path '/' is defined. When this route is accessed, it responds with the text 'Hello Hono!'.\n5. The `handle` function is used to export the application.\n\n### Important notes\n\n- The `handle` function is specific to Netlify and is used to handle requests in a Netlify environment.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs)\n\n### Common use cases\n\n- Creating a basic web application with Hono.\n- Defining simple routes in a Hono application.",
      "ruleTitle": "Creating a Basic Hono Application",
      "sourcePath": "docs/getting-started/netlify.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic Hono application with Netlify. It shows how to import the necessary modules, create a new Hono application, define a route, and export the application to be handled by Netlify. It also explains how to run the application locally using the Netlify CLI and how to deploy it to production. Lastly, it shows how to access the Netlify's context through 'c.env'.",
      "ruleFile": "## Hono Application Setup with Netlify\n\nThis code snippet demonstrates how to set up a basic Hono application with Netlify.\n\n```ts\nimport { Hono } from 'jsr:@hono/hono'\nimport { handle } from 'jsr:@hono/hono/netlify'\n\nconst app = new Hono()\n\napp.get('/', (c) => {\n  return c.text('Hello Hono!')\n})\n\nexport default handle(app)\n```\n\nTo run the application locally, use the Netlify CLI:\n\n```sh\nnetlify dev\n```\n\nTo deploy the application to production, use the following command:\n\n```sh\nnetlify deploy --prod\n```\n\nYou can access the Netlify's context through 'c.env':\n\n```ts\nimport { Hono } from 'jsr:@hono/hono'\nimport { handle } from 'jsr:@hono/hono/netlify'\n\nconst app = new Hono()\n\napp.get('/', (c) => {\n  console.log(c.env)\n  return c.text('Hello Hono!')\n})\n\nexport default handle(app)\n```\n\n### Important Notes\n\n- Make sure to install the necessary packages before running the application.\n- The 'handle' function from '@hono/hono/netlify' is used to handle the Hono application.\n\n### References\n\n- [Hono Documentation](https://hono.js.org/)\n- [Netlify CLI Documentation](https://cli.netlify.com/)\n\n### Common Use Cases\n\n- Creating a basic Hono application with Netlify.\n- Accessing the Netlify's context in a Hono application.",
      "ruleTitle": "Setting Up a Basic Hono Application with Netlify",
      "sourcePath": "docs/getting-started/netlify.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy a Hono application using Netlify. It shows the command needed to deploy the application to production. Understanding this rule is crucial for developers to successfully deploy their Hono applications.",
      "ruleFile": "## Deploying a Hono Application with Netlify\n\nThis code snippet demonstrates how to deploy a Hono application using Netlify.\n\n```sh\nnetlify deploy --prod\n```\n\n### How it works\n\nThe `netlify deploy --prod` command deploys the application to production. The `--prod` flag indicates that the deployment is for the production environment.\n\n### Important notes\n\nEnsure that you have the necessary permissions and the Netlify CLI installed before running the command.\n\n### References\n\n- [Netlify CLI Documentation](https://cli.netlify.com/)\n\n### Common use cases\n\nThis command is typically used when you want to deploy your Hono application to the production environment.",
      "ruleTitle": "Deploying a Hono Application with Netlify",
      "sourcePath": "docs/getting-started/netlify.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to access the Netlify's Context through `c.env` in Hono. Understanding this rule allows developers to effectively use the environment variables and context in their Hono applications.",
      "ruleFile": "## Accessing Netlify's Context in Hono\n\nIn Hono, you can access the Netlify's `Context` through `c.env`. This is useful when you need to use environment variables or context in your application.\n\nHere is a code snippet demonstrating this:\n\n```ts\nimport { Hono } from 'jsr:@hono/hono'\nimport { handle } from 'jsr:@hono/hono/netlify'\n\n// Import the type definition\nimport type { Context } from 'https://edge.netlify.com/'\n\nexport type Env = {\n\n## `Context`\n\nYou can access the Netlify's `Context` through `c.env`:\n```\n\n### How it works\n\nIn the above code, `c.env` is used to access the Netlify's Context. This allows you to use environment variables and context in your Hono application.\n\n### Important notes\n\nEnsure that you have imported the necessary modules and type definitions before trying to access the `Context`.\n\n### References\n\n- Hono Documentation\n- Netlify Documentation\n\n### Common use cases\n\nThis is commonly used when you need to use environment variables or context in your Hono application.",
      "ruleTitle": "Accessing Netlify's Context in Hono",
      "sourcePath": "docs/getting-started/netlify.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a new project using the Bun framework and Hono. It shows the command necessary to initialize a new project with the latest version of Hono, and how to navigate into the project directory and install the necessary dependencies. Understanding this rule is crucial for setting up a new project correctly and efficiently.",
      "ruleFile": "## Creating a New Project with Bun and Hono\n\nThis code snippet demonstrates how to create a new project using the Bun framework and Hono.\n\n```sh\nbun create hono@latest my-app\ncd my-app\nbun install\n```\n\n### How it works\n\n1. The `bun create hono@latest my-app` command creates a new project named 'my-app' with the latest version of Hono.\n2. The `cd my-app` command navigates into the newly created project directory.\n3. The `bun install` command installs the necessary dependencies for the project.\n\n### Important notes\n\n- Ensure that Bun is installed and updated to its latest version before running these commands.\n\n### References\n\n- Official Bun website: https://bun.sh\n\n### Common use cases\n\n- Setting up a new project with Bun and Hono.",
      "ruleTitle": "Creating a New Project with Bun and Hono",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a new project with Hono using Bun, how to set up an existing project with Hono, and how to install the necessary dependencies. Understanding this rule is crucial for developers to get started with Hono and Bun.",
      "ruleFile": "## Creating and Setting Up a Hono Project with Bun\n\nThis guide demonstrates how to create a new project with Hono using Bun, how to set up an existing project with Hono, and how to install the necessary dependencies.\n\n### Creating a New Project\n\nTo create a new project with Hono, use the `bun create` command followed by `hono@latest` and your desired project name.\n\n```sh\nbun create hono@latest my-app\n```\n\nNext, navigate into your new project directory and install the dependencies with `bun install`.\n\n```sh\ncd my-app\nbun install\n```\n\n### Setting Up an Existing Project\n\nTo set up an existing Bun project with Hono, you only need to install the `hono` dependencies in the project root directory with `bun add hono`.\n\n```sh\nbun add hono\n```\n\n## Important Notes\n\n- Ensure that Bun is properly installed and updated to the latest version before creating or setting up a project with Hono.\n\n## References\n\n- [Bun Documentation](https://bun.js.org/)\n- [Hono Documentation](https://hono.eclipse.org/)\n\n## Common Use Cases\n\n- Starting a new project with Hono and Bun.\n- Adding Hono to an existing Bun project.",
      "ruleTitle": "Creating and Setting Up a Hono Project with Bun",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up an existing project with Hono dependencies using Bun, a package manager for Deno. It also shows how to create a simple 'Hello World' application using Hono.",
      "ruleFile": "## Installing Hono Dependencies in an Existing Project with Bun and Creating a Simple Hono Application\n\nThis code snippet demonstrates how to install Hono dependencies in an existing project using Bun, a package manager for Deno. It also shows how to create a simple 'Hello World' application using Hono.\n\n### Code Snippet:\n\n```sh\nbun add hono\n```\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\napp.get('/', (c) => c.text('Hello Bun!'))\n```\n\n### How it works:\n\n1. Navigate to the project directory (`cd my-app`)\n2. Install the dependencies using Bun (`bun install`)\n3. Add Hono dependencies to the project (`bun add hono`)\n4. Import the Hono module and create a new Hono application\n5. Define a GET route for the application that responds with 'Hello Bun!'\n\n### Important notes:\n\n- Bun is a package manager for Deno, and it's used to manage and install dependencies for your Deno projects.\n- Hono is a web framework for Deno.\n\n### References:\n\n- [Bun Package Manager](https://github.com/erfanium/bun)\n- [Hono Web Framework](https://github.com/honots/hono)\n\n### Common use cases:\n\n- Setting up a new Hono project\n- Adding Hono dependencies to an existing project\n- Creating a simple Hono application",
      "ruleTitle": "Installing Hono Dependencies with Bun and Creating a Simple Hono Application",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic Hono application, run it, and change the port number. It shows the basic structure of a Hono application and how to handle HTTP GET requests.",
      "ruleFile": "## Creating, Running, and Changing Port of a Basic Hono Application\n\nThis code snippet demonstrates how to create a basic Hono application, run it, and change the port number.\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\napp.get('/', (c) => c.text('Hello Bun!'))\n\nexport default app\n```\n\nTo run the application, use the command `bun run dev`. Then, access `http://localhost:3000` in your browser.\n\nYou can specify the port number with exporting the `port`.\n\n### How it works\n\n1. The `Hono` class is imported from the `hono` package.\n2. An instance of `Hono` is created.\n3. The `get` method of the `Hono` instance is used to handle HTTP GET requests to the root URL ('/'). The callback function takes a context object `c` and sends a text response 'Hello Bun!'.\n4. The `Hono` instance is exported.\n\n### Important notes\n\n- The `Hono` class is the main class for creating Hono applications.\n- The `get` method is used to handle HTTP GET requests.\n- The context object `c` represents the HTTP request and response.\n\n### References\n\n- [Hono documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Creating a basic Hono application\n- Handling HTTP GET requests\n- Changing the port number of a Hono application",
      "ruleTitle": "Creating, Running, and Changing Port of a Basic Hono Application",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic Hono application, run it, and change the port number. Understanding this is fundamental to getting started with the Hono web framework.",
      "ruleFile": "## Setting Up and Running a Basic Hono Application\n\nThis code snippet demonstrates how to set up a basic Hono application, run it, and change the port number.\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\napp.get('/', (c) => c.text('Hello Bun!'))\n\nexport default app\n```\n\nTo run the application, use the command:\n\n```sh\nbun run dev\n```\n\nThen, access `http://localhost:3000` in your browser.\n\nTo change the port number, you can specify it with exporting the `port`.\n\n### How it Works\n\nThe `Hono` class is imported from the `hono` package. An instance of `Hono` is created and a GET route is set up for the root URL (`/`). The route returns the text 'Hello Bun!'. The application is then exported for use elsewhere.\n\nThe `bun run dev` command is used to start the application in development mode.\n\n### Important Notes\n\n- The default port for Hono applications is 3000. To use a different port, you need to specify it when running the application.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/docs)\n\n### Common Use Cases\n\n- Setting up a basic Hono application for development.\n- Changing the port number for a Hono application.",
      "ruleTitle": "Setting Up and Running a Basic Hono Application",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to change the default port number in a Hono application. By exporting an object with the 'port' property, developers can specify the port number their application should run on. This is crucial for configuring the application to run in different environments.",
      "ruleFile": "## Changing the Default Port Number in Hono\n\nIn Hono, the default port number can be changed by exporting an object with the 'port' property. Here is a code snippet demonstrating this:\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\napp.get('/', (c) => c.text('Hello Bun!'))\n\nexport default app // [!code --]\nexport default { // [!code ++]\n  port: 3000, // [!code ++]\n  fetch: app.fetch, // [!code ++]\n} // [!code ++]\n```\n\n### How it Works\n\n1. Import the Hono framework.\n2. Create a new Hono application.\n3. Define a route.\n4. Instead of exporting the app directly, export an object with the 'port' property set to the desired port number.\n\n### Important Notes\n\n- The 'port' property should be a number.\n- The 'fetch' property should be set to 'app.fetch'.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common Use Cases\n\n- Running the application in different environments with different port numbers.",
      "ruleTitle": "Changing the Default Port Number in Hono",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files using Hono web framework. Serving static files is a common requirement in many web applications, and understanding how to do this in Hono is crucial for developers.",
      "ruleFile": "## Serve Static Files in Hono\n\nThis code snippet demonstrates how to serve static files using Hono web framework.\n\n```ts\nimport { serveStatic } from 'hono/bun'\n\nconst app = new Hono()\n\napp.use('/static/*', serveStatic({ root: './' }))\napp.use('/favicon.ico', serveStatic({ path: './favicon.ico' }))\napp.get('/', (c) => c.text('You can access: /static/hello.txt'))\napp.get('*', serveStatic({ path: './static/fallback.txt' }))\n```\n\n### How it works\n\n1. The `serveStatic` function from `hono/bun` is imported.\n2. A new instance of Hono is created.\n3. The `app.use` function is used to specify the path for serving static files. The `serveStatic` function is used with a configuration object that specifies the root directory for the static files.\n4. The `app.get` function is used to define routes and their handlers. In this case, the root route (`/`) returns a text message, and all other routes (`*`) serve a fallback static file.\n\n### Important notes\n\n- The `serveStatic` function takes a configuration object that can have `root` or `path` properties. The `root` property specifies the root directory for the static files, and the `path` property specifies the path to a specific static file.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Serving static assets like images, scripts, and stylesheets in a web application.\n- Serving a default file for non-existing routes.",
      "ruleTitle": "Serving Static Files in Hono",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files in a Hono application and how to rewrite request paths. Understanding this rule is crucial for managing static assets such as images, CSS files, and JavaScript files in a Hono application.",
      "ruleFile": "## Serving Static Files and Rewriting Request Paths in Hono\n\nIn Hono, you can serve static files and rewrite request paths using the `serveStatic` and `rewriteRequestPath` options respectively. This is useful for managing static assets such as images, CSS files, and JavaScript files.\n\nHere's an example of how to serve a static file:\n\n```ts\napp.get('*', serveStatic({ path: './static/fallback.txt' }))\n```\n\nIn this example, any GET request will be served with the `fallback.txt` file from the `./static` directory.\n\nIf you want to map `http://localhost:3000/static/*` to `./statics`, you can use the `rewriteRequestPath` option:\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    root: './statics',\n    rewriteRequestPath: (req, res) => {\n      return req.path.replace('/static', '');\n    },\n  }),\n);\n```\n\nIn this example, any GET request to `http://localhost:3000/static/*` will be served with the corresponding file from the `./statics` directory.\n\n### Important Notes\n\n- The `serveStatic` option serves static files from a specified directory.\n- The `rewriteRequestPath` option rewrites request paths based on a specified function.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common Use Cases\n\n- Serving static assets in a Hono application.\n- Rewriting request paths in a Hono application.",
      "ruleTitle": "Serving Static Files and Rewriting Request Paths in Hono",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'rewriteRequestPath' option in Hono to map a URL path to a local directory. This is useful when you want to serve static files from a specific directory in your project.",
      "ruleFile": "## Rule: Using 'rewriteRequestPath' to Map URL Paths to Local Directories\n\nThis rule demonstrates how to use the 'rewriteRequestPath' option in Hono to map a URL path to a local directory. This is useful when you want to serve static files from a specific directory in your project.\n\n### Code Snippet:\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    root: './',\n    rewriteRequestPath: (path) =>\n      path.replace(/^\\/static/, '/statics'),\n  })\n)\n```\n\n### How it Works:\n\nThe 'rewriteRequestPath' function takes a path as an argument and returns a new path. In this case, it's replacing '/static' with '/statics'. This means that any request to 'http://localhost:3000/static/*' will be served from the './statics' directory.\n\n### Important Notes:\n\n- The 'rewriteRequestPath' function is a powerful tool that allows you to customize how your server responds to different URL paths.\n\n### References:\n\n- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common Use Cases:\n\n- Serving static files from a specific directory in your project.\n- Mapping URL paths to local directories for better organization of your project.",
      "ruleTitle": "Using 'rewriteRequestPath' to Map URL Paths to Local Directories in Hono",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle different scenarios when serving static files in Hono. It shows how to set custom MIME types, how to handle the scenario when a requested file is found, and how to handle the scenario when a requested file is not found. Understanding these patterns is crucial for building robust web applications with Hono.",
      "ruleFile": "## Serving Static Files in Hono\n\nThis code snippet demonstrates how to serve static files in Hono and handle different scenarios.\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    mimes: {\n      m3u8: 'application/vnd.apple.mpegurl',\n      ts: 'video/mp2t',\n    },\n    onFound: (_path, c) => {\n      c.header('Cache-Control', `public, immutable, max-age=31536000`)\n    },\n    onNotFound: (path, c) => {\n      console.log(`${path} not found`)\n    },\n  })\n)\n```\n\n### How it works\n\n1. The `app.get` method is used to define a route for serving static files.\n2. The `serveStatic` function is used to serve static files. It takes an options object as an argument.\n3. The `mimes` option is used to specify custom MIME types.\n4. The `onFound` option is used to specify handling when the requested file is found. In this case, it sets the 'Cache-Control' header.\n5. The `onNotFound` option is used to specify handling when the requested file is not found. In this case, it logs a message.\n\n### Important notes\n\n- The `onFound` and `onNotFound` options are optional. If not provided, Hono will use default handling.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common use cases\n\n- Serving static files such as images, CSS files, and JavaScript files.\n- Setting custom MIME types for certain file extensions.\n- Customizing response headers for static files.\n- Customizing error handling for not found static files.",
      "ruleTitle": "Handling Static Files in Hono",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle not found errors in Hono framework. It shows how to use the 'onNotFound' option in the 'serveStatic' method to specify a custom error handling function when the requested file is not found.",
      "ruleFile": "## Handling Not Found Errors in Hono\n\nThis code snippet demonstrates how to handle not found errors in Hono framework. It uses the 'onNotFound' option in the 'serveStatic' method to specify a custom error handling function when the requested file is not found.\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    onNotFound: (path, c) => {\n      console.log(`${path} is not found, you access ${c.req.path}`)\n    },\n  })\n)\n```\n\n### How it works\n\nWhen a request is made to a path that does not exist, the function specified in the 'onNotFound' option is called. This function takes two arguments: the path that was not found and the context object 'c'. In this example, a message is logged to the console indicating the path that was not found and the path that was accessed.\n\n### Important notes\n\n- The 'onNotFound' option is only called when the requested file is not found. If the file exists, this function is not called.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common use cases\n\n- Custom error handling when a file is not found\n- Logging for debugging purposes",
      "ruleTitle": "Handling Not Found Errors in Hono",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files with precompression in Hono framework. It shows the usage of the 'serveStatic' middleware with the 'precompressed' option set to true. This can significantly improve the performance of a web application by reducing the size of the files that need to be transferred over the network.",
      "ruleFile": "## Serving Static Files with Precompression in Hono\n\nThis code snippet demonstrates how to serve static files with precompression in Hono framework.\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    precompressed: true,\n  })\n)\n```\n\n### How it works\n\nThe 'serveStatic' middleware is used with the 'precompressed' option set to true. This means that if precompressed versions of the files with extensions like `.br` or `.gz` are available, they will be served based on the `Accept-Encoding` header. The middleware prioritizes Brotli, then Zstd, and Gzip. If none are available, it serves the original file.\n\n### Important notes\n\n- The static files need to be precompressed and available in the same directory as the original files.\n- The 'Accept-Encoding' header of the request is used to determine which precompressed version of the file to serve.\n\n### References\n\n- [Hono serveStatic middleware documentation](https://hono.bun.dev/middlewares/serveStatic)\n\n### Common use cases\n\n- Serving static assets like CSS, JavaScript, and image files in a web application.",
      "ruleTitle": "Serving Static Files with Precompression in Hono",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files with precompression and how to test the server response using the Bun testing framework. Understanding this rule ensures efficient delivery of static content and helps in validating server responses during development.",
      "ruleFile": "## Serving Static Files with Precompression and Testing Server Response in Hono\n\nThis code demonstrates how to serve static files with precompression in Hono and how to test the server response using the Bun testing framework.\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    precompressed: true,\n  })\n)\n```\n\nIn the above snippet, `app.get` is used to handle GET requests to any route that matches '/static/*'. The `serveStatic` function is used with the `precompressed` option set to true, which means that it will serve precompressed versions of the files if they are available.\n\nTo test the server response, the Bun testing framework is used as shown below:\n\n```ts\nimport { describe, expect, it } from 'bun:test'\nimport app from '.'\n\ndescribe('My first test', () => {\n  it('Should return 200 Response', async () => {\n    const req = new Request('http://localhost/')\n    const res = await app.fetch(req)\n    expect(res.status).toBe(200)\n  })\n})\n```\n\nIn this test, a new request is created and sent to the server using `app.fetch`. The response status is then checked to be 200, indicating a successful request.\n\n### Important Notes\n\n- Ensure that precompressed versions of the files are available when using the `precompressed` option.\n- Always validate server responses during development to ensure correct server behavior.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n- [Bun Testing Framework](https://bun.dev/docs/testing)\n\n### Common Use Cases\n\n- Serving static files in a web application.\n- Testing server responses during development.",
      "ruleTitle": "Serving Static Files with Precompression and Testing Server Response in Hono",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to write and execute a basic test in Hono. Testing is a crucial part of software development to ensure the code behaves as expected. This rule shows how to create a simple test that checks if a request to the local server returns a 200 status code, indicating a successful HTTP request. The test is then run using the 'bun test' command.",
      "ruleFile": "## Rule: Writing and Running Basic Tests in Hono\n\nThis rule demonstrates how to write a basic test in Hono and run it using the 'bun test' command.\n\n### Code Snippet:\n\n```sh\n'Should return 200 Response', async () => {\n    const req = new Request('http://localhost/')\n    const res = await app.fetch(req)\n    expect(res.status).toBe(200)\n  })\n})\n```\n\nThen, run the command.\n\n```sh\nbun test index.test.ts\n```\n\n### How it works:\n\n1. A new Request object is created with the URL of the local server.\n2. The 'fetch' method of the 'app' object is used to send the request and the response is awaited.\n3. The 'expect' function is used to assert that the status code of the response is 200.\n4. The test is run using the 'bun test' command, specifying the test file to run.\n\n### Important notes:\n\n- The 'fetch' method returns a Promise that resolves to the Response to that request, whether it is successful or not.\n\n### References:\n\n- [Hono Documentation](https://www.eclipse.org/hono/)\n\n### Common use cases:\n\n- Testing the response of a server to a certain request.\n- Checking the status code of a response to ensure it is as expected.",
      "ruleTitle": "Writing and Running Basic Tests in Hono",
      "sourcePath": "docs/getting-started/bun.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a new Hono application and select a template for the application. This is a fundamental step in getting started with the Hono framework.",
      "ruleFile": "## Creating a New Hono Application and Selecting a Template\n\nThis code snippet demonstrates how to create a new Hono application and select a template for the application.\n\n```sh\nyarn create hono my-app\n```\n\nor\n\n```sh\npnpm create hono@latest my-app\n```\n\nor\n\n```sh\nbun create hono@latest my-app\n```\n\nor\n\n```sh\ndeno init --npm hono@latest my-app\n```\n\nAfter running one of the above commands, you will be asked to select a template for your application. In this example, the 'cloudflare-workers' template is selected.\n\n```\n? Which template do you want to use?\n    aws-lambda\n    bun\n    cloudflare-pages\nâ¯   cloudflare-workers\n    deno\n    fastly\n    nextjs\n    nodejs\n    vercel\n```\n\n### How it Works\n\nThe `create` command initializes a new Hono application in the directory specified (in this case, 'my-app'). The `@latest` flag ensures you are using the latest version of Hono. After initialization, you are prompted to select a template for your application. The template you choose will shape the structure and functionality of your application.\n\n### Important Notes\n\n- Ensure you have the necessary package manager (yarn, pnpm, bun, or deno) installed before running the `create` command.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common Use Cases\n\n- Initializing a new Hono application\n- Selecting a template for a new Hono application",
      "ruleTitle": "Creating a New Hono Application and Selecting a Template",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to navigate to the project directory and install the dependencies in a Hono project. It is a fundamental step in setting up a new project, regardless of the package manager being used.",
      "ruleFile": "## Navigating to Project Directory and Installing Dependencies\n\nAfter selecting the template for your Hono project, the next step is to navigate to the project directory and install the necessary dependencies. This can be done using various package managers like npm, yarn, pnpm, or bun.\n\nHere is the code snippet demonstrating this:\n\n```sh\n# For npm\n\ncd my-app\nnpm i\n\n# For yarn\n\ncd my-app\nyarn\n\n# For pnpm\n\ncd my-app\npnpm i\n\n# For bun\n\ncd my-app\nbun i\n```\n\n### How it works\n\n1. `cd my-app` - This command navigates to the `my-app` directory.\n2. `npm i`, `yarn`, `pnpm i`, `bun i` - These commands install the dependencies listed in the `package.json` file.\n\n### Important notes\n\n- Make sure to use the correct command for the package manager you are using.\n- The dependencies must be installed before you can start working on the project.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Setting up a new Hono project\n- Installing additional dependencies in an existing Hono project",
      "ruleTitle": "Navigating to Project Directory and Installing Dependencies in Hono",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to navigate to the application directory and install dependencies using different package managers. It also shows how to start a local server. Understanding this is crucial for setting up and running a Hono application.",
      "ruleFile": "## Navigating to Application Directory and Installing Dependencies\n\nThe code snippet demonstrates how to navigate to the application directory (`my-app`) and install dependencies using different package managers (`npm`, `yarn`, `pnpm`, `bun`).\n\n```sh\n# With npm\ncd my-app\nnpm i\n\n# With yarn\ncd my-app\nyarn\n\n# With pnpm\ncd my-app\npnpm i\n\n# With bun\ncd my-app\nbun i\n```\n\n## Starting a Local Server\n\nOnce the package installation is complete, the following commands can be used to start a local server.\n\n```sh\n# With npm\nnpm run dev\n\n# With yarn\nyarn dev\n\n# With pnpm\npnpm dev\n\n# With bun\nbun run dev\n```\n\n### How it Works\n\nThe `cd` command is used to navigate to the application directory. The `i` or `install` command is used to install the dependencies listed in the `package.json` file. The `run dev` command is used to start a local server.\n\n### Important Notes\n\n- Ensure that the correct package manager is used for installing dependencies and starting the server.\n\n### References\n\n- [npm documentation](https://docs.npmjs.com/)\n- [yarn documentation](https://yarnpkg.com/getting-started)\n- [pnpm documentation](https://pnpm.io/)\n- [bun documentation](https://bun.js.org/)\n\n### Common Use Cases\n\n- Setting up a new Hono application\n- Running a Hono application locally",
      "ruleTitle": "Navigating to Application Directory, Installing Dependencies, and Starting a Local Server in Hono",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic Hono application. It shows how to import the Hono module, instantiate it, define a route, and export the application. This is a fundamental pattern in Hono framework usage that every developer should understand.",
      "ruleFile": "## Creating a Basic Hono Application\n\nThis code snippet demonstrates how to create a basic Hono application.\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/', (c) => {\n  return c.text('Hello Hono!')\n})\n\nexport default app\n```\n\n### How it works\n\n1. The Hono module is imported.\n2. A new instance of Hono is created.\n3. A GET route is defined on the root path ('/'). When this route is hit, it returns a text response 'Hello Hono!'.\n4. The Hono application is exported.\n\n### Important notes\n\nThe `import` and the final `export default` parts may vary from runtime to runtime, but all of the application code will run the same code everywhere.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Creating a new Hono application\n- Defining routes in a Hono application",
      "ruleTitle": "Creating a Basic Hono Application",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates the basic setup and usage of the Hono web framework. It shows how to create a new Hono application, define a simple GET route, and start the development server. Understanding this basic pattern is crucial for building applications with Hono.",
      "ruleFile": "## Hono Basic Setup and Usage\n\nThis code demonstrates the basic setup and usage of the Hono web framework.\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/', (c) => {\n  return c.text('Hello Hono!')\n})\n\nexport default app\n```\n\nTo start the development server, use one of the following commands based on your package manager:\n\n```sh\nnpm run dev\n```\n\n```sh\nyarn dev\n```\n\n```sh\npnpm dev\n```\n\n```sh\nbun run dev\n```\n\nThen, access `http://localhost:8787` with your browser.\n\n### How it works\n\n1. The `Hono` class is imported from the 'hono' module.\n2. A new instance of `Hono` is created and assigned to the `app` variable.\n3. The `get` method of the `app` object is used to define a route that responds to HTTP GET requests at the root URL ('/'). The route handler function takes a context object `c` and returns a text response 'Hello Hono!'.\n4. The `app` object is exported for use in other modules.\n\n### Important notes\n\n- The route handler function can return a response in different formats, such as text, HTML, or JSON, using the appropriate methods of the context object.\n\n### References\n\n- [Hono documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Building a simple web server with Hono\n- Defining routes and route handlers in a Hono application",
      "ruleTitle": "Basic Setup and Usage of Hono Web Framework",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle a GET request and return a JSON response in the Hono framework. Understanding this rule is crucial for building APIs that return JSON data.",
      "ruleFile": "## Returning JSON Response in Hono\n\nThis code snippet demonstrates how to handle a GET request and return a JSON response in the Hono framework.\n\n```ts\napp.get('/api/hello', (c) => {\n  return c.json({\n    ok: true,\n    message: 'Hello Hono!',\n  })\n})\n```\n\n### How it works\n\nIn this code snippet, `app.get` is used to handle a GET request to the `/api/hello` endpoint. The callback function takes a context object `c` as an argument, which is used to return a JSON response using `c.json` method.\n\n### Important notes\n\nThe `c.json` method sets the Content-Type header to `application/json` and sends the response.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\nThis pattern is commonly used when building APIs that need to return JSON data.",
      "ruleTitle": "Handling GET Requests and Returning JSON Response in Hono",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle GET requests, extract path parameters and query values, and append response headers in Hono. Understanding this rule is crucial for building APIs with Hono as it forms the basis of request-response handling.",
      "ruleFile": "## Handling GET Requests and Manipulating Responses in Hono\n\nThe following code snippets demonstrate how to handle GET requests and manipulate responses in Hono.\n\nTo handle a GET request to `/api/hello` and return a JSON response, you can use the `get` method of the `app` object and the `json` method of the context `c`:\n\n```ts\napp.get('/api/hello', (c) => {\n  return c.json({\n    ok: true,\n    message: 'Hello Hono!',\n  })\n})\n```\n\nTo get a path parameter, a URL query value, and append a response header, you can use the `req` and `header` methods of the context `c`:\n\n```ts\napp.get('/posts/:id', (c) => {\n  const page = c.req.query('page')\n  const id = c.req.param('id')\n  c.header('X-Message', 'Hi!')\n  return c.text(`You want to see ${page} of ${id}`)\n})\n```\n\n### How it Works\n\nIn Hono, the `app.get` method is used to handle GET requests. The first argument is the path, and the second argument is a callback function that takes a context `c` as its argument. The context `c` has several methods to manipulate the request and the response. The `req.query` method is used to get a URL query value, the `req.param` method is used to get a path parameter, and the `header` method is used to append a response header.\n\n### Important Notes\n\n- The `req.query` and `req.param` methods return `undefined` if the specified query or parameter does not exist.\n- The `header` method does not return anything.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases\n\n- Building APIs that handle GET requests.\n- Building APIs that need to extract path parameters and query values.\n- Building APIs that need to manipulate response headers.",
      "ruleTitle": "Handling GET Requests and Manipulating Responses in Hono",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle different HTTP methods such as GET, POST, DELETE in Hono framework. It also shows how to extract parameters from the request and how to set headers and return responses in different formats.",
      "ruleFile": "## Handling Different HTTP Methods and Responses in Hono\n\nThis code snippet demonstrates how to handle different HTTP methods such as GET, POST, DELETE in Hono framework. It also shows how to extract parameters from the request and how to set headers and return responses in different formats.\n\n```ts\napp.get('/posts/:id', (c) => {\n  const page = c.req.query('page')\n  const id = c.req.param('id')\n  c.header('X-Message', 'Hi!')\n  return c.text(`You want to see ${page} of ${id}`)\n})\n\napp.post('/posts', (c) => c.text('Created!', 201))\napp.delete('/posts/:id', (c) =>\n  c.text(`${c.req.param('id')} is deleted!`)\n)\n```\n\n### How it works\n\n1. `app.get`, `app.post`, `app.delete` are used to handle GET, POST, DELETE requests respectively.\n2. `c.req.query` is used to get query parameters from the request.\n3. `c.req.param` is used to get route parameters from the request.\n4. `c.header` is used to set response headers.\n5. `c.text` is used to return a text response.\n\n### Important notes\n\n- Make sure to return a response in the handler function, otherwise the request will hang.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common use cases\n\n- Building RESTful APIs with different HTTP methods.\n- Returning different types of responses based on the request.",
      "ruleTitle": "Handling Different HTTP Methods and Responses in Hono",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle different HTTP methods such as POST, DELETE and GET in Hono, and how to return HTML or JSX from a Hono application. Understanding these patterns is crucial for building web applications using the Hono framework.",
      "ruleFile": "## Handling HTTP Methods and Returning HTML in Hono\n\nThis code snippet demonstrates how to handle different HTTP methods and return HTML or JSX in a Hono application.\n\n```ts\napp.post('/posts', (c) => c.text('Created!', 201))\napp.delete('/posts/:id', (c) =>\n  c.text(`${c.req.param('id')} is deleted!`)\n)\n```\nIn the above code, we define routes for POST and DELETE methods. The POST route creates a new post and returns a text response with status code 201. The DELETE route deletes a post with a specific id and returns a text response.\n\n```tsx\nconst View = () => {\n  return (\n    <html>\n      <body>\n        <h1>Hello Hono!</h1>\n      </body>\n    </html>\n  )\n}\n\napp.get('/page', (c) => {\n  return c.html(<View />)\n})\n```\nIn the above code, we define a GET route that returns an HTML response. The HTML is defined using JSX syntax.\n\n### Important Notes\n\n- To use JSX, rename the file to `src/index.tsx` and configure it. The configuration may vary depending on the runtime.\n- You can also write HTML using the html Helper.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases\n\n- Building RESTful APIs with different HTTP methods.\n- Returning HTML or JSX from a Hono application.",
      "ruleTitle": "Handling HTTP Methods and Returning HTML in Hono",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic Hono application, return raw responses and use middleware for tasks like authentication. Understanding these concepts is crucial for building and managing applications using the Hono framework.",
      "ruleFile": "## Hono Basic Usage, Raw Responses and Middleware\n\nThis rule demonstrates how to create a basic Hono application, return raw responses and use middleware for tasks like authentication.\n\n### Code Snippet\n\n```tsx\nconst View = () => {\n  return (\n    <html>\n      <body>\n        <h1>Hello Hono!</h1>\n      </body>\n    </html>\n  )\n}\n\napp.get('/page', (c) => {\n  return c.html(<View />)\n})\n```\n\nYou can also return the raw Response.\n\n```ts\napp.get('/', () => {\n  return new Response('Good morning!')\n})\n```\n\nMiddleware can do the hard work for you. For example, add in Basic Authentication.\n\n```ts\nimport { basicAuth\n```\n\n### How it Works\n\n1. The `View` function returns a JSX component which is rendered as HTML.\n2. The `app.get` function sets up a route handler for the '/page' route, which returns the rendered HTML.\n3. The raw Response can be returned directly from the route handler.\n4. Middleware functions can be imported and used to handle common tasks like authentication.\n\n### Important Notes\n\n- JSX components must be transpiled to JavaScript before they can be used in a Hono application.\n- Middleware functions are executed in the order they are defined.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n- [MDN Response Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n\n### Common Use Cases\n\n- Building a simple web page with Hono\n- Returning raw responses for simple text responses\n- Using middleware for authentication",
      "ruleTitle": "Creating a Basic Hono Application, Returning Raw Responses and Using Middleware",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use middleware in Hono for adding Basic Authentication to routes. Middleware can handle complex tasks and improve code reusability and organization. In this case, the basicAuth middleware is used to protect the '/admin/*' route by requiring a username and password.",
      "ruleFile": "# Using Middleware in Hono\n\nThis code snippet demonstrates how to use middleware in Hono to add Basic Authentication to a route.\n\n```ts\nimport { basicAuth } from 'hono/basic-auth'\n\n// ...\n\napp.use(\n  '/admin/*',\n  basicAuth({\n    username: 'admin',\n    password: 'secret',\n  })\n)\n\napp.get('/admin', (c) => {\n  return c.text('You are authenticated!')\n})\n```\n\n## How it works\n\nThe `app.use` function is used to apply middleware to routes. The first argument is the route pattern, and the second argument is the middleware function. In this case, the `basicAuth` middleware is used, which requires a username and password.\n\n## Important notes\n\n- Middleware functions are executed in the order they are added.\n- Middleware can be applied to specific routes or to all routes.\n\n## References\n\n- [Hono Documentation](https://hono.beyondnlp.com/)\n\n## Common use cases\n\n- Protecting routes with Basic Authentication\n- Applying logging or error handling middleware to all routes",
      "ruleTitle": "Using Middleware for Basic Authentication in Hono",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use built-in and third-party middleware in Hono, and how to handle platform-dependent functions using Adapters. Middleware is crucial for handling requests and responses, while Adapters allow for platform-specific functionality.",
      "ruleFile": "## Using Middleware and Adapters in Hono\n\nThis code snippet demonstrates the use of built-in and third-party middleware in Hono, as well as handling platform-dependent functions using Adapters.\n\n```text\nThere are useful built-in middleware including Bearer and authentication using JWT, CORS and ETag.\nHono also provides third-party middleware using external libraries such as GraphQL Server and Firebase Auth.\nAnd, you can make your own middleware.\n\n## Adapter\n\nThere are Adapters for platform-dependent functions, e.g., handling static files or WebSocket.\nFor example, to handle WebSocket in Cloudflare Workers, import `hono/cloudflare-workers`.\n```\n\n### How it works\n\nMiddleware in Hono can be used to handle requests and responses. Built-in middleware includes Bearer and JWT authentication, CORS, and ETag. Hono also supports third-party middleware from external libraries such as GraphQL Server and Firebase Auth. You can also create custom middleware.\n\nAdapters in Hono are used for platform-dependent functions, such as handling static files or WebSocket. For instance, to handle WebSocket in Cloudflare Workers, you can import the `hono/cloudflare-workers` Adapter.\n\n### Important notes\n\n- Middleware is crucial for handling requests and responses in Hono.\n- Adapters allow for platform-specific functionality in Hono.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Using built-in middleware for authentication, CORS, and ETag.\n- Using third-party middleware from external libraries.\n- Handling platform-dependent functions using Adapters.",
      "ruleTitle": "Using Middleware and Adapters in Hono",
      "sourcePath": "docs/getting-started/basic.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates the initial steps to create a new project directory for a Vite project. Understanding these steps is crucial for setting up the project structure correctly.",
      "ruleFile": "## Creating a New Project Directory in Vite\n\nThis code snippet demonstrates how to create a new project directory when starting a new Vite project.\n\n```sh\nmkdir my-app\ncd my-app\n```\n\n### How it Works\n\n1. `mkdir my-app`: This command creates a new directory named 'my-app'.\n2. `cd my-app`: This command changes the current working directory to 'my-app'.\n\n### Important Notes\n\n- Ensure you have the necessary permissions to create and access the directory.\n\n### References\n\n- [Vite Documentation](https://vitejs.dev/guide/)\n\n### Common Use Cases\n\n- Starting a new Vite project\n- Creating a new directory for any project",
      "ruleTitle": "Creating a New Project Directory in Vite",
      "sourcePath": "docs/getting-started/service-worker.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic package.json file for a new project in Hono. The package.json file is a crucial part of any Node.js project as it holds various metadata relevant to the project. This file is used to give information to npm that allows it to identify the project as well as handle the project's dependencies. It can also contain other metadata such as a project description, the version of the project in a particular distribution, license information, even configuration data - all of which can be vital to both npm and to the end users of the package.",
      "ruleFile": "## Creating a Basic package.json File in Hono\n\nThe following code snippet demonstrates how to create a basic `package.json` file for a new project in Hono:\n\n```json\n{\n  \"name\": \"my-app\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"vite dev\"\n  },\n  \"type\": \"module\"\n}\n```\n\n### How it works\n\n1. `name`: This is the name of your application. It should be lowercase and one word, but hyphens and underscores can be used.\n2. `private`: This is a safety measure to prevent accidental publication of private repositories. When set to true, this option prevents the package from being accidentally published on npm.\n3. `scripts`: This is where you can define script commands that are part of your application's lifecycle. In this case, the `dev` command is used to start the development server.\n4. `type`: This field signifies that the code should be treated as ECMAScript modules.\n\n### Important notes\n\n- The `package.json` file is a crucial part of any Node.js project and should be set up correctly.\n\n### References\n\n- [npm documentation on package.json](https://docs.npmjs.com/cli/v7/configuring-npm/package-json)\n\n### Common use cases\n\n- Setting up a new Node.js project\n- Defining project metadata and configuration",
      "ruleTitle": "Creating a Basic package.json File in Hono",
      "sourcePath": "docs/getting-started/service-worker.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a new Hono project with the necessary configuration files and dependencies. The `package.json` file is used to define the project and its scripts, while the `tsconfig.json` file is used to specify the TypeScript compiler options. The installation commands show how to add the Hono and Vite packages to the project.",
      "ruleFile": "## Setting up a new Hono project\n\nWhen starting a new Hono project, it's necessary to create a `package.json` and a `tsconfig.json` file with the appropriate configurations.\n\nThe `package.json` file should look like this:\n\n```json\n{\n  \"name\": \"my-app\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"vite dev\"\n  },\n  \"type\": \"module\"\n}\n```\n\nThe `tsconfig.json` file should look like this:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2020\", \"DOM\", \"WebWorker\"],\n    \"moduleResolution\": \"bundler\"\n  },\n  \"include\": [\"./\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\nAfter these files are set up, you can install the necessary modules with the following commands:\n\n```sh\nnpm i hono\nnpm i -D vite\n```\n\nor\n\n```sh\nyarn add hono\nyarn add -D vite\n```\n\nor\n\n```sh\npnpm add hono\npnpm add -D vite\n```\n\nThis setup is crucial for the proper functioning of a Hono project.",
      "ruleTitle": "Setting up a new Hono project",
      "sourcePath": "docs/getting-started/service-worker.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to install the Hono framework and its dependencies using different package managers, and how to set up a basic 'Hello World' page using Hono. Understanding this rule is crucial for developers to get started with Hono and to understand the basic structure of a Hono application.",
      "ruleFile": "## Installing Hono and Setting Up a Basic Page\n\nThis code snippet demonstrates how to install the Hono framework and its dependencies using different package managers, and how to set up a basic 'Hello World' page.\n\n### Code Snippet\n\n```sh\nnpm i hono\nnpm i -D vite\n```\n\nor\n\n```sh\nyarn add hono\nyarn add -D vite\n```\n\nor\n\n```sh\npnpm add hono\npnpm add -D vite\n```\n\nor\n\n```sh\nbun add hono\nbun add -D vite\n```\n\nThen, edit `index.html`:\n\n```html\n<!doctype html>\n<html>\n  <body>\n    <a href=\"/sw\">Hello World by Service Worker</a>\n    <script type=\"module\" src=\"/main.ts\"></script>\n  </body>\n</html>\n```\n\n### How it Works\n\nThe first part of the code installs Hono and its dependencies using npm, yarn, pnpm, or bun. The `-D` flag in the installation command is used to save the package for development purpose only.\n\nThe second part of the code sets up a basic 'Hello World' page. The `index.html` file is edited to include a link that displays 'Hello World by Service Worker' and a script tag that links to `main.ts`.\n\n### Important Notes\n\n- Make sure to install the correct version of Hono and its dependencies.\n- The `main.ts` file should be properly set up for the script tag in `index.html` to work correctly.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs)\n\n### Common Use Cases\n\n- Setting up a new Hono project\n- Installing dependencies for a Hono project",
      "ruleTitle": "Installing Hono and Setting Up a Basic Page",
      "sourcePath": "docs/getting-started/service-worker.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create an application using Hono and register it to the `fetch` event with the Service Worker adapterâ€™s `handle` function. This is crucial for intercepting access to certain routes in the application, in this case `/sw`, which can be useful for caching strategies, offline functionality, or other service worker use cases.",
      "ruleFile": "## Registering a Hono Application to the Fetch Event with Service Worker Adapter's Handle Function\n\nThis code snippet demonstrates how to create an application using Hono and register it to the `fetch` event with the Service Worker adapterâ€™s `handle` function. This allows the Hono application to intercept access to `/sw`.\n\n```ts\n// To support types\n// https://github.com/microsoft/TypeScript/issues/14877\ndeclare const self: ServiceWorkerGlobalScope\n\nimport { Hono } from 'hono'\nimport { handle } from 'hono/service-worker'\n```\n\n### How it Works\n\n1. The `declare const self: ServiceWorkerGlobalScope` line is used to support types in TypeScript.\n2. The `Hono` and `handle` functions are imported from the `hono` and `hono/service-worker` modules respectively.\n3. The `handle` function is used to register the Hono application to the `fetch` event. This allows the application to intercept access to `/sw`.\n\n### Important Notes\n\n- This setup is necessary for applications that need to use service workers for tasks like caching, offline functionality, etc.\n\n### References\n\n- [TypeScript Issue #14877](https://github.com/microsoft/TypeScript/issues/14877)\n\n### Common Use Cases\n\n- Caching assets for offline use\n- Intercepting and modifying requests\n- Background data synchronization",
      "ruleTitle": "Registering a Hono Application to the Fetch Event with Service Worker Adapter's Handle Function",
      "sourcePath": "docs/getting-started/service-worker.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic service worker using the Hono framework, and how to start the development server. Understanding this is crucial for developers as service workers are a key component in creating reliable, fast web pages, and running the development server is a fundamental step in the development process.",
      "ruleFile": "## Setting Up a Basic Service Worker and Running the Development Server in Hono\n\nThis code snippet demonstrates how to set up a basic service worker using the Hono framework, and how to start the development server.\n\n```text\nimport { Hono } from 'hono'\nimport { handle } from 'hono/service-worker'\n\nconst app = new Hono().basePath('/sw')\napp.get('/', (c) => c.text('Hello World'))\n\nself.addEventListener('fetch', handle(app))\n```\n\nTo run the development server, use the following commands:\n\n```sh\nnpm run dev\n```\n\n```sh\nyarn dev\n```\n\n```sh\npnpm run dev\n```\n\n```sh\nbun run dev\n```\n\nBy default, the development server will run on port `5173`.\n\n### How it Works\n\nThe `Hono` class is imported from the 'hono' module, and the `handle` function is imported from 'hono/service-worker'. A new instance of `Hono` is created, with the base path set to '/sw'. A GET request handler is set up for the root path ('/'), which responds with the text 'Hello World'. The `fetch` event listener is added to the service worker, which uses the `handle` function to handle requests.\n\nThe development server is started using one of the provided commands, depending on the package manager being used.\n\n### Important Notes\n\n- The `handle` function is a key part of setting up a service worker in Hono, as it handles incoming requests.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common Use Cases\n\n- Setting up a basic service worker for a web application.\n- Starting the development server for a web application.",
      "ruleTitle": "Setting Up a Basic Service Worker and Running the Development Server in Hono",
      "sourcePath": "docs/getting-started/service-worker.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to initialize a new Hono project using Deno. It's a fundamental step for developers to start working with Hono in a Deno environment.",
      "ruleFile": "## Initializing a Hono Project with Deno\n\nThis code snippet demonstrates how to initialize a new Hono project using Deno.\n\n```sh\ndeno init --npm hono my-app\n```\n\n### How it works\n\nThe `deno init --npm hono my-app` command initializes a new Hono project in a directory named `my-app`. This command sets up the necessary files and configurations for a Hono project.\n\n### Important notes\n\n- The `my-app` is the name of the directory that will be created for the new project. You can replace `my-app` with the name of your choice.\n\n- For Deno, you don't have to install Hono explicitly.\n\n### References\n\n- [Official Hono Documentation](https://docs.deno.com/runtime/manual/getting_started/installation)\n\n### Common use cases\n\n- Setting up a new Hono project in a Deno environment.",
      "ruleTitle": "Initializing a Hono Project with Deno",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono framework in Deno. It shows how to import the Hono module, create a new Hono application, define a route, and serve the application. Understanding this basic structure is crucial for building more complex applications using Hono.",
      "ruleFile": "## Creating a Basic Hono Application in Deno\n\nThis code snippet demonstrates how to create a basic 'Hello World' application using the Hono framework in Deno.\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Deno!'))\n\nDeno.serve(app.fetch)\n```\n\n### How it works\n\n1. The Hono module is imported.\n2. A new Hono application is created.\n3. A route is defined for the root URL ('/') that responds with the text 'Hello Deno!'.\n4. The application is served using Deno's built-in server.\n\n### Important notes\n\n- For Deno, you don't have to install Hono explicitly.\n- You can change the port number by updating the arguments of `Deno.serve`.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n- [Deno Documentation](https://deno.land/manual)\n\n### Common use cases\n\n- Creating a basic web application.\n- Learning the structure of a Hono application.",
      "ruleTitle": "Creating a Basic Hono Application in Deno",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic Hono application, run it, and change the port number. Understanding this is fundamental to getting started with the Hono web framework in Deno.",
      "ruleFile": "## Creating, Running and Changing Port of a Hono Application\n\nThis code demonstrates how to create a basic Hono application, run it, and change the port number.\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Deno!'))\n\nDeno.serve(app.fetch)\n```\n\nTo run the application, use the command:\n\n```sh\ndeno task start\n```\n\nYou can specify the port number by updating the arguments of `Deno.serve` in `main.ts`:\n\n```ts\nDeno.serve(app.fetch) // default port\nDeno.serve({ port: 8787 }, app.fetch) // custom port\n```\n\n### How it works\n\n1. The Hono application is created and a GET route is defined.\n2. The application is served using Deno's built-in server.\n3. The `deno task start` command is used to run the application.\n4. The port number can be changed by passing an options object to `Deno.serve`.\n\n### Important notes\n\n- The `app.fetch` method is used to handle HTTP requests and responses.\n- The `deno task start` command requires the `--allow-net` flag to allow network access.\n\n### References\n\n- [Hono Documentation](https://hono.land)\n- [Deno Documentation](https://deno.land)\n\n### Common use cases\n\n- Creating a basic web server with Hono and Deno.\n- Changing the port number of a Hono application.",
      "ruleTitle": "Creating, Running and Changing Port of a Hono Application",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve an application and change the port number in Hono using Deno. It also shows how to serve static files, which is a common requirement in web development. Understanding how to configure the port number and serve static files is crucial for setting up and managing a web server.",
      "ruleFile": "## Serving an Application and Changing the Port Number in Hono using Deno\n\nThis code snippet demonstrates how to serve an application and change the port number in Hono using Deno. It also shows how to serve static files.\n\n```ts\nDeno.serve(app.fetch)\nDeno.serve({ port: 8787 }, app.fetch)\n```\n\n### How it works\n\nThe `Deno.serve` function is used to serve the application. The first argument can be an object that specifies the port number. If no port number is specified, the default port number is used.\n\nTo serve static files, the `serveStatic` function imported from `hono/middleware.ts` is used.\n\n### Important notes\n\n- The port number must be a number and not a string.\n- The `serveStatic` function can only serve static files. It cannot be used to serve dynamic content.\n\n### References\n\n- [Hono Documentation](https://hono.beyondnlp.com/docs)\n\n### Common use cases\n\n- Serving a web application on a specific port number\n- Serving static files in a web application",
      "ruleTitle": "Serving an Application and Changing the Port Number in Hono using Deno",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files using the Hono web framework in Deno. Serving static files is a common requirement in many web applications, and understanding how to do this in Hono can help developers build more efficient and performant applications.",
      "ruleFile": "## Serve Static Files in Hono\n\nThis code demonstrates how to serve static files using the Hono web framework in Deno.\n\n```ts\nimport { Hono } from 'hono'\nimport { serveStatic } from 'hono/deno'\n\nconst app = new Hono()\n\napp.use('/static/*', serveStatic({ root: './' }))\napp.use('/favicon.ico', serveStatic({ path: './favicon.ico' }))\napp.get('/', (c) => c.text('You can access: /static/hello.txt'))\napp.get('*', serveStatic({ path: './static/fallback.txt' }))\n\nDeno.serve(app.fetch)\n```\n\n### How it works\n\nThe `serveStatic` function from `hono/deno` is used to serve static files. The `app.use` and `app.get` methods are used to define routes and their corresponding handlers. The `serveStatic` function is used as a handler for these routes, and it takes an object as an argument that specifies the root directory or path of the static file to be served.\n\n### Important notes\n\n- The `serveStatic` function serves files from the specified root directory or path.\n- The `app.use` method is used to define middleware functions that have access to the request object, the response object, and the next function in the applicationâ€™s request-response cycle.\n\n### References\n\n- [Hono Documentation](https://hono.land)\n\n### Common use cases\n\n- Serving static assets like images, CSS files, and JavaScript files.\n- Serving a default file as a fallback when no routes match.",
      "ruleTitle": "Serving Static Files in Hono",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files and handle fallbacks in Hono. It also shows how to rewrite request paths to map to a different directory structure. Understanding this rule is crucial for managing static resources in a Hono application.",
      "ruleFile": "## Serving Static Files and Handling Fallbacks in Hono\n\nIn Hono, you can serve static files from a directory and set a fallback file for any unmatched routes. Here is a code snippet that demonstrates this:\n\n```ts\napp.get('*', serveStatic({ path: './static/hello.txt' }))\napp.get('*', serveStatic({ path: './static/fallback.txt' }))\n\nDeno.serve(app.fetch)\n```\n\nThis code will work well with the following directory structure:\n\n```\n./\nâ”œâ”€â”€ favicon.ico\nâ”œâ”€â”€ index.ts\nâ””â”€â”€ static\n    â”œâ”€â”€ demo\n    â”‚   â””â”€â”€ index.html\n    â”œâ”€â”€ fallback.txt\n    â”œâ”€â”€ hello.txt\n    â””â”€â”€ images\n        â””â”€â”€ dinotocat.png\n```\n\nIf you want to map `http://localhost:8000/static/*` to `./statics`, you can use the `rewriteRequestPath` option:\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    root: '.\n```\n\n### How it Works\n\nThe `serveStatic` function serves static files from the specified path. If a route does not match any file, the fallback file is served.\n\nThe `rewriteRequestPath` option allows you to map a request path to a different directory structure.\n\n### Important Notes\n\n- The `serveStatic` function and the `rewriteRequestPath` option are part of the Hono framework.\n- The fallback file is served for any unmatched routes.\n\n### References\n\n- [Hono Documentation](https://hono.bryntum.com/docs)\n\n### Common Use Cases\n\n- Serving static resources like images, CSS files, and JavaScript files.\n- Setting a default file to be served when no routes match.",
      "ruleTitle": "Serving Static Files and Handling Fallbacks in Hono",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to rewrite request paths in Hono. It shows how to map a URL pattern to a different directory in the server. This is useful when you want to serve static files from a different directory than the one specified in the URL.",
      "ruleFile": "## Rewriting Request Paths in Hono\n\nThis code snippet demonstrates how to rewrite request paths in Hono. This is useful when you want to serve static files from a different directory than the one specified in the URL.\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    root: './',\n    rewriteRequestPath: (path) =>\n      path.replace(/^\\/static/, '/statics'),\n  })\n)\n```\n\n### How it works\n\nThe `rewriteRequestPath` option is a function that takes the request path as an argument and returns the new path. In this case, it replaces `/static` with `/statics` in the request path.\n\n### Important notes\n\n- The `rewriteRequestPath` function is called for every request, so it should be as efficient as possible.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Serving static files from a different directory than the one specified in the URL.",
      "ruleTitle": "Rewriting Request Paths in Hono",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files and add MIME types in Hono framework. MIME types are essential for browsers to handle the received content correctly. The rule also shows how to rewrite the request path, which can be useful for redirecting requests or handling them differently based on the path.",
      "ruleFile": "## Serving Static Files and Adding MIME Types in Hono\n\nThis code snippet demonstrates how to serve static files and add MIME types in Hono framework.\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    root: './',\n    rewriteRequestPath: (path) =>\n      path.replace(/^\\/static/, '/statics'),\n  })\n)\n```\n\nIn the above code, `app.get` is used to handle GET requests to the '/static/*' path. The `serveStatic` function is used to serve static files from the root directory. The `rewriteRequestPath` function is used to rewrite the request path by replacing '/static' with '/statics'.\n\nYou can also add MIME types with `mimes`:\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    mimes: {\n      m3u8: 'application/vnd.apple.mpegurl',\n      ts: 'video/mp2t',\n    },\n  })\n)\n```\n\nIn this code, MIME types for 'm3u8' and 'ts' files are added. This is important for the browser to handle the received content correctly.\n\n### Important Notes\n\n- The `serveStatic` function is used to serve static files in Hono.\n- The `rewriteRequestPath` function can be used to rewrite the request path.\n- You can add MIME types using the `mimes` option.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common Use Cases\n\n- Serving static files in a web application.\n- Adding MIME types for specific file types.",
      "ruleTitle": "Serving Static Files and Adding MIME Types in Hono",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle different scenarios when serving static files in Hono. It shows how to set custom headers when a file is found and how to handle situations when a file is not found. Understanding these handlers is crucial for building robust applications with proper error handling and response management.",
      "ruleFile": "## Handling Static Files in Hono\n\nThis code snippet demonstrates how to handle different scenarios when serving static files in Hono.\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    // ...\n    onFound: (_path, c) => {\n      c.header('Cache-Control', `public, immutable, max-age=31536000`)\n    },\n  })\n)\n```\n\nIn this example, the `onFound` handler is used to set a custom 'Cache-Control' header when a file is found. This can be useful for controlling how client browsers cache the static files.\n\nIt's also possible to define an `onNotFound` handler to handle situations when a file is not found. This could be used to log the event or return a custom error message.\n\n### Important Notes\n\n- The `onFound` and `onNotFound` handlers provide a way to customize the behavior of the server when serving static files.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common Use Cases\n\n- Serving static files such as images, stylesheets, and scripts in a web application.\n- Setting custom headers for caching or other purposes.\n- Customizing the error handling when a file is not found.",
      "ruleTitle": "Handling Static Files in Hono",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle scenarios when a requested file is not found in Hono framework. It also shows how to use the 'onNotFound' option in 'serveStatic' method to log the path that was not found and the path that was accessed.",
      "ruleFile": "## Handling File Not Found in Hono Framework\n\nThis code snippet demonstrates how to handle scenarios when a requested file is not found in Hono framework. It uses the 'onNotFound' option in 'serveStatic' method to log the path that was not found and the path that was accessed.\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    onNotFound: (path, c) => {\n      console.log(`${path} is not found, you access ${c.req.path}`)\n    },\n  })\n)\n```\n\n### How it works\n\nWhen a file is not found at the specified path, the 'onNotFound' function is triggered. This function takes two parameters - the path that was not found and the context 'c'. It then logs a message indicating the path that was not found and the path that was accessed.\n\n### Important notes\n\n- The 'onNotFound' option is a part of the 'serveStatic' method in Hono framework.\n- The 'serveStatic' method is used to serve static files.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en)\n\n### Common use cases\n\n- Logging file not found errors in a web application.",
      "ruleTitle": "Handling File Not Found in Hono Framework",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files in Hono with precompression enabled. Precompression can significantly reduce the size of the files being served, leading to faster load times and a better user experience. It also shows how Hono prioritizes different compression methods based on the 'Accept-Encoding' header.",
      "ruleFile": "## Serving Static Files with Precompression in Hono\n\nThis code snippet demonstrates how to serve static files with precompression enabled in Hono.\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    precompressed: true,\n  })\n)\n```\n\n### How it works\n\nThe `serveStatic` function is used with the `precompressed` option set to `true`. This tells Hono to check if precompressed versions of the files with extensions like `.br` or `.gz` are available and serve them based on the `Accept-Encoding` header. Hono prioritizes Brotli, then Zstd, and Gzip. If none are available, it serves the original file.\n\n### Important notes\n\n- The `precompressed` option should be used when you have precompressed versions of your static files available.\n- The path '/static/*' is a wildcard path that matches any path starting with '/static/'. You can replace this with the path to your static files.\n\n### References\n\n- [Hono Official Documentation](https://hono.boutell.com/)\n\n### Common use cases\n\n- Serving static files such as images, stylesheets, and scripts in a web application.",
      "ruleTitle": "Serving Static Files with Precompression in Hono",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to add a dependency in Deno and how to write a basic test using the Hono framework. It shows the usage of the `Deno.test` function and the `assertEquals` function from the `@std/assert` module. Understanding this rule is crucial for setting up tests for your Hono application.",
      "ruleFile": "## Adding a Dependency and Writing a Test in Hono\n\nThis code demonstrates how to add a dependency in Deno and how to write a basic test using the Hono framework.\n\nFirst, add the `@std/assert` module using the `deno add` command:\n\n```sh\ndeno add jsr:@std/assert\n```\n\nThen, write a test using the `Deno.test` function and the `assertEquals` function from the `@std/assert` module:\n\n```ts\nimport { Hono } from 'hono'\nimport { assertEquals } from '@std/assert'\n\nDeno.test('Hello World', async () => {\n  const app = new Hono()\n  app.get('/', (c) => c.text('Please test me'))\n\n  const\n```\n\n### How it Works\n\nThe `deno add` command adds the `@std/assert` module to your project. The `Deno.test` function is used to define a test, and the `assertEquals` function is used to assert that two values are equal.\n\n### Important Notes\n\n- The `Deno.test` function is asynchronous, so you need to use the `await` keyword when calling it.\n\n### References\n\n- [Deno Documentation](https://docs.deno.com/deploy/manual/)\n- [Hono Documentation](https://hono.com)\n\n### Common Use Cases\n\n- Writing tests for your Hono application",
      "ruleTitle": "Adding a Dependency and Writing a Test in Hono",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to write and run tests in Deno using the Hono framework and the assertEquals function from the @std/assert library. It is crucial to write tests for your application to ensure it behaves as expected.",
      "ruleFile": "## Writing and Running Tests in Deno using Hono and @std/assert\n\nThe following code snippet demonstrates how to write a simple test in Deno using the Hono framework and the assertEquals function from the @std/assert library.\n\n```ts\nimport { Hono } from 'hono'\nimport { assertEquals } from '@std/assert'\n\nDeno.test('Hello World', async () => {\n  const app = new Hono()\n  app.get('/', (c) => c.text('Please test me'))\n\n  const res = await app.request('http://localhost/')\n  assertEquals(res.status, 200)\n})\n```\n\nTo run the test, use the `deno test` command followed by the filename.\n\n```sh\ndeno test hello.ts\n```\n\n### How it Works\n\n1. The Hono framework is imported to create a new Hono application.\n2. The assertEquals function from the @std/assert library is imported to assert that the response status is 200.\n3. A new test is defined using the `Deno.test` function. The test creates a new Hono application, sets up a GET route, and makes a request to that route.\n4. The assertEquals function is used to assert that the response status is 200, indicating a successful request.\n\n### Important Notes\n\n- The @std/assert library provides a set of assertion functions for use in tests.\n- The `Deno.test` function is used to define a test.\n\n### References\n\n- [Deno Testing Documentation](https://deno.land/manual/testing)\n- [Hono Documentation](https://hono.land/)\n\n### Common Use Cases\n\n- Writing tests for a Hono application.\n- Asserting that a request to a Hono application returns a successful response.",
      "ruleTitle": "Writing and Running Tests in Deno using Hono and @std/assert",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic Hono application, how to handle a GET request, and how to test the application using Deno. It also shows how to import the Hono module using the `npm:` specifier in `deno.json`.",
      "ruleFile": "## Creating and Testing a Basic Hono Application\n\nThis code snippet demonstrates how to create a basic Hono application, handle a GET request, and test the application using Deno. It also shows how to import the Hono module using the `npm:` specifier in `deno.json`.\n\n```sh\nconst app = new Hono()\napp.get('/', (c) => c.text('Please test me'))\n\nconst res = await app.request('http://localhost/')\nassertEquals(res.status, 200)\n```\n\nThen run the command:\n\n```sh\ndeno test hello.ts\n```\n\nTo use the `npm:` specifier for importing Hono, fix the `deno.json` as follows:\n\n```json\n{\n  \"imports\": {\n    \"hono\": \"npm:hono\"\n  }\n}\n```\n\n### How it Works\n\n1. A new Hono application is created.\n2. A GET request handler is set up for the root URL ('/'). The handler sends a text response 'Please test me'.\n3. The application is tested by sending a request to 'http://localhost/' and asserting that the response status is 200.\n4. The `npm:` specifier is used to import the Hono module in `deno.json`.\n\n### Important Notes\n\n- The `npm:` specifier allows you to import npm packages in Deno.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/)\n- [Deno Documentation](https://deno.land/)\n\n### Common Use Cases\n\n- Creating a basic web application with Hono\n- Testing a Hono application with Deno\n- Importing npm packages in Deno",
      "ruleTitle": "Creating and Testing a Basic Hono Application and Importing npm Packages in Deno",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import the Hono library in a Deno project using either the 'npm:' or 'jsr:' specifiers. This is crucial for setting up a project with Hono and understanding how to switch between different versions or sources of the library.",
      "ruleFile": "## Importing Hono in a Deno Project\n\nThis code snippet demonstrates how to import the Hono library in a Deno project. You can use either the 'npm:' or 'jsr:' specifiers to import the library.\n\n```json\n{\n  \"imports\": {\n    \"hono\": \"jsr:@hono/hono\" // [!code --]\n    \"hono\": \"npm:hono\" // [!code ++]\n  }\n}\n```\n\n### How it Works\n\nIn the 'deno.json' file, you specify the source of the Hono library. The 'npm:' specifier imports the library from the npm registry, while the 'jsr:' specifier imports it from the jsr registry.\n\n### Important Notes\n\n- You can only use one specifier at a time. If you want to switch between specifiers, you need to comment out the current one and uncomment the other.\n- If you want to use third-party middleware with TypeScript type inferences, you need to use the 'npm:' specifier.\n\n### References\n\n- [Deno Manual - Import Maps](https://deno.land/manual/linking_to_external_code/import_maps)\n\n### Common Use Cases\n\n- Setting up a new Deno project with Hono\n- Switching between different versions or sources of the Hono library",
      "ruleTitle": "Importing Hono in a Deno Project",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import third-party middleware in Hono using the `npm:` specifier. This is crucial for leveraging external libraries and tools, such as the `@hono/zod-validator`, in your Hono projects.",
      "ruleFile": "## Importing Third-Party Middleware in Hono\n\nThis code snippet demonstrates how to import third-party middleware in Hono using the `npm:` specifier.\n\n```json\n{\n  \"imports\": {\n    \"hono\": \"npm:hono\",\n    \"zod\": \"npm:zod\",\n    \"@hono/zod-validator\": \"npm:@hono/zod-validator\"\n  }\n}\n```\n\n### How it Works\n\nIn the `imports` object, each key represents the name of the module you want to import, and the value is the specifier that tells Hono where to find the module. In this case, we're using the `npm:` specifier to tell Hono to look for these modules in the npm registry.\n\n### Important Notes\n\n- When using third-party middleware with TypeScript Type inferences, you need to use the `npm:` specifier.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common Use Cases\n\n- Importing validation libraries like `@hono/zod-validator` for input validation in your Hono applications.",
      "ruleTitle": "Importing Third-Party Middleware in Hono",
      "sourcePath": "docs/getting-started/deno.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a new Hono application and install its dependencies using different package managers. Understanding this is fundamental to getting started with the Hono framework.",
      "ruleFile": "# Creating a new Hono application and installing dependencies\n\nThis code snippet demonstrates how to create a new Hono application and install its dependencies using different package managers.\n\n```sh\nyarn create hono my-app\n```\n\n```sh\npnpm create hono my-app\n```\n\n```sh\nbun create hono@latest my-app\n```\n\n```sh\ndeno init --npm hono my-app\n```\n\nAfter creating the application, move into the application directory and install the dependencies.\n\n```sh\ncd my-app\nnpm i\n```\n\n```sh\ncd my-app\nyarn\n```\n\n```sh\ncd my-app\npnpm i\n```\n\n```sh\ncd my-app\nbun i\n```\n\n## How it works\n\nThe `create` command is used to create a new Hono application. The `cd` command is used to move into the application directory. The `i` or `install` command is used to install the dependencies of the application.\n\n## Important notes\n\nDifferent package managers require slightly different commands to create a new application and install its dependencies.\n\n## References\n\n- [Hono documentation](https://hono.bun.dev/)\n\n## Common use cases\n\n- Starting a new Hono project\n- Installing dependencies for a Hono project",
      "ruleTitle": "Creating a new Hono application and installing dependencies",
      "sourcePath": "docs/getting-started/vercel.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic 'Hello World' route using the Hono framework in a Vercel environment. It also shows how to install dependencies in different environments (npm, yarn, pnpm, bun). Understanding this rule is crucial for developers to get started with creating and handling routes in Hono.",
      "ruleFile": "## Setting Up a Basic Route and Installing Dependencies in Hono\n\nThis rule demonstrates how to set up a basic 'Hello World' route using the Hono framework in a Vercel environment. It also shows how to install dependencies in different environments (npm, yarn, pnpm, bun).\n\n### Code Snippet\n\n```ts\nimport { Hono } from 'hono'\nimport { handle } from 'hono/vercel'\n\nexport const runtime = 'edge'\n\nconst app = new Hono().basePath('/api')\n\napp.get('/hello', (c) => {\n  return c.json({\n    message: 'Hello World'\n  })\n})\n```\n\n### How it Works\n\n1. Import the necessary modules from Hono and Vercel.\n2. Set the runtime to 'edge'.\n3. Create a new Hono instance and set the base path to '/api'.\n4. Define a GET route '/hello' that returns a JSON object with a 'Hello World' message.\n\n### Important Notes\n\n- Ensure that the necessary dependencies are installed in your environment. You can do this by moving into your app directory and running the install command for your environment (npm i, yarn, pnpm i, bun i).\n\n### References\n\n- [Supported HTTP Methods](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#supported-http-methods)\n\n### Common Use Cases\n\n- Setting up basic routes in a Hono application.\n- Installing dependencies in different environments.",
      "ruleTitle": "Setting Up a Basic Route and Installing Dependencies in Hono",
      "sourcePath": "docs/getting-started/vercel.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic Hono application with Vercel and Next.js. It shows how to define the base path, create a simple GET route, and export the handlers for GET and POST requests. It also shows how to configure the runtime for the application in the `pages/api/[[...route]].ts` file.",
      "ruleFile": "## Setting up a Basic Hono Application with Vercel and Next.js\n\nThis code snippet demonstrates how to set up a basic Hono application with Vercel and Next.js.\n\n```javascript\nconst app = new Hono().basePath('/api')\n\napp.get('/hello', (c) => {\n  return c.json({\n    message: 'Hello Next.js!',\n  })\n})\n\nexport const GET = handle(app)\nexport const POST = handle(app)\n```\n\nIn the `pages/api/[[...route]].ts` file, you can configure the runtime for the application.\n\n```typescript\nimport { Hono } from 'hono'\nimport { handle } from 'hono/vercel'\nimport type { PageConfig } from 'next'\n\nexport const config: PageConfig = {\n  runtime: 'edge',\n}\n\nconst app = new Hono().basePath('/api')\n```\n\n### How it Works\n\n1. A new Hono application is created with the base path set to '/api'.\n2. A GET route '/hello' is defined that returns a JSON response.\n3. The handlers for GET and POST requests are exported.\n4. In the `pages/api/[[...route]].ts` file, the runtime for the application is configured to 'edge'.\n\n### Important Notes\n\n- The `basePath` method is used to set the base path for the application.\n- The `get` method is used to define a GET route.\n- The `handle` function from 'hono/vercel' is used to create the handlers for GET and POST requests.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n- [Vercel Documentation](https://vercel.com/docs)\n- [Next.js Documentation](https://nextjs.org/docs)\n\n### Common Use Cases\n\n- Creating a basic Hono application with Vercel and Next.js.\n- Defining routes and handlers for GET and POST requests.",
      "ruleTitle": "Setting up a Basic Hono Application with Vercel and Next.js",
      "sourcePath": "docs/getting-started/vercel.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define a simple GET endpoint using the Hono web framework and how to run the development server locally. It also shows how to return a JSON response from the endpoint, which is a common requirement in web development.",
      "ruleFile": "## Defining a GET Endpoint and Running the Server Locally\n\nThis code snippet demonstrates how to define a simple GET endpoint in Hono and how to run the development server locally.\n\n```javascript\nconst app = new Hono().basePath('/api')\n\napp.get('/hello', (c) => {\n  return c.json({\n    message: 'Hello Next.js!',\n  })\n})\n\nexport default handle(app)\n```\n\nTo run the development server locally, use one of the following commands:\n\n```sh\nnpm run dev\n```\n\n```sh\nyarn dev\n```\n\n```sh\npnpm dev\n```\n\n```sh\nbun run dev\n```\n\nAfter running the server, you can access `http://localhost:3000` in your web browser. The `/api/hello` endpoint will return a JSON response with the message 'Hello Next.js!'.\n\n### Important Notes\n\n- The `basePath` method is used to set the base path for all routes.\n- The `get` method is used to define a GET endpoint.\n- The `json` method is used to return a JSON response.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common Use Cases\n\n- Defining endpoints for a REST API\n- Returning JSON responses from endpoints",
      "ruleTitle": "Defining a GET Endpoint and Running the Server Locally in Hono",
      "sourcePath": "docs/getting-started/vercel.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up and run a Hono application locally, deploy it using Vercel, and how to set the runtime to Node.js. Understanding this process is crucial for developers to effectively use the Hono framework and deploy their applications.",
      "ruleFile": "## Running and Deploying a Hono Application\n\nThis code snippet demonstrates how to run a Hono application locally, deploy it using Vercel, and set the runtime to Node.js.\n\n```text\n:::\n\nNow, `/api/hello` just returns JSON, but if you build React UIs, you can create a full-stack application with Hono.\n\n## 4. Deploy\n\nIf you have a Vercel account, you can deploy by linking the Git repository.\n\n## Node.js\n\nYou can also run Hono on Next.js running on the Node.js runtime.\n\n### App Router\n\nFor the App Router, you can simply set the runtime to `nodejs` in your route handler:\n```\n\n### How it works\n\n1. Run the Hono application locally using the command `npm run dev`, `yarn dev`, `pnpm dev`, or `bun run dev`.\n2. Access the application in your web browser at `http://localhost:3000`.\n3. To deploy the application, link the Git repository to your Vercel account.\n4. To run Hono on Next.js with the Node.js runtime, set the runtime to `nodejs` in your route handler.\n\n### Important notes\n\n- Ensure that you have installed the required dependencies before running the application locally.\n- You need a Vercel account to deploy the application.\n\n### References\n\n- [Hono documentation](https://hono.dev/docs/getting-started)\n\n### Common use cases\n\n- Developing and deploying full-stack applications using Hono and Vercel.\n- Running Hono on Next.js with the Node.js runtime.",
      "ruleTitle": "Running and Deploying a Hono Application",
      "sourcePath": "docs/getting-started/vercel.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define a basic Hono application with a single route and how to handle GET and POST requests. It also shows the necessity of installing the Node.js adapter for the Pages Router in Hono.",
      "ruleFile": "## Defining a Basic Hono Application and Installing Node.js Adapter for Pages Router\n\nThis code snippet demonstrates how to define a basic Hono application with a single route and how to handle GET and POST requests. It also shows the necessity of installing the Node.js adapter for the Pages Router in Hono.\n\n```javascript\nconst app = new Hono().basePath('/api')\n\napp.get('/hello', (c) => {\n  return c.json({\n    message: 'Hello from Hono!',\n  })\n})\n\nexport const GET = handle(app)\nexport const POST = handle(app)\n```\n\n### How it works\n\n1. A new Hono application is created with a base path of '/api'.\n2. A GET route '/hello' is defined which returns a JSON response with a message.\n3. The GET and POST handlers for the application are exported.\n\n### Important notes\n\n- The Node.js adapter needs to be installed for the Pages Router in Hono. This can be done using npm, yarn, pnpm, or bun.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common use cases\n\n- Defining basic routes in a Hono application.\n- Handling different types of HTTP requests in a Hono application.",
      "ruleTitle": "Defining a Basic Hono Application and Installing Node.js Adapter for Pages Router",
      "sourcePath": "docs/getting-started/vercel.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to install the Hono node server using different package managers and how to import and utilize the 'handle' function from '@hono/node-server/vercel'. This is a fundamental step in setting up a Hono server and utilizing its functionalities.",
      "ruleFile": "## Installing Hono Node Server and Utilizing the Handle Function\n\nThis code snippet demonstrates how to install the Hono node server using different package managers and how to import and utilize the 'handle' function from '@hono/node-server/vercel'.\n\n```sh\nnpm i @hono/node-server\n```\n\n```sh\nyarn add @hono/node-server\n```\n\n```sh\npnpm add @hono/node-server\n```\n\n```sh\nbun add @hono/node-server\n```\n\nAfter installing, you can import and use the 'handle' function as shown below:\n\n```ts\nimport { Hono } from 'hono'\nimport { handle } from '@hono/node-server/vercel'\nimport type { PageConfig } from 'next'\n\nexport const config: PageConfig = {\n  api: {\n    bodyParser: false,\n  },\n}\n```\n\n### How it Works\n\nThe 'handle' function is a utility function provided by the Hono node server for handling requests and responses in a serverless function environment.\n\n### Important Notes\n\nEnsure that the Hono node server is installed before attempting to import and use the 'handle' function.\n\n### References\n\n- Hono Documentation: https://hono.io/docs/getting-started\n\n### Common Use Cases\n\n- Setting up a Hono server\n- Handling requests and responses in a serverless function environment",
      "ruleTitle": "Installing Hono Node Server and Utilizing the Handle Function",
      "sourcePath": "docs/getting-started/vercel.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to disable Vercel Node.js helpers for Hono to work with the Pages Router. This is crucial because Hono might not function correctly with the Vercel Node.js helpers enabled.",
      "ruleFile": "## Disabling Vercel Node.js Helpers for Hono\n\nIn this code snippet, we are disabling Vercel Node.js helpers to ensure Hono works correctly with the Pages Router. This is done by setting up an environment variable in your project dashboard or in your `.env` file.\n\n```text\nNODEJS_HELPERS=0\n```\n\n### How it works\n\nBy setting the `NODEJS_HELPERS` environment variable to `0`, we are disabling Vercel Node.js helpers. This is necessary because Hono might not function correctly with these helpers enabled.\n\n### Important notes\n\nEnsure to set this environment variable in your project dashboard or in your `.env` file.\n\n### References\n\n- Hono documentation\n- Vercel documentation\n\n### Common use cases\n\nThis is commonly used when you are using Hono with the Pages Router and you are deploying your application on Vercel.",
      "ruleTitle": "Disabling Vercel Node.js Helpers for Hono",
      "sourcePath": "docs/getting-started/vercel.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono framework on Lambda@Edge. It shows the process of setting up the application, adding Hono, creating a lambda directory, and defining a simple GET route. This is a fundamental pattern in Hono framework usage.",
      "ruleFile": "## Creating a Basic 'Hello World' Application with Hono on Lambda@Edge\n\nThis code demonstrates how to create a basic 'Hello World' application using the Hono framework on Lambda@Edge.\n\n```sh\nmkdir my-app\ncd my-app\ncdk init app -l typescript\npnpm add hono\nmkdir lambda\n```\n\nAfter setting up the application and adding Hono, a lambda directory is created. Then, a simple GET route is defined in `lambda/index_edge.ts`.\n\n```ts\nimport { Hono } from 'hono'\nimport { handle } from 'hono/lambda-edge'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Hono on Lambda@Edge!'))\n\nexport const handler = handle(app)\n```\n\n### How it works\n\n1. A new Hono application is created.\n2. A GET route is defined on the root path ('/'). When this route is accessed, it responds with the text 'Hello Hono on Lambda@Edge!'.\n3. The application is exported as a handler that can be used by AWS Lambda.\n\n### Important notes\n\n- Ensure that Hono is added to the project using `pnpm add hono` or `bun add hono`.\n- The lambda directory must be created in the project root.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Creating a basic web application with Hono.\n- Setting up a serverless application with AWS Lambda.",
      "ruleTitle": "Creating a Basic 'Hello World' Application with Hono on Lambda@Edge",
      "sourcePath": "docs/getting-started/lambda-edge.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic Hono application and deploy it using AWS Lambda@Edge. It shows the process of creating a Hono instance, defining a simple GET route, and exporting the handler for AWS Lambda@Edge to use. This is a fundamental pattern in serverless applications using the Hono framework.",
      "ruleFile": "## Creating and Deploying a Basic Hono Application with AWS Lambda@Edge\n\nThis code demonstrates how to set up a basic Hono application and deploy it using AWS Lambda@Edge.\n\n```ts\nimport { Hono } from 'hono'\nimport { handle } from 'hono/lambda-edge'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Hono on Lambda@Edge!'))\n\nexport const handler = handle(app)\n```\n\nTo deploy the application, edit `bin/my-app.ts`.\n\n```ts\n#!/usr/bin/env node\nimport 'source-map-support/register'\nimport * as cdk from 'aws-cdk-lib'\nimport { MyAppStack } from '../lib/my-app-stack'\n\nconst app = new cdk.App()\nnew MyAppStack(app, 'MyAppStack')\n```\n\n### How it Works\n\n1. A new instance of Hono is created.\n2. A GET route is defined on the root path ('/') of the application. When this route is hit, it returns the text 'Hello Hono on Lambda@Edge!'.\n3. The handler for the Hono application is exported using the `handle` function from 'hono/lambda-edge'. This handler can be used by AWS Lambda@Edge to handle incoming requests.\n4. To deploy the application, a new AWS CDK App is created and a new instance of `MyAppStack` is added to the app.\n\n### Important Notes\n\n- The `handle` function from 'hono/lambda-edge' is used to create a handler for AWS Lambda@Edge.\n\n### References\n\n- [Hono Documentation](https://hono.boutique/docs/)\n\n### Common Use Cases\n\n- Creating serverless applications with Hono and AWS Lambda@Edge.",
      "ruleTitle": "Creating and Deploying a Basic Hono Application with AWS Lambda@Edge",
      "sourcePath": "docs/getting-started/lambda-edge.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to initialize a new application stack in Hono using the AWS CDK (Cloud Development Kit). It shows how to set the environment variables for the AWS account and region. This is a fundamental step in setting up an application in Hono, as it sets up the basic infrastructure for the application.",
      "ruleFile": "## Initializing a New Application Stack in Hono\n\nThis code snippet demonstrates how to initialize a new application stack in Hono using the AWS CDK.\n\n```ts\nimport { MyAppStack } from '../lib/my-app-stack'\n\nconst app = new cdk.App()\nnew MyAppStack(app, 'MyAppStack', {\n  env: {\n    account: process.env.CDK_DEFAULT_ACCOUNT,\n    region: 'us-east-1',\n  },\n})\n```\n\n### How it works\n\n1. Import the `MyAppStack` class from the `lib` directory.\n2. Create a new instance of the `cdk.App` class.\n3. Create a new instance of the `MyAppStack` class, passing in the `app` instance, a name for the stack, and an object containing the environment variables for the AWS account and region.\n\n### Important notes\n\n- The `CDK_DEFAULT_ACCOUNT` environment variable should be set to your AWS account ID.\n- The region is set to 'us-east-1', but this can be changed to any valid AWS region.\n\n### References\n\n- [AWS CDK Documentation](https://docs.aws.amazon.com/cdk/latest/guide/home.html)\n\n### Common use cases\n\n- Initializing a new application stack in Hono.",
      "ruleTitle": "Initializing a New Application Stack in Hono",
      "sourcePath": "docs/getting-started/lambda-edge.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy an edge lambda function using the Hono framework and the Cloud Development Kit (CDK). It also shows how to use the callback function for Basic Auth and request processing after verification.",
      "ruleFile": "## Deploying Edge Lambda Function and Using Callback in Hono Framework\n\nThis code snippet demonstrates how to deploy an edge lambda function using the Hono framework and the Cloud Development Kit (CDK). It also shows how to use the callback function for Basic Auth and request processing after verification.\n\n```text\nedgeLambdas: [\n  {\n    functionVersion: edgeFn.currentVersion,\n    eventType: cloudfront.LambdaEdgeEventType.VIEWER_REQUEST,\n  },\n],\n},\n})\n}\n}\n```\n\nTo deploy the function, run the following command:\n\n```sh\ncdk deploy\n```\n\nIf you want to add Basic Auth and continue with request processing after verification, you can use `c.env.callback()`:\n\n```ts\nimport { Hono } from 'hono'\nimport { basicA\n```\n\n### How it Works\n\nThe `edgeLambdas` array contains the configuration for the edge lambda function. The `functionVersion` is the current version of the function, and the `eventType` is the type of event that triggers the function. The `cdk deploy` command deploys the function.\n\nThe `c.env.callback()` function is used for Basic Auth and to continue with request processing after verification.\n\n### Important Notes\n\nEnsure that the `functionVersion` and `eventType` are correctly set in the `edgeLambdas` array. Also, make sure to import the necessary modules before using the `c.env.callback()` function.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs)\n\n### Common Use Cases\n\nThis pattern is commonly used when deploying edge lambda functions and implementing Basic Auth in applications using the Hono framework.",
      "ruleTitle": "Deploying Edge Lambda Function and Using Callback in Hono Framework",
      "sourcePath": "docs/getting-started/lambda-edge.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the callback function in Hono to add Basic Auth and continue with request processing after verification. This is a common pattern in Hono where the callback function is used to continue the execution of the application after a certain operation has been completed.",
      "ruleFile": "## Using Callback in Hono for Basic Auth and Request Processing\n\nIn Hono, you can use the `c.env.callback()` function to add Basic Auth and continue with request processing after verification. This is a common pattern in Hono where the callback function is used to continue the execution of the application after a certain operation has been completed.\n\nHere is a code snippet demonstrating this:\n\n```ts\nimport { Hono } from 'hono'\nimport { basicAuth } from 'hono/basic-auth'\nimport type { Callback, CloudFrontRequest } from 'hono/lambda-edge'\nimport { handle } from 'hono/lambda-edge'\n\ntype Bindings \n```\n\n### How it works\n\nThe `c.env.callback()` function is called after the Basic Auth operation has been completed. This function then continues the execution of the application.\n\n### Important notes\n\n- The `c.env.callback()` function is a part of the Hono framework and is used to continue the execution of the application after a certain operation has been completed.\n\n### References\n\n- Hono Documentation\n\n### Common use cases\n\n- Adding Basic Auth to an application and continuing with request processing after verification.",
      "ruleTitle": "Using Callback in Hono for Basic Auth and Request Processing",
      "sourcePath": "docs/getting-started/lambda-edge.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono framework in an AWS Lambda environment. It shows how to initialize a new Hono application, define a route handler for the root path ('/') and export the handler for AWS Lambda to use.",
      "ruleFile": "## Creating a Basic Hono Application for AWS Lambda\n\nThis code snippet demonstrates how to create a basic 'Hello World' application using the Hono framework in an AWS Lambda environment.\n\n```ts\nimport { Hono } from 'hono'\nimport { handle } from 'hono/aws-lambda'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Hono!'))\n\nexport const handler = handle(app)\n```\n\n### How it works\n\n1. The Hono and handle modules from 'hono/aws-lambda' are imported.\n2. A new Hono application is created.\n3. A route handler for the root path ('/') is defined. This handler simply returns the text 'Hello Hono!'.\n4. The handler is exported for AWS Lambda to use.\n\n### Important notes\n\n- The 'handle' function from 'hono/aws-lambda' is used to create a handler that AWS Lambda can use to handle incoming requests.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Creating a basic serverless application using Hono and AWS Lambda.",
      "ruleTitle": "Creating a Basic Hono Application for AWS Lambda",
      "sourcePath": "docs/getting-started/aws-lambda.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic Hono application and deploy it using AWS Lambda. It shows how to create a Hono application, define a simple GET route, and export a handler for AWS Lambda. This is a fundamental pattern in serverless applications development using Hono and AWS Lambda.",
      "ruleFile": "## Hono AWS Lambda Deployment\n\nThis code snippet demonstrates how to set up a basic Hono application and deploy it using AWS Lambda.\n\n```ts\nimport { Hono } from 'hono'\nimport { handle } from 'hono/aws-lambda'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Hono!'))\n\nexport const handler = handle(app)\n```\n\n### How it works\n\n1. Import the `Hono` class from the `hono` package and the `handle` function from `hono/aws-lambda`.\n2. Create a new instance of `Hono`.\n3. Define a GET route for the root URL (`/`) that responds with 'Hello Hono!'.\n4. Export a handler for AWS Lambda using the `handle` function, passing the Hono application instance as an argument.\n\n### Important notes\n\n- The `handle` function is specifically designed for AWS Lambda and helps to adapt the Hono application to the AWS Lambda environment.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n- [AWS Lambda Documentation](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)\n\n### Common use cases\n\n- Creating serverless applications with Hono and AWS Lambda.\n- Deploying Hono applications to AWS Lambda.",
      "ruleTitle": "Setting Up and Deploying a Hono Application with AWS Lambda",
      "sourcePath": "docs/getting-started/aws-lambda.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy an AWS Lambda function using the Hono framework. It also shows how to add a function URL and create a REST API for the function. Understanding this rule is crucial for developers who want to deploy serverless applications using Hono and AWS Lambda.",
      "ruleFile": "## Deploying AWS Lambda Function with Hono\n\nThis code snippet demonstrates how to deploy an AWS Lambda function using the Hono framework. It also shows how to add a function URL and create a REST API for the function.\n\n```text\nuntime: lambda.Runtime.NODEJS_20_X,\n})\nfn.addFunctionUrl({\n  authType: lambda.FunctionUrlAuthType.NONE,\n})\nnew apigw.LambdaRestApi(this, 'myapi', {\n  handler: fn,\n})\n}\n```\n\nTo deploy the function, run the command:\n\n```sh\ncdk deploy\n```\n\n### How it works\n\n1. The `lambda.Runtime.NODEJS_20_X` specifies the runtime environment for the Lambda function.\n2. The `addFunctionUrl` method is used to add a URL for the function. The `authType` is set to `NONE`, meaning no authentication is required to access the function.\n3. The `LambdaRestApi` class is used to create a REST API for the function.\n4. The `cdk deploy` command is used to deploy the function.\n\n### Important notes\n\n- Make sure to replace `'myapi'` with the actual name of your API.\n- The `cdk deploy` command should be run in the root directory of your project.\n\n### References\n\n- [AWS CDK Documentation](https://docs.aws.amazon.com/cdk/latest/guide/home.html)\n\n### Common use cases\n\n- Deploying serverless applications using AWS Lambda and Hono.",
      "ruleTitle": "Deploying AWS Lambda Function with Hono",
      "sourcePath": "docs/getting-started/aws-lambda.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve binary data in Hono using AWS Lambda. It shows that base64 encoding is required to return binary data in Lambda and once the binary type is set to `Content-Type` header, Hono automatically encodes the data to base64.",
      "ruleFile": "## Serve Binary data in Hono using AWS Lambda\n\nHono supports binary data as a response. In AWS Lambda, base64 encoding is required to return binary data. Once binary type is set to `Content-Type` header, Hono automatically encodes data to base64.\n\n```ts\napp.get('/binary', async (c) => {\n  // ...\n  c.status(200)\n  c.header('Content-Type', 'image/png') // means binary data\n  return c.body(buffer) // supports `ArrayBufferLike` type, encoded to base64\n```\n\n### How it works\n\n1. Define a route using `app.get()`.\n2. Set the status code to 200 using `c.status(200)`.\n3. Set the `Content-Type` header to the type of binary data you are serving using `c.header('Content-Type', 'image/png')`.\n4. Return the binary data as the response body using `return c.body(buffer)`. Hono will automatically encode the `ArrayBufferLike` type data to base64.\n\n### Important notes\n\n- Hono automatically handles the base64 encoding once the `Content-Type` header is set to a binary type.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Serving images or other binary data from a Hono application using AWS Lambda.",
      "ruleTitle": "Serving Binary Data in Hono using AWS Lambda",
      "sourcePath": "docs/getting-started/aws-lambda.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle binary data in Hono. It shows how to set the status and content type of the response, and how to return binary data in the response body.",
      "ruleFile": "## Handling Binary Data in Hono\n\nIn Hono, you can handle binary data by setting the status and content type of the response, and returning the binary data in the response body.\n\n```ts\np.get('/binary', async (c) => {\n  // ...\n  c.status(200)\n  c.header('Content-Type', 'image/png') // means binary data\n  return c.body(buffer) // supports `ArrayBufferLike` type, encoded to base64.\n})\n```\n\n### How it works\n\n1. `c.status(200)`: This sets the HTTP status code of the response to 200.\n2. `c.header('Content-Type', 'image/png')`: This sets the content type of the response to 'image/png', indicating that the response contains binary data.\n3. `return c.body(buffer)`: This returns the binary data in the response body. The `body` method supports `ArrayBufferLike` type, which is encoded to base64.\n\n### Important notes\n\n- The `body` method supports `ArrayBufferLike` type, which is encoded to base64. This means that you can return binary data in the response body.\n\n### References\n\n- [Hono documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Returning images or other binary data in the response body.",
      "ruleTitle": "Handling Binary Data in Hono",
      "sourcePath": "docs/getting-started/aws-lambda.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to access the AWS Lambda request context in Hono. Understanding this is crucial for developers who need to interact with AWS Lambda functions and retrieve specific information from the request context.",
      "ruleFile": "## Accessing AWS Lambda RequestContext in Hono\n\nIn Hono, you can access the AWS Lambda request context by binding the `LambdaEvent` type and using `c.env.event.requestContext`.\n\n```ts\nimport { Hono } from 'hono'\nimport type { LambdaEvent } from 'hono/aws-lambda'\nimport { handle } from 'hono/aws-lambda'\n\ntype Bindings = {\n  event: LambdaEvent\n}\n\nconst app = new Hono<{ Bindings: Bindings }>()\n\napp.get('/aws-lambda-info/', (c) => {\n  return c.json({\n    isBase64Encoded: c.env.event.isBase64Encoded,\n    awsRequestId: c.env.lambdaContext.awsRequestId,\n  })\n})\n\nexport const handler = handle(app)\n```\n\n### How it works\n\n1. Import the necessary modules from Hono and AWS Lambda.\n2. Define the bindings for the AWS Lambda event.\n3. Create a new Hono application with the defined bindings.\n4. Define a GET route that returns a JSON response with specific information from the AWS Lambda request context.\n5. Export the handler function that handles the Hono application.\n\n### Important notes\n\n- The `LambdaEvent` type provides access to the AWS Lambda request context.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common use cases\n\n- Retrieving specific information from the AWS Lambda request context for processing in your application.",
      "ruleTitle": "Accessing AWS Lambda RequestContext in Hono",
      "sourcePath": "docs/getting-started/aws-lambda.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to access the AWS Lambda request context in Hono before version 3.10.0. This is crucial when developing AWS Lambda functions using Hono, as it allows developers to access and manipulate the request context, which contains useful information about the request.",
      "ruleFile": "## Accessing AWS Lambda Request Context in Hono (Before v3.10.0)\n\nThis code snippet demonstrates how to access the AWS Lambda request context in Hono before version 3.10.0. This is done by binding the `ApiGatewayRequestContext` type and using `c.env.`.\n\n```text\nimport { Hono } from 'hono'\nimport type { ApiGatewayRequestContext } from 'hono/aws-lambda'\nimport { handle } from 'hono/aws-lambda'\n\ntype Bindings = {\n  requestContext: ApiGatewayRequestContext\n}\n\napp.get('/custom-context/', (c) => {\n  const lambdaContext = c.env.event.requestContext\n  return c.json(lambdaContext)\n})\n\nexport const handler = handle(app)\n```\n\n### How it works\n\n1. The `ApiGatewayRequestContext` type is imported from `hono/aws-lambda`.\n2. A new Hono app is created with the `Bindings` type, which includes `requestContext` of type `ApiGatewayRequestContext`.\n3. In the route handler for '/custom-context/', the AWS Lambda request context is accessed through `c.env.event.requestContext`.\n4. The request context is then returned as a JSON response.\n\n### Important notes\n\n- This method is deprecated in Hono version 3.10.0 and later.\n\n### References\n\n- Hono documentation: [https://hono.bayfront.io/](https://hono.bayfront.io/)\n\n### Common use cases\n\n- Accessing the AWS Lambda request context to get information about the request, such as the HTTP method, path, headers, and more.",
      "ruleTitle": "Accessing AWS Lambda Request Context in Hono (Before v3.10.0)",
      "sourcePath": "docs/getting-started/aws-lambda.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important because it demonstrates how to change the invocation mode of AWS Lambda to achieve a streaming response. This is useful when you want to send large amounts of data in chunks rather than all at once, which can improve performance and reduce memory usage.",
      "ruleFile": "## Lambda Response Streaming in Hono\n\nIn Hono, you can change the invocation mode of AWS Lambda to achieve a streaming response. This is done by setting the `invokeMode` property to `lambda.InvokeMode.RESPONSE_STREAM` when adding a function URL.\n\n```diff\nfn.addFunctionUrl({\n  authType: lambda.FunctionUrlAuthType.NONE,\n+  invokeMode: lambda.InvokeMode.RESPONSE_STREAM,\n})\n```\n\nThis change allows AWS Lambda to send large amounts of data in chunks rather than all at once, which can improve performance and reduce memory usage.\n\n### How it Works\n\nWhen you set the `invokeMode` to `RESPONSE_STREAM`, AWS Lambda will write data to a NodeJS.Writable stream. This allows the data to be sent in chunks rather than all at once.\n\n### Important Notes\n\n- The `invokeMode` property is only available in the `addFunctionUrl` method.\n- The `RESPONSE_STREAM` mode is best used when you need to send large amounts of data.\n\n### References\n\n- [AWS Lambda Response Streaming](https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/)\n\n### Common Use Cases\n\n- Sending large amounts of data from a Lambda function.\n- Reducing memory usage when sending data from a Lambda function.",
      "ruleTitle": "Achieving Streaming Response with AWS Lambda in Hono",
      "sourcePath": "docs/getting-started/aws-lambda.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to achieve traditional streaming response in Hono using AWS Lambda Adaptor's streamHandle instead of handle. This is crucial for developers who want to leverage the power of AWS Lambda functions in their Hono applications without losing the traditional streaming response functionality.",
      "ruleFile": "## AWS Lambda Response Streaming in Hono\n\nIn Hono, you can achieve the traditional streaming response using AWS Lambda Adaptor's `streamHandle` instead of `handle`. This is particularly useful when you want to leverage the power of AWS Lambda functions in your Hono applications without losing the traditional streaming response functionality.\n\nHere's how you can do it:\n\n```ts\nimport { Hono } from 'hono'\nimport { streamHandle } from 'hono/aws-lambda'\n\nconst app = new Hono()\n\napp.get('/stream', async (c) => {\n  return streamText(c, async (stream) => {\n    for (let i = 0; \n```\n\n### How it works\n\nTypically, the implementation requires writing chunks to NodeJS.WritableStream using `awslambda.streamifyResponse`. But with the AWS Lambda Adaptor, you can achieve the traditional streaming response of Hono by using `streamHandle` instead of `handle`.\n\n### Important notes\n\nMake sure to set the `invokeMode` to `RESPONSE_STREAM` when adding the function URL.\n\n```diff\nfn.addFunctionUrl({\n  authType: lambda.FunctionUrlAuthType.NONE,\n+  invokeMode: lambda.InvokeMode.RESPONSE_STREAM,\n})\n```\n\n### References\n\n- [AWS Lambda Response Streaming](https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/)\n\n### Common use cases\n\n- Streaming large amounts of data from AWS Lambda functions\n- Implementing real-time updates or notifications",
      "ruleTitle": "Implementing Traditional Streaming Response in Hono with AWS Lambda Adaptor",
      "sourcePath": "docs/getting-started/aws-lambda.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono framework and the hono-alibaba-cloud-fc3-adapter. It shows how to set up the project, import necessary modules, create a new Hono instance, define a route, and export the handler function.",
      "ruleFile": "## Creating a Basic Hono Application\n\nThis code snippet demonstrates how to create a basic 'Hello World' application using the Hono framework and the hono-alibaba-cloud-fc3-adapter.\n\n```ts\nimport { Hono } from 'hono'\nimport { handle } from 'hono-alibaba-cloud-fc3-adapter'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Hono!'))\n\nexport const handler = handle(app)\n```\n\n### How it Works\n\n1. The `Hono` and `handle` modules are imported from 'hono' and 'hono-alibaba-cloud-fc3-adapter' respectively.\n2. A new instance of `Hono` is created and assigned to the `app` variable.\n3. A GET route is defined on the root path ('/') of the application. When this route is hit, it responds with the text 'Hello Hono!'.\n4. The `handle` function is used to create a handler for the `app` and this handler is exported.\n\n### Important Notes\n\n- The `handle` function from 'hono-alibaba-cloud-fc3-adapter' is used to create a handler for the Hono application. This is necessary for the application to work with Alibaba Cloud Function Compute.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common Use Cases\n\n- This pattern is commonly used when creating a basic Hono application for Alibaba Cloud Function Compute.",
      "ruleTitle": "Creating a Basic Hono Application",
      "sourcePath": "docs/getting-started/ali-function-compute.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic Hono application and integrate it with Alibaba Cloud Function Compute using the Hono Alibaba Cloud FC3 adapter. It also shows how to use the serverless-devs tool to manage serverless applications.",
      "ruleFile": "## Setting Up a Basic Hono Application and Integrating with Alibaba Cloud Function Compute\n\nThis code snippet demonstrates how to set up a basic Hono application and integrate it with Alibaba Cloud Function Compute using the Hono Alibaba Cloud FC3 adapter. It also shows how to use the serverless-devs tool to manage serverless applications.\n\n```ts\nimport { Hono } from 'hono'\nimport { handle } from 'hono-alibaba-cloud-fc3-adapter'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Hono!'))\n\nexport const handler = handle(app)\n```\n\n### How it Works\n\n1. Import the necessary modules from Hono and the Hono Alibaba Cloud FC3 adapter.\n2. Create a new Hono application.\n3. Define a GET route that responds with 'Hello Hono!'.\n4. Export a handler function that wraps the Hono application with the Alibaba Cloud FC3 adapter.\n\n### Important Notes\n\n- The handler function is what Alibaba Cloud Function Compute will use to handle incoming requests.\n\n### References\n\n- [Hono](https://github.com/hono-xx/hono)\n- [Hono Alibaba Cloud FC3 Adapter](https://github.com/hono-xx/hono-alibaba-cloud-fc3-adapter)\n- [Serverless Devs](https://github.com/Serverless-Devs/Serverless-Devs)\n\n### Common Use Cases\n\n- Creating serverless applications that run on Alibaba Cloud Function Compute.",
      "ruleTitle": "Setting Up a Basic Hono Application and Integrating with Alibaba Cloud Function Compute",
      "sourcePath": "docs/getting-started/ali-function-compute.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure Alibaba Cloud AccessKeyID & AccessKeySecret and how to set up a basic serverless application configuration in Hono using the 's.yaml' file. This is a crucial step in deploying serverless applications on Alibaba Cloud using Hono.",
      "ruleFile": "## Alibaba Cloud AccessKeyID & AccessKeySecret Configuration and Basic Serverless Application Setup in Hono\n\nThis code snippet demonstrates how to add the Alibaba Cloud AccessKeyID & AccessKeySecret and how to set up a basic serverless application configuration in Hono using the 's.yaml' file.\n\n```sh\nnpx s config add\n# Please select a provider: Alibaba Cloud (alibaba)\n# Input your AccessKeyID & AccessKeySecret\n```\n\nAfter adding the AccessKeyID & AccessKeySecret, you need to edit the 's.yaml' file as follows:\n\n```yaml\nedition: 3.0.0\nname: my-app\naccess: 'default'\n\nvars:\n  region: 'us-west-1'\n\nresources:\n  my-app:\n    component: fc3\n    props:\n      region: ${vars.region}\n      functionName: 'my-app'\n      desc\n```\n\n### How it works\n\n1. The 'npx s config add' command is used to add the Alibaba Cloud AccessKeyID & AccessKeySecret.\n2. The 's.yaml' file is a serverless application model file in Hono. It defines the serverless application.\n\n### Important notes\n\n- The 'access' field in the 's.yaml' file should match the name you used when you configured your Alibaba Cloud credentials.\n- The 'region' is a variable that is defined under the 'vars' field and is used in the 'props' field.\n\n### References\n\n- [Hono Documentation](https://www.hono.io/)\n\n### Common use cases\n\n- Setting up a serverless application on Alibaba Cloud using Hono.",
      "ruleTitle": "Configuring Alibaba Cloud AccessKeyID & AccessKeySecret and Basic Serverless Application Setup in Hono",
      "sourcePath": "docs/getting-started/ali-function-compute.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure the build and deploy scripts in the package.json file for a Hono application. This is a crucial step in automating the build and deployment process of the application.",
      "ruleFile": "## Configuring Build and Deploy Scripts in package.json for Hono Applications\n\nThis code snippet demonstrates how to configure the build and deploy scripts in the package.json file for a Hono application.\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"esbuild --bundle --outfile=./dist/index.js --platform=node --target=node20 ./src/index.ts\",\n    \"deploy\": \"s deploy -y\"\n  }\n}\n```\n\n### How it works\n\n1. The `build` script uses esbuild to bundle the TypeScript source code into a single JavaScript file, which is output to the ./dist directory.\n2. The `deploy` script uses the Serverless Framework's deploy command to deploy the application.\n\n### Important notes\n\n- The `--platform=node` and `--target=node20` options in the `build` script specify that the code should be bundled for the Node.js 20 runtime.\n- The `-y` option in the `deploy` script automatically confirms any prompts that may appear during the deployment process.\n\n### References\n\n- [esbuild documentation](https://esbuild.github.io/getting-started/)\n- [Serverless Framework documentation](https://www.serverless.com/framework/docs/)\n\n### Common use cases\n\n- Automating the build and deployment process of a Hono application",
      "ruleTitle": "Configuring Build and Deploy Scripts in package.json for Hono Applications",
      "sourcePath": "docs/getting-started/ali-function-compute.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy a function to Alibaba Cloud Function Compute using npm scripts. It shows the correct sequence of commands to compile TypeScript code to JavaScript and then deploy the function.",
      "ruleFile": "## Deploying a Function to Alibaba Cloud Function Compute\n\nThis code snippet demonstrates how to deploy a function to Alibaba Cloud Function Compute using npm scripts.\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"esbuild --bundle --outfile=./dist/index.js --platform=node --target=node20 ./src/index.ts\",\n    \"deploy\": \"s deploy -y\"\n  }\n}\n```\n\nTo deploy, run the following commands:\n\n```sh\nnpm run build # Compile the TypeScript code to JavaScript\nnpm run deploy # Deploy the function to Alibaba Cloud Function Compute\n```\n\n### How it Works\n\n1. The `build` script uses esbuild to compile the TypeScript code to JavaScript, targeting Node.js 20 and outputting the result to `./dist/index.js`.\n2. The `deploy` script uses the Serverless Framework's `s` command to deploy the function, with the `-y` flag automatically confirming any prompts.\n\n### Important Notes\n\n- Ensure that you have the necessary permissions to deploy to Alibaba Cloud Function Compute.\n- Make sure that your function's dependencies are correctly installed and that your TypeScript code compiles without errors before attempting to deploy.\n\n### References\n\n- [Alibaba Cloud Function Compute Documentation](https://www.alibabacloud.com/help/product/50980.htm)\n- [Serverless Framework Documentation](https://www.serverless.com/framework/docs/)\n\n### Common Use Cases\n\n- Deploying serverless functions to Alibaba Cloud Function Compute\n- Automating deployment processes with npm scripts",
      "ruleTitle": "Deploying a Function to Alibaba Cloud Function Compute with npm Scripts",
      "sourcePath": "docs/getting-started/ali-function-compute.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a new Hono application and install its dependencies using different package managers. Understanding this rule is crucial for setting up a new Hono project correctly.",
      "ruleFile": "## Creating a new Hono application and installing dependencies\n\nThis code snippet demonstrates how to create a new Hono application and install its dependencies using different package managers.\n\n```sh\nyarn create hono my-app\n```\n\n```sh\npnpm create hono my-app\n```\n\n```sh\nbun create hono@latest my-app\n```\n\n```sh\ndeno init --npm hono my-app\n```\n\nAfter creating the application, you need to move to the application directory and install the dependencies.\n\n```sh\ncd my-app\nnpm i\n```\n\n```sh\ncd my-app\nyarn\n```\n\n```sh\ncd my-app\npnpm i\n```\n\n```sh\ncd my-app\nbun i\n```\n\n### How it works\n\nThe `create` command is used to create a new Hono application. The `cd` command is used to move to the application directory. The `i` or `install` command is used to install the dependencies of the application.\n\n### Important notes\n\n- Make sure to use the correct command for your package manager.\n- The `@latest` tag can be used to create an application with the latest version of Hono.\n\n### References\n\n- [Hono documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Setting up a new Hono project",
      "ruleTitle": "Creating a new Hono application and installing dependencies",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono framework. It shows the basic structure of a Hono application, including how to define routes and responses.",
      "ruleFile": "## Creating a Basic Hono Application\n\nThis code snippet demonstrates how to create a basic 'Hello World' application using the Hono framework.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Cloudflare Workers!'))\n\nexport default app\n```\n\n### How it works\n\n1. The Hono framework is imported.\n2. A new Hono application is created.\n3. A GET route is defined for the root URL ('/'). The response is a simple text message.\n4. The application is exported for use elsewhere.\n\n### Important notes\n\n- This is a very basic example of a Hono application. Real-world applications will typically have more complex routing and response logic.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Creating a simple serverless application with Hono and Cloudflare Workers.",
      "ruleTitle": "Creating a Basic Hono Application",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to run a Hono application locally using different package managers. It shows the command to start the development server and how to access the application in a web browser. Understanding this rule is crucial for testing and debugging during development.",
      "ruleFile": "## Running a Hono Application Locally\n\nThis code snippet demonstrates how to run a Hono application on your local machine using different package managers.\n\n```sh\nnpm run dev\n```\n\n```sh\nyarn dev\n```\n\n```sh\npnpm dev\n```\n\n```sh\nbun run dev\n```\n\nAfter running one of these commands, you can access the application by opening `http://localhost:8787` in your web browser.\n\n### How it works\n\nThese commands start the development server for your Hono application. The server listens on port 8787 and serves the application.\n\n### Important notes\n\n- Ensure that the specified port is not being used by another service.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Running the application for testing during development.",
      "ruleTitle": "Running a Hono Application Locally",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to change the port number and deploy the application using different package managers in the context of Cloudflare Workers. Understanding how to change the port number is crucial for avoiding port conflicts and ensuring the application runs smoothly. Moreover, knowing how to deploy the application using different package managers provides flexibility and allows developers to use the package manager they are most comfortable with.",
      "ruleFile": "## Rule: Changing Port Number and Deploying Application in Cloudflare Workers\n\nThis rule demonstrates how to change the port number and deploy the application using different package managers in the context of Cloudflare Workers.\n\n### Code Snippet\n\n```text\n:::\n\n### Change port number\n\nIf you need to change the port number you can follow the instructions here to update `wrangler.toml` / `wrangler.json` / `wrangler.jsonc` files:\n[Wrangler Configuration](https://developers.cloudflare.com/workers/wrangler/configuration/#local-development-settings)\n\nOr, you can follow the instructions here to set CLI options:\n[Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/commands/#dev)\n\n## 4. Deploy\n\nIf you have a Cloudflare account, you can deploy to Cloudflare. In `package.json`, `$npm_execpath` needs to be changed to your package manager of choice.\n\n::: code-group\n```\n\n### How it Works\n\n1. To change the port number, you can update the `wrangler.toml`, `wrangler.json`, or `wrangler.jsonc` files as per the instructions provided in the Wrangler Configuration link.\n2. Alternatively, you can set CLI options as per the instructions provided in the Wrangler CLI link.\n3. To deploy the application, you need to have a Cloudflare account. In the `package.json` file, you need to change `$npm_execpath` to your package manager of choice.\n\n### Important Notes\n\n- Ensure to use a unique port number to avoid port conflicts.\n- Choose the package manager you are most comfortable with for deploying the application.\n\n### References\n\n- [Wrangler Configuration](https://developers.cloudflare.com/workers/wrangler/configuration/#local-development-settings)\n- [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/commands/#dev)\n\n### Common Use Cases\n\n- Changing the port number when the default port is already in use.\n- Deploying the application using different package managers based on personal preference or project requirements.",
      "ruleTitle": "Changing Port Number and Deploying Application in Cloudflare Workers",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates the two syntaxes for writing Cloudflare Workers in Hono: Module Worker mode and Service Worker mode. It also highlights the recommendation to use Module Worker mode for localized binding variables, which can be crucial for maintaining clean and manageable code.",
      "ruleFile": "## Service Worker mode or Module Worker mode\n\nIn Hono, there are two syntaxes for writing the Cloudflare Workers: _Module Worker mode_ and _Service Worker mode_.\n\nHere is how you can write in both modes:\n\n```ts\n// Module Worker\nexport default app\n```\n\n```ts\n// Service Worker\napp.fire()\n```\n\nWhile both syntaxes are supported, it is recommended to use Module Worker mode. This is because in Module Worker mode, binding variables are localized, which can help in maintaining clean and manageable code.\n\n### Important Notes\n\n- While both modes are supported, Module Worker mode is recommended for better management of binding variables.\n\n### Common Use Cases\n\n- Use Module Worker mode when you want to keep your binding variables localized.\n\n- Use Service Worker mode when you want to fire the application immediately.",
      "ruleTitle": "Using Module Worker mode and Service Worker mode in Hono",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to integrate Hono with other event handlers in Module Worker mode. This is crucial for developers who want to extend the functionality of their Hono applications with additional event handlers.",
      "ruleFile": "## Using Hono with other event handlers in Module Worker mode\n\nIn Hono, you can integrate with other event handlers (such as `scheduled`) in Module Worker mode. To do this, you need to export `app.fetch` as the module's `fetch` handler, and then implement other handlers as needed.\n\nHere is a code snippet demonstrating this:\n\n```ts\nconst app = new Hono()\n\nexport default {\n  fetch: app.fetch,\n  scheduled: async (batch, env) => {},\n}\n```\n\n### How it works\n\nIn the above code, `app.fetch` is exported as the module's `fetch` handler. This allows Hono to handle fetch events. The `scheduled` handler is also defined, but it doesn't do anything in this example.\n\n### Important notes\n\n- The `scheduled` handler can be replaced with any other event handler as per your application's requirements.\n\n### References\n\n- [Hono Documentation](https://hono.bouzuya.net/)\n\n### Common use cases\n\n- Integrating Hono with a scheduling system to perform tasks at specific intervals.\n- Extending the functionality of a Hono application with additional event handlers.",
      "ruleTitle": "Integrating Hono with Other Event Handlers in Module Worker Mode",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files using the Static Assets feature of Cloudflare Workers in a Hono application. This is a common requirement in many web applications where static files like images, CSS, JavaScript files, etc., need to be served to the client.",
      "ruleFile": "## Serve Static Files in Hono using Cloudflare Workers\n\nThe following code snippet demonstrates how to serve static files using the Static Assets feature of Cloudflare Workers in a Hono application. This is done by specifying the directory for the files in `wrangler.toml`:\n\n```toml\nassets = { directory = \"public\" }\n```\n\nAfter this, you need to create the `public` directory and place the files there. For instance, `./public/static/hello.txt` will be served as `/static/hello.txt`.\n\n### How it Works\n\n1. The `assets` field in the `wrangler.toml` file is used to specify the directory that contains the static files.\n2. The `directory` field within the `assets` field is set to the directory that contains the static files. In this case, it is set to `public`.\n3. Any file placed within the `public` directory can be accessed as a static file. For example, a file at `./public/static/hello.txt` can be accessed at the URL `/static/hello.txt`.\n\n### Important Notes\n\n- The directory specified in the `directory` field must exist, otherwise, an error will occur.\n- The static files feature is a part of Cloudflare Workers and may not be available in other environments.\n\n### References\n\n- [Cloudflare Workers Static Assets Feature](https://developers.cloudflare.com/workers/static-assets/)\n\n### Common Use Cases\n\n- Serving images, CSS files, JavaScript files, etc., as static files.\n- Hosting a static website or a single-page application.",
      "ruleTitle": "Serving Static Files in Hono using Cloudflare Workers",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static assets using the Cloudflare Workers feature in Hono. It shows how to specify the directory for static files in the `wrangler.toml` file and how to structure the project directory for serving these files.",
      "ruleFile": "## Serving Static Assets with Cloudflare Workers in Hono\n\nIn Hono, you can serve static assets using the Cloudflare Workers feature. To do this, you need to specify the directory for the static files in the `wrangler.toml` file. For instance:\n\n```toml\nassets = { directory = \"public\" }\n```\n\nThen, you need to create the `public` directory and place your static files there. For example, if you place a file at `./public/static/hello.txt`, it will be served at the path `/static/hello.txt`.\n\nYour project directory should look something like this:\n\n```\n.\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ public\nâ”‚   â”œâ”€â”€ favicon.ico\nâ”‚   â””â”€â”€ static\nâ”‚       â””â”€â”€ hello.txt\nâ”œâ”€â”€ src\nâ”‚   â””â”€â”€ index.ts\nâ””â”€â”€ wrangler.toml\n```\n\n### Important Notes\n\n- Ensure that the directory specified in the `wrangler.toml` file exists and contains the static files you want to serve.\n\n### References\n\n- [Cloudflare Workers Static Assets](https://developers.cloudflare.com/workers/static-assets/)\n\n### Common Use Cases\n\n- Serving static files like images, CSS, and JavaScript for a web application.",
      "ruleTitle": "Serving Static Assets with Cloudflare Workers in Hono",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to install the '@cloudflare/workers-types' package, which provides type definitions for Cloudflare Workers. These type definitions are essential for TypeScript development, as they provide autocompletion and type checking capabilities, improving the developer experience and reducing the likelihood of runtime errors.",
      "ruleFile": "## Installing '@cloudflare/workers-types' for TypeScript Development\n\nThe code snippet demonstrates how to install the '@cloudflare/workers-types' package using different package managers. This package provides type definitions for Cloudflare Workers, which are essential for TypeScript development.\n\n```sh\nnpm i --save-dev @cloudflare/workers-types\n```\n\n```sh\nyarn add -D @cloudflare/workers-types\n```\n\n```sh\npnpm add -D @cloudflare/workers-types\n```\n\nThese commands add the '@cloudflare/workers-types' package as a development dependency, meaning it will not be included in the production build of your project.\n\n### Important Notes\n\n- Make sure to install the '@cloudflare/workers-types' package as a development dependency, as it is only needed during development and not in the production build.\n\n### References\n\n- [Cloudflare Workers TypeScript documentation](https://developers.cloudflare.com/workers/learning/typescript)\n\n### Common Use Cases\n\n- When setting up a new TypeScript project for Cloudflare Workers, you should install the '@cloudflare/workers-types' package to benefit from autocompletion and type checking capabilities.",
      "ruleTitle": "Installing '@cloudflare/workers-types' for TypeScript Development in Cloudflare Workers",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to add development dependencies in a Hono project using different package managers like yarn, pnpm, and bun. It also shows how to set up testing using the '@cloudflare/vitest-pool-workers' package and provides an example of a simple test case for a Hono application.",
      "ruleFile": "## Adding Development Dependencies and Setting Up Testing in Hono\n\nThis code snippet demonstrates how to add development dependencies in a Hono project using different package managers. It also shows how to set up testing using the '@cloudflare/vitest-pool-workers' package.\n\n```sh\n# Using yarn\nyarn add -D @cloudflare/workers-types\n\n# Using pnpm\npnpm add -D @cloudflare/workers-types\n\n# Using bun\nbun add --dev @cloudflare/workers-types\n```\n\nFor testing, we recommend using '@cloudflare/vitest-pool-workers'. You can refer to the [examples](https://github.com/honojs/examples) for setting it up.\n\nHere is an example of a simple test case for a Hono application:\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\napp.get('/', (c) => c.text('Please test me!'))\n```\n\nYou can test if it returns a '_200 OK_' Response with this code.\n\n### Important Notes\n\n- The '-D' flag in the commands is used to add the package as a development dependency.\n- The '@cloudflare/workers-types' package provides TypeScript definitions for Cloudflare Workers.\n- The '@cloudflare/vitest-pool-workers' package is recommended for testing Hono applications.\n\n### References\n\n- [Hono Documentation](https://honojs.com)\n- [Cloudflare Workers Types](https://www.npmjs.com/package/@cloudflare/workers-types)\n- [Vitest Pool Workers](https://www.npmjs.com/package/@cloudflare/vitest-pool-workers)\n\n### Common Use Cases\n\n- Setting up a new Hono project\n- Adding development dependencies to a Hono project\n- Setting up testing for a Hono application",
      "ruleTitle": "Adding Development Dependencies and Setting Up Testing in Hono",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to test a basic Hono application using Jest. It shows how to make a request to the application and check if it returns a 200 status code, which indicates a successful HTTP request. This is a fundamental part of developing and maintaining reliable web applications.",
      "ruleFile": "## Testing a Basic Hono Application\n\nThis code demonstrates how to test a basic Hono application using Jest. The application is set up to respond to GET requests at the root URL ('/') with a text response.\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\napp.get('/', (c) => c.text('Please test me!'))\n```\n\nWe can test if it returns a 200 OK response with this code:\n\n```ts\ndescribe('Test the application', () => {\n  it('Should return 200 response', async () => {\n    const res = await app.request('http://localhost/')\n    expect(res.status).toBe(200)\n  })\n})\n```\n\nThis works by making a request to the application and checking the status of the response. If the status is 200, the test passes.\n\n### Important Notes\n\n- The `app.request` method is a part of Hono's API that allows for making requests to the application.\n- Jest's `expect` function is used to assert that the response status is 200.\n\n### References\n\n- [Hono Documentation](https://honojs.com/docs)\n- [Jest Documentation](https://jestjs.io/docs)\n\n### Common Use Cases\n\n- Testing the response of different routes in your Hono application.\n- Checking the status code of HTTP responses.",
      "ruleTitle": "Testing a Basic Hono Application",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to bind environment values, KV namespace, R2 bucket, or Durable Object in Cloudflare Workers using Hono. It also shows how to access these bindings in `c.env` and how to pass the '_type struct_' for the bindings to the `Hono` as generics, which provides type safety.",
      "ruleFile": "## Bindings in Hono\n\nIn the Cloudflare Workers, we can bind the environment values, KV namespace, R2 bucket, or Durable Object. You can access them in `c.env`. It will have the types if you pass the '_type struct_' for the bindings to the `Hono` as generics.\n\n```ts\ntype Bindings = {\n  MY_BUCKET: R2Bucket\n  USERNAME: string\n  PASSWORD: string\n}\n\nconst app = new Hono<{ Bindings: Bindings }>()\n```\n\n### How it works\n\n1. Define a type for the bindings.\n2. Pass this type as a generic parameter when creating a new Hono instance.\n3. Access the bindings in `c.env`.\n\n### Important notes\n\n- The bindings are available in `c.env`.\n- The bindings have types if you pass the '_type struct_' for the bindings to the `Hono` as generics.\n\n### References\n\n- [Hono documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common use cases\n\n- Binding environment values in Cloudflare Workers\n- Accessing KV namespace, R2 bucket, or Durable Object in Cloudflare Workers",
      "ruleTitle": "Binding and Accessing Environment Values in Hono",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use environment variables in Hono middleware. This is particularly useful when you need to use sensitive data like usernames or passwords in your middleware, which should not be hard-coded for security reasons.",
      "ruleFile": "## Using Environment Variables in Hono Middleware\n\nIn Hono, if you need to use environment variables or secret variables in middleware, such as 'username' or 'password' in Basic Authentication Middleware, you can do so as shown in the following code snippet.\n\n```ts\nimport { basicAuth } from 'hono/basic-auth'\n\ntype Bindings = {\n  USERNAME: string\n  PASSWORD: string\n}\n\nconst app = new Hono<{ Bindings: Bindings }>()\n\n//...\n\napp.use('/auth/*', async (c, next) =>\n```\n\nThis is particularly useful when you need to use sensitive data like usernames or passwords in your middleware, which should not be hard-coded for security reasons. Instead, these values can be stored in environment variables and accessed as shown.\n\n### Important Notes\n\n- This is the only case for Module Worker mode.\n- Always ensure to keep your environment variables secure and do not expose them in your code or version control systems.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases\n\n- Using environment variables for sensitive data in middleware\n- Implementing Basic Authentication using environment variables",
      "ruleTitle": "Using Environment Variables in Hono Middleware",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up authentication middleware in Hono and how to deploy a Hono project to Cloudflare using GitHub Actions. Understanding this rule is crucial for securing your Hono applications and for automating the deployment process.",
      "ruleFile": "## Setting up Authentication Middleware and Deploying Hono Project to Cloudflare using GitHub Actions\n\nThis code snippet demonstrates how to set up basic authentication middleware in a Hono application. The same process can be applied to other types of authentication middleware such as Bearer Authentication Middleware, JWT Authentication, etc.\n\n```text\napp.use('/auth/*', async (c, next) => {\n  const auth = basicAuth({\n    username: c.env.USERNAME,\n    password: c.env.PASSWORD,\n  })\n  return auth(c, next)\n})\n```\n\nThe snippet also shows how to deploy a Hono project to Cloudflare using GitHub Actions. Before deploying, you need a Cloudflare token which can be managed from User API Tokens. If it's a newly created token, select the Edit Cloudflare Workers template. If you already have another token, make sure the token has the corresponding permissions.\n\nAdd a new secret with the name CLOUDFLARE_API_TOKEN in your GitHub repository settings dashboard. Then create .github/workflows/deploy.yml in your Hono project root folder and paste the deployment code.\n\n### How it works\n\nThe authentication middleware intercepts requests to '/auth/*' paths and checks if the provided username and password match the ones in the environment variables. If they match, the request is allowed to proceed, otherwise, it's rejected.\n\nThe deployment process is triggered whenever you push to the main branch of your repository. GitHub Actions checks out your code and deploys it to Cloudflare using the provided API token.\n\n### Important notes\n\n- Make sure to keep your Cloudflare API token secret to prevent unauthorized access to your Cloudflare account.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n- [Cloudflare Workers Documentation](https://developers.cloudflare.com/workers/)\n- [GitHub Actions Documentation](https://docs.github.com/en/actions)\n\n### Common use cases\n\n- Securing routes in your Hono application\n- Automating the deployment of your Hono application to Cloudflare",
      "ruleTitle": "Setting up Authentication Middleware and Deploying Hono Project to Cloudflare using GitHub Actions",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure the 'wrangler.toml' file for a Cloudflare Workers deployment. It shows how to specify the main entry point for the application and enable minification for the deployed code.",
      "ruleFile": "## Configuring the 'wrangler.toml' file for Cloudflare Workers deployment\n\nThis code snippet demonstrates how to configure the 'wrangler.toml' file when deploying a Cloudflare Workers application.\n\n```toml\nmain = \"src/index.ts\"\nminify = true\n```\n\nAfter the `compatibility_date` line in the 'wrangler.toml' file, add the above lines. The `main` line specifies the main entry point for the application, which in this case is 'src/index.ts'. The `minify` line enables minification for the deployed code, which can help reduce the size of the deployed code and improve performance.\n\n### Important notes\n\n- The 'wrangler.toml' file is a configuration file used by the Wrangler CLI, which is a tool for deploying Cloudflare Workers applications.\n- The `main` and `minify` options should be configured according to the specific needs of your application.\n\n### References\n\n- [Wrangler CLI Documentation](https://developers.cloudflare.com/workers/cli-wrangler/configuration)\n\n### Common use cases\n\n- Configuring the 'wrangler.toml' file for a Cloudflare Workers deployment",
      "ruleTitle": "Configuring the 'wrangler.toml' file for Cloudflare Workers deployment",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure environment variables for local development in a Cloudflare worker project. Environment variables are crucial for managing configurations that vary between deployment environments (like development, staging, production). They help to keep sensitive data like API keys, database passwords, etc., out of the codebase.",
      "ruleFile": "## Configuring Environment Variables for Local Development in Cloudflare Worker Project\n\nThis code snippet demonstrates how to configure environment variables for local development in a Cloudflare worker project.\n\n```text\n## Load env when local development\n\nTo configure the environment variables for local development, create the `.dev.vars` file in the root directory of the project.\nThen configure your environment variables as you would with a normal env file.\n```\n\n### How it works\n\n1. Create a `.dev.vars` file in the root directory of your project.\n2. Add your environment variables to this file in the format `KEY=value`.\n\n### Important notes\n\n- Keep this file out of version control to prevent sensitive data from being exposed. Add `.dev.vars` to your `.gitignore` file.\n\n### References\n\n- [Cloudflare Workers Documentation](https://developers.cloudflare.com/workers/wrangler/c)\n\n### Common use cases\n\n- Storing API keys, database passwords, and other sensitive data.\n- Managing configurations that vary between deployment environments.",
      "ruleTitle": "Configuring Environment Variables for Local Development in Cloudflare Worker Project",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to correctly access environment variables in a Hono application when using Cloudflare Workers. It's crucial to understand that in this context, environment variables must be accessed via `c.env.*` and not `process.env` as is common in other Node.js environments. This is due to the specific way Cloudflare Workers handle environment variables.",
      "ruleFile": "## Accessing Environment Variables in Hono with Cloudflare Workers\n\nWhen working with Hono and Cloudflare Workers, environment variables are accessed differently than in other Node.js environments. Instead of using `process.env`, you should use `c.env.*`.\n\nHere's a code snippet demonstrating this:\n\n```ts\nThen we use the `c.env.*` to get the environment variables in our code.\n\nFor Cloudflare Workers, environment variables must be obtained via `c`, not via `process.env`.\n```\n\nThis is due to the way Cloudflare Workers handle environment variables. For more information, refer to the [Cloudflare documentation](https://developers.cloudflare.com/workers/wrangler/configuration/#secrets).\n\nCommon use cases include accessing API keys, database credentials, or other sensitive information stored in environment variables.",
      "ruleTitle": "Accessing Environment Variables in Hono with Cloudflare Workers",
      "sourcePath": "docs/getting-started/cloudflare-workers.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a new Hono application and install its dependencies using different package managers. Understanding this is crucial for setting up a new Hono project correctly.",
      "ruleFile": "## Creating a new Hono application and installing dependencies\n\nThis code snippet demonstrates how to create a new Hono application and install its dependencies using different package managers. \n\n```sh\n[yarn]\nyarn create hono my-app\n```\n\n```sh\n[pnpm]\npnpm create hono my-app\n```\n\n```sh\n[bun]\nbun create hono@latest my-app\n```\n\n```sh\n[deno]\ndeno init --npm hono my-app\n```\n\nAfter creating the application, you need to move into the application directory and install the dependencies.\n\n```sh\n[npm]\ncd my-app\nnpm i\n```\n\n```sh\n[yarn]\ncd my-app\nyarn\n```\n\n```sh\n[pnpm]\ncd my-app\npnpm i\n```\n\n```sh\n[bun]\ncd my-app\nbun i\n```\n\n### How it works\n\nThe `create` command is used to create a new application. The `cd` command is used to move into the application directory. The `i` or `install` command is used to install the dependencies of the application.\n\n### Important notes\n\n- Different package managers have different syntax for the same operations.\n- Always ensure to install the dependencies after creating a new application.\n\n### References\n\n- [Hono documentation](https://hono.com/docs)\n\n### Common use cases\n\n- Setting up a new Hono application",
      "ruleTitle": "Creating a new Hono application and installing dependencies",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to navigate into a project directory and install dependencies using different package managers. It also shows the basic directory structure for a Hono project, which is crucial for understanding how to organize files and directories in such a project.",
      "ruleFile": "## Rule File\n\nThis code snippet demonstrates how to navigate into a project directory and install dependencies using different package managers. It also provides a basic directory structure for a Hono project.\n\n```sh\n[npm]\ncd my-app\nnpm i\n```\n\n```sh\n[yarn]\ncd my-app\nyarn\n```\n\n```sh\n[pnpm]\ncd my-app\npnpm i\n```\n\n```sh\n[bun]\ncd my-app\nbun i\n```\n\nBelow is a basic directory structure.\n\n```text\n./\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ public\nâ”‚   â””â”€â”€ static // Put your static files.\nâ”‚       â””â”€â”€ style.css // You can refer to it as `/static/style.css`.\nâ”œâ”€â”€ src\nâ”‚   â”œâ”€â”€ index.tsx // The entry point for serve\n```\n\n### How it works\n\nThe `cd` command is used to navigate into the project directory. The `i` command is used to install the dependencies listed in the `package.json` file. The directory structure shows where to place static files and the entry point for the server.\n\n### Important notes\n\nDifferent package managers (npm, yarn, pnpm, bun) can be used to install dependencies, but the exact command may vary.\n\n### References\n\n- [Hono documentation](https://hono.bun.dev/)\n\n### Common use cases\n\nThis is a common setup step when starting a new Hono project or when pulling an existing project from a repository.",
      "ruleTitle": "Navigating into a Project Directory and Installing Dependencies in Hono",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic Hono application and define routes. It shows the standard way of importing the Hono module, creating a new Hono application, and defining a wildcard route and a root route. This is a fundamental pattern in Hono application development.",
      "ruleFile": "## Hono Basic Application Setup and Route Definition\n\nThis code snippet demonstrates how to set up a basic Hono application and define routes.\n\n```tsx\nimport { Hono } from 'hono'\nimport { renderer } from './renderer'\n\nconst app = new Hono()\n\napp.get('*', renderer)\n\napp.get('/', (c) => {\n  return c.render(<h1>Hello, Cloudflare Pages!</h1>)\n})\n```\n\n### How it works\n\n1. The Hono module is imported.\n2. A new Hono application is created.\n3. A wildcard route (`*`) is defined, which matches any path. The `renderer` function is used as the handler for this route.\n4. A root route (`/`) is defined, which returns a rendered HTML string.\n\n### Important notes\n\n- The order of route definitions matters. Hono checks routes in the order they are defined.\n\n### References\n\n- [Hono documentation](https://hono.boutique/docs)\n\n### Common use cases\n\n- Setting up a new Hono application\n- Defining routes in a Hono application",
      "ruleTitle": "Setting Up a Basic Hono Application and Defining Routes",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes and render responses in a Hono application. It also shows how to run the application locally and access it via a web browser.",
      "ruleFile": "## Defining Routes and Rendering Responses in Hono\n\nThis code snippet demonstrates how to define routes and render responses in a Hono application. It also shows how to run the application locally and access it via a web browser.\n\n```javascript\n} from 'hono'\nimport { renderer } from './renderer'\n\nconst app = new Hono()\n\napp.get('*', renderer)\n\napp.get('/', (c) => {\n  return c.render(<h1>Hello, Cloudflare Pages!</h1>)\n})\n\nexport default app\n```\n\n### How it works\n\n1. The `Hono` class is instantiated to create a new Hono application.\n2. The `get` method is used to define routes. The first argument is the path, and the second argument is the handler function.\n3. The `renderer` function is used to render responses.\n4. The application is exported for use in other modules.\n\n### Important notes\n\n- The `*` path in the `get` method matches all routes.\n- The `renderer` function should be defined in the same module or imported from another module.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Defining routes and rendering responses in a Hono application.\n- Running a Hono application locally.",
      "ruleTitle": "Defining Routes and Rendering Responses in Hono",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy a Hono application to Cloudflare using different package managers. It shows the necessary commands to run in the terminal for different package managers (npm, yarn, pnpm, bun) to deploy the application. This is crucial for developers to understand as it allows them to deploy their applications to the cloud, making it accessible to users.",
      "ruleFile": "## Deploying a Hono Application to Cloudflare\n\nThis code snippet demonstrates how to deploy a Hono application to Cloudflare using different package managers.\n\n```sh\n::: code-group\n\n```sh [npm]\nnpm run deploy\n```\n\n```sh [yarn]\nyarn deploy\n```\n\n```sh [pnpm]\npnpm run deploy\n```\n\n```sh [bun]\nbun run deploy\n```\n\n:::\n```\n\n### How it works\n\n1. The `run deploy` command is used to deploy the application. The command that is used depends on the package manager that you are using.\n2. In `package.json`, `$npm_execpath` needs to be changed to your package manager of choice.\n\n### Important notes\n\n- Make sure that you have a Cloudflare account before attempting to deploy.\n- The package manager used must be installed in your system.\n\n### References\n\n- [Hono Documentation](https://hono.bouffier.dev/docs)\n- [Cloudflare Documentation](https://developers.cloudflare.com/pages/)\n\n### Common use cases\n\n- Deploying a Hono application to the cloud for user accessibility.",
      "ruleTitle": "Deploying a Hono Application to Cloudflare",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy a Hono application via the Cloudflare dashboard with GitHub and how to create local bindings using the `wrangler.toml` file. Understanding this process is crucial for deploying and managing Hono applications in a production environment.",
      "ruleFile": "## Deploying Hono Application via Cloudflare Dashboard with GitHub and Creating Local Bindings\n\nThis code snippet demonstrates how to deploy a Hono application via the Cloudflare dashboard with GitHub and how to create local bindings using the `wrangler.toml` file.\n\n```text\n### Deploy via the Cloudflare dashboard with GitHub\n\n1. Log in to the [Cloudflare dashboard](https://dash.cloudflare.com) and select your account.\n2. In Account Home, select Workers & Pages > Create application > Pages > Connect to Git.\n3. Authorize your GitHub account, and select the repository. In Set up builds and deployments, provide the following information:\n\n| Configuration option | Value           |\n| -------------------- | --------------- |\n| Production branch    | `main`          |\n| Build command        | `npm run build` |\n| Build directory      | `dist`          |\n\n## Bindings\n\nYou can use Cloudflare Bindings like Variables, KV, D1, and others.\nIn this section, let's use Variables and KV.\n\n### Create `wrangler.toml`\n\nFirst, create `wrangler.toml` for local Bindings:\n```\n\n### How it works\n\n1. The Cloudflare dashboard is used to connect to a GitHub repository and set up the build and deployment settings.\n2. The `wrangler.toml` file is created for local bindings. This file is used to specify variables that can be used in the Hono application.\n\n### Important notes\n\n- Make sure to replace the `main` branch, `npm run build` command, and `dist` directory with the actual values for your Hono application.\n- The `wrangler.toml` file should be located in the root directory of your Hono application.\n\n### References\n\n- [Cloudflare Workers Documentation](https://developers.cloudflare.com/workers/)\n\n### Common use cases\n\n- Deploying a Hono application to production\n- Setting up local bindings for a Hono application",
      "ruleTitle": "Deploying Hono Application via Cloudflare Dashboard with GitHub and Creating Local Bindings",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create and specify a variable in the `wrangler.toml` file in the Hono framework. Understanding how to define variables is crucial for managing and configuring the application's environment.",
      "ruleFile": "## Creating and Specifying a Variable in `wrangler.toml` File\n\nThis code snippet demonstrates how to create and specify a variable in the `wrangler.toml` file in the Hono framework.\n\n```toml\n[vars]\nMY_NAME = \"Hono\"\n```\n\n### How it Works\n\n1. The `[vars]` section in the `wrangler.toml` file is used to define environment variables.\n2. The variable `MY_NAME` is defined and assigned the value `Hono`.\n\n### Important Notes\n\n- Variables defined in the `wrangler.toml` file can be accessed in the application code.\n- The `wrangler.toml` file is a configuration file for the Wrangler CLI, which is used to manage and deploy Workers projects.\n\n### References\n\n- [Wrangler Configuration](https://developers.cloudflare.com/workers/cli-wrangler/configuration)\n\n### Common Use Cases\n\n- Defining environment-specific variables such as API keys, database connection strings, etc.\n- Managing different configurations for different environments (development, staging, production).",
      "ruleTitle": "Creating and Specifying a Variable in `wrangler.toml` File",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a Key-Value (KV) namespace using the `wrangler` command in Cloudflare Workers. KV namespaces are a feature of Cloudflare Workers that allow you to store data in a distributed, eventually-consistent key-value store. This is a fundamental step in setting up a Cloudflare Worker project.",
      "ruleFile": "## Creating a Key-Value Namespace in Cloudflare Workers using `wrangler` command\n\nThis code snippet demonstrates how to create a Key-Value (KV) namespace using the `wrangler` command in Cloudflare Workers.\n\n```sh\nwrangler kv namespace create MY_KV --preview\n```\n\n### How it works\n\nThe `wrangler kv namespace create` command creates a new namespace under your account. The `--preview` flag is used to create the namespace in preview mode.\n\n### Important notes\n\nAfter running the command, you should note down the `preview_id` from the output. This `preview_id` will be used to bind the namespace to your worker.\n\n### References\n\n- [Cloudflare Workers KV](https://developers.cloudflare.com/workers/runtime-apis/kv)\n\n### Common use cases\n\nThis command is commonly used when setting up a new Cloudflare Worker project and you need to store data in a distributed, eventually-consistent key-value store.",
      "ruleTitle": "Creating a Key-Value Namespace in Cloudflare Workers",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important because it demonstrates how to create a Key-Value (KV) namespace in Cloudflare using the `wrangler` command, and how to bind it to a specific identifier. This is crucial in Hono as it allows for the storage and retrieval of data in a distributed, low-latency manner, which is essential for high-performance web applications.",
      "ruleFile": "## Creating and Binding a KV Namespace in Cloudflare\n\nThis code snippet demonstrates how to create a Key-Value (KV) namespace in Cloudflare and bind it to a specific identifier using the `wrangler` command.\n\n```sh\nwrangler kv namespace create MY_KV --preview\n```\n\nAfter running the command, note down the `preview_id` from the output.\n\n```\n{ binding = \"MY_KV\", preview_id = \"abcdef\" }\n```\n\nThen, specify the `preview_id` with the name of Bindings, `MY_KV`:\n\n```toml\n[[kv_namespaces]]\nbinding = \"MY_KV\"\nid = \"abcdef\"\n```\n\n### How it Works\n\nThe `wrangler` command creates a new KV namespace. The `--preview` flag is used to get a `preview_id` which is then used to bind the namespace to a specific identifier.\n\n### Important Notes\n\n- The `preview_id` is unique to each KV namespace and is used to identify it.\n- The `binding` is the identifier to which the KV namespace is bound.\n\n### References\n\n- [Cloudflare KV Namespace Documentation](https://developers.cloudflare.com/workers/runtime-apis/kv)\n\n### Common Use Cases\n\n- Storing and retrieving data in a distributed, low-latency manner for high-performance web applications.",
      "ruleTitle": "Creating and Binding a KV Namespace in Cloudflare",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a namespace in Cloudflare Workers KV and bind it to a specific ID. This is a crucial step in setting up a Cloudflare Workers environment, as it allows the application to store and retrieve data in a distributed, eventually consistent key-value store. The rule also shows how to configure the binding in the application's configuration file.",
      "ruleFile": "## Creating and Binding a Namespace in Cloudflare Workers KV\n\nIn Cloudflare Workers, you can create a namespace in Workers KV by running the following `wrangler` command:\n\n```sh\nwrangler kv namespace create MY_KV --preview\n```\n\nThis command will output a `preview_id` that you need to note down:\n\n```\n{ binding = \"MY_KV\", preview_id = \"abcdef\" }\n```\n\nYou then need to specify this `preview_id` with the name of the binding, `MY_KV`, in your application's configuration file:\n\n```toml\n[[kv_namespaces]]\nbinding = \"MY_KV\"\nid = \"abcdef\"\n```\n\n### How it Works\n\nThe `wrangler kv namespace create` command creates a new namespace in Workers KV. The `--preview` flag ensures that the namespace is only created in the preview environment, not in the production environment.\n\nThe `preview_id` is a unique identifier for the namespace. You need to specify this ID along with the binding name in your application's configuration file to bind the namespace to your application.\n\n### Important Notes\n\n- Make sure to replace `MY_KV` and `abcdef` with your actual binding name and preview ID.\n- The binding name must be unique across your application.\n\n### References\n\n- [Cloudflare Workers KV Documentation](https://developers.cloudflare.com/workers/runtime-apis/kv)\n\n### Common Use Cases\n\n- Storing and retrieving data in a distributed, eventually consistent key-value store in a Cloudflare Workers application.",
      "ruleTitle": "Creating and Binding a Namespace in Cloudflare Workers KV",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to edit the `vite.config.ts` file in a Hono project. This file is crucial for configuring the Vite development server and build process, which are essential for the proper functioning of a Hono application.",
      "ruleFile": "## Editing the `vite.config.ts` File in Hono\n\nIn a Hono project, the `vite.config.ts` file is used to configure the Vite development server and build process. This file is crucial for the proper functioning of a Hono application.\n\nHere is a code snippet demonstrating how to edit this file:\n\n```ts\n### Edit `vite.config.ts`\n\nEdit the `vite.config.ts`:\n```\n\nTo edit this file, you need to import the necessary modules from Hono, such as the development server and the Cloudflare adapter. Then, you can define your configuration using the `defineConfig` function from Vite.\n\nIt's important to note that the specific configuration will depend on the needs of your project. Always refer to the Hono and Vite documentation for more details on how to configure your application.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs)\n- [Vite Documentation](https://vitejs.dev/config/)\n\n### Common Use Cases\n\n- Configuring the development server for a Hono application\n- Setting up the build process for a Hono application",
      "ruleTitle": "Editing the `vite.config.ts` File in Hono",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use bindings in a Hono application. Bindings allow you to use variables and key-value (KV) pairs in your application. By setting the types for these bindings, you ensure type safety and improve code readability and maintainability.",
      "ruleFile": "## Using Bindings in Hono Applications\n\nIn Hono, you can use bindings to utilize variables and key-value (KV) pairs in your application. It is important to set the types for these bindings to ensure type safety and improve code readability and maintainability.\n\nHere is a code snippet demonstrating this:\n\n```ts\ntype Bindings = {\n  MY_NAME: string\n  MY_KV: KVNamespace\n}\n\nconst app = new Hono<{ Bindings: Bindings }>()\n```\n\nIn this snippet, a `Bindings` type is defined with `MY_NAME` as a string and `MY_KV` as a `KVNamespace`. Then, a new Hono application is created with these bindings.\n\n### How it Works\n\nWhen you define a type for your bindings, you specify the types of the variables and KV pairs you will use in your application. This helps TypeScript to understand the types of these bindings and can prevent type-related errors.\n\n### Important Notes\n\n- Always define types for your bindings to ensure type safety.\n\n### References\n\n- [Hono Documentation](https://hono.boutique/docs)\n\n### Common Use Cases\n\n- Using bindings to store and retrieve application-specific data.\n- Using bindings to manage environment-specific variables.",
      "ruleTitle": "Using Bindings in Hono Applications",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle different environments in Hono, specifically for Cloudflare Pages and client-side scripts. It shows how to use different configuration files for local development and production, and how to use environment variables to detect the running environment.",
      "ruleFile": "## Rule File\n\nThis rule demonstrates how to handle different environments in Hono, specifically for Cloudflare Pages and client-side scripts.\n\n### Code Snippet\n\n```text\n### In production\n\nFor Cloudflare Pages, you will use `wrangler.toml` for local development, but for production, you will set up Bindings in the dashboard.\n\n## Client-side\n\nYou can write client-side scripts and import them into your application using Vite's features.\nIf `/src/client.ts` is the entry point for the client, simply write it in the script tag.\nAdditionally, `import.meta.env.PROD` is useful for detecting whether it's running on a dev server or in the build phase.\n```\n\n### How it Works\n\nFor Cloudflare Pages, `wrangler.toml` is used for local development. For production, Bindings are set up in the dashboard. On the client-side, scripts can be written and imported into the application using Vite's features. The entry point for the client is `/src/client.ts`, which can be written in the script tag. The environment variable `import.meta.env.PROD` can be used to detect whether the application is running on a dev server or in the build phase.\n\n### Important Notes\n\nIt's crucial to correctly set up the environment configurations to ensure the application runs correctly in different environments.\n\n### References\n\n- [Hono Documentation](https://hono.boutique/docs)\n\n### Common Use Cases\n\n- Setting up different configurations for local development and production\n- Detecting the running environment to adjust application behavior",
      "ruleTitle": "Handling Different Environments in Hono",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to properly configure a Hono application using the `vite.config.ts` file. This is crucial for setting up the development environment and ensuring that the application runs correctly.",
      "ruleFile": "## Configuring Hono Application with vite.config.ts\n\nThe `vite.config.ts` file is used to configure your Hono application. This file is important for setting up your development environment and ensuring that your application runs correctly.\n\nHere is an example of how to use the `vite.config.ts` file:\n\n```ts\nimport pages from '@hono/vite-cloudflare-pages'\nimport devServer from '@hono/vite-dev-server'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig(({ mode }) => {\n  if (mode === 'client\n```\n\nIn this example, we are importing the necessary modules and defining the configuration for our application. The `defineConfig` function is used to define the configuration for our application.\n\n### Important Notes\n\n- The `vite.config.ts` file is crucial for setting up your development environment and ensuring that your application runs correctly.\n- Make sure to import the necessary modules and define the configuration correctly.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs)\n\n### Common Use Cases\n\n- Setting up the development environment for a Hono application.",
      "ruleTitle": "Configuring Hono Application with vite.config.ts",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to build the server and client script using the Vite build command. This is a crucial step in the development process as it compiles the source code into a format that can be executed by the browser or server.",
      "ruleFile": "## Building Server and Client Script with Vite\n\nThis code snippet demonstrates how to use the Vite build command to compile the server and client script.\n\n```sh\nvite build --mode client && vite build\n```\n\n### How it works\n\nThe `vite build --mode client` command builds the client script, while the `vite build` command builds the server script. The `&&` operator is used to run these commands sequentially.\n\n### Important notes\n\n- Ensure that Vite is installed and properly configured in your project before running these commands.\n\n### References\n\n- [Vite Documentation](https://vitejs.dev/guide/build.html)\n\n### Common use cases\n\n- Use this command when you want to compile your source code for production deployment.",
      "ruleTitle": "Building Server and Client Script with Vite",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to integrate Cloudflare Pages middleware with Hono. It shows how to create and export an `onRequest` function in a `_middleware.ts` file, which is a key step in enabling Cloudflare Pages middleware in a Hono application.",
      "ruleFile": "## Cloudflare Pages Middleware Integration with Hono\n\nCloudflare Pages uses its own middleware system that is different from Hono's middleware. This can be enabled in a Hono application by exporting an `onRequest` function in a `_middleware.ts` file.\n\nHere is a code snippet demonstrating this:\n\n```ts\n// functions/_middleware.ts\nexport async function onRequest(pagesContext) {\n  console.log(`You are accessing ${pagesContext.request.url}`)\n  return await pagesContext.next()\n}\n```\n\n### How it Works\n\nThe `onRequest` function is exported from the `_middleware.ts` file. This function logs the URL being accessed and then calls the `next` function on the `pagesContext` object, allowing the request to proceed to the next middleware in the stack.\n\n### Important Notes\n\n- The `_middleware.ts` file should be located in the `functions` directory of your Hono application.\n\n### References\n\n- [Cloudflare Pages Middleware Documentation](https://developers.cloudflare.com/pages/functions/middleware/)\n\n### Common Use Cases\n\n- Logging requests in a Hono application hosted on Cloudflare Pages.\n- Implementing custom middleware functionality in a Hono application hosted on Cloudflare Pages.",
      "ruleTitle": "Integrating Cloudflare Pages Middleware with Hono",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use Hono's middleware as Cloudflare Pages middleware. It shows how to import and use the `handleMiddleware` function from the 'hono/cloudflare-pages' module to handle HTTP requests in a Cloudflare Pages environment.",
      "ruleFile": "# Using Hono's Middleware in Cloudflare Pages\n\nThis guide demonstrates how to use Hono's middleware as Cloudflare Pages middleware.\n\n## Code Snippet\n\n```ts\n// functions/_middleware.ts\nimport { handleMiddleware } from 'hono/cloudflare-pages'\n\nexport const onRequest = handleMiddleware(async (c, next) => {\n  console.log(`You are accessing ${c.req.url}`)\n```\n\n## How it Works\n\nThe `handleMiddleware` function from the 'hono/cloudflare-pages' module is imported and used to handle HTTP requests. The function logs the URL of the request.\n\n## Important Notes\n\n- The `handleMiddleware` function is specific to the Hono framework and is used to handle HTTP requests in a Cloudflare Pages environment.\n\n## References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)\n\n## Common Use Cases\n\n- Logging HTTP request URLs in a Cloudflare Pages environment using Hono's middleware.",
      "ruleTitle": "Using Hono's Middleware in Cloudflare Pages",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use built-in and third-party middleware in Hono. Middleware is a crucial part of web development as it allows developers to add functionality to their applications in a modular and reusable way. In this case, the code shows how to add Basic Authentication to a Hono application using Hono's Basic Authentication Middleware.",
      "ruleFile": "## Using Middleware in Hono\n\nThis code snippet demonstrates how to use built-in and third-party middleware in Hono. Middleware is a crucial part of web development as it allows developers to add functionality to their applications in a modular and reusable way.\n\n```ts\nimport { handleMiddleware } from 'hono/cloudflare-pages'\nimport { basicAuth } from 'hono/basic-auth'\n\nexport const onRequest = handleMiddleware(\n  basicAuth({\n    username: 'user',\n    password: 'pass'\n  })\n)\n```\n\nIn this example, we're adding Basic Authentication to our Hono application using Hono's Basic Authentication Middleware. This middleware will require a valid username and password to be provided with each request.\n\n### How it works\n\n1. We import the `handleMiddleware` function from `hono/cloudflare-pages`.\n2. We import the `basicAuth` middleware from `hono/basic-auth`.\n3. We use the `handleMiddleware` function to apply the `basicAuth` middleware to our `onRequest` function.\n\n### Important notes\n\n- Middleware functions are applied in the order they are defined.\n- Middleware can modify the request and response objects.\n\n### References\n\n- [Hono's Basic Authentication Middleware](/docs/middleware/builtin/basic-auth)\n\n### Common use cases\n\n- Adding authentication to your application.\n- Logging requests.\n- Handling errors.",
      "ruleTitle": "Using Middleware in Hono",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to access the EventContext object in Hono framework using Cloudflare Pages. The EventContext object is a crucial part of Cloudflare Pages as it provides information about the event that triggered the function. Understanding how to access this object is key to effectively using the Hono framework with Cloudflare Pages.",
      "ruleFile": "## Accessing EventContext in Hono Framework\n\nIn Hono framework, you can access the `EventContext` object via `c.env` in `handleMiddleware`. This object provides information about the event that triggered the function.\n\nHere is a code snippet demonstrating this:\n\n```ts\n// functions/_middleware.ts\nimport { handleMiddleware } from 'hono/cloudflare-pages'\n\nexport const onRequest = [\n  handleMiddleware(async (c, next) => {\n    c.env.eventContext.data.user = 'Joe'\n  })\n]\n```\n\nIn this example, `c.env.eventContext.data.user` is being set to 'Joe'. This could be useful in scenarios where you need to modify or access event data.\n\n### Important Notes\n\n- The `EventContext` object is read-only and its properties cannot be modified.\n\n### References\n\n- [Cloudflare Pages API Reference](https://developers.cloudflare.com/pages/functions/api-reference/#eventcontext)\n\n### Common Use Cases\n\n- Modifying or accessing event data\n- Implementing custom logic based on event data",
      "ruleTitle": "Accessing EventContext in Hono Framework",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use middleware in Hono to set and access data in the event context. This is a common pattern in Hono and other web frameworks, allowing developers to share data across different parts of the application.",
      "ruleFile": "## Using Middleware to Set and Access Event Context Data in Hono\n\nThis code demonstrates how to use middleware in Hono to set and access data in the event context. This is a common pattern in Hono and other web frameworks, allowing developers to share data across different parts of the application.\n\n```ts\nimport { handleMiddleware } from 'hono/cloudflare-pages'\n\nexport const onRequest = [\n  handleMiddleware(async (c, next) => {\n    c.env.eventContext.data.user = 'Joe'\n    await next()\n  }),\n]\n```\n\nThen, you can access the data value in via `c.env.eventContext` in the handler:\n\n```ts\n// functions/api/[[route]].ts\nimport type { EventContext } from 'hono/cloudflare-pages'\nimport { handle } from 'hono/cloudflare-pages'\n\n// ...\n\ntype Env = {\n  Bindings: {\n    eventContext: EventContext\n  }\n}\n```\n\n### How it Works\n\nThe `handleMiddleware` function is used to create a middleware function that sets a user value in the event context. This middleware function is then added to the `onRequest` array, which is a list of middleware functions that are run when a request is received.\n\nIn the handler, the `EventContext` type is imported from 'hono/cloudflare-pages' and used to type the `eventContext` property of the `Env` type. The user value set in the middleware can then be accessed via `c.env.eventContext`.\n\n### Important Notes\n\n- Middleware functions in Hono are asynchronous and must call the `next` function to pass control to the next middleware function in the stack.\n\n### References\n\n- [Hono Documentation](https://hono.boutique/docs)\n\n### Common Use Cases\n\n- Sharing data across different parts of the application\n- Setting up context-specific data for handlers",
      "ruleTitle": "Setting and Accessing Event Context Data Using Middleware in Hono",
      "sourcePath": "docs/getting-started/cloudflare-pages.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to install Azure Functions Core Tools on macOS using Homebrew. Azure Functions Core Tools is a command line tool that allows you to create, test, run, and manage Azure Functions on your local development machine. It is a crucial step in setting up the development environment for working with Azure Functions.",
      "ruleFile": "## Installing Azure Functions Core Tools on macOS\n\nThis code snippet demonstrates how to install Azure Functions Core Tools on macOS using Homebrew.\n\n```sh\nbrew tap azure/functions\nbrew install azure-functions-core-tools@4\n```\n\n### How it works\n\n1. `brew tap azure/functions`: This command adds the Azure Functions repository to the list of formulae that brew tracks, updates, and installs from.\n\n2. `brew install azure-functions-core-tools@4`: This command installs the Azure Functions Core Tools version 4.\n\n### Important notes\n\n- Ensure that Homebrew is installed on your macOS before running these commands.\n\n### References\n\n- [Azure Functions Core Tools](https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-typescript?pivots=nodejs-model-v4#install-the-azure-functions-core-tools)\n\n### Common use cases\n\n- Setting up the development environment for working with Azure Functions.",
      "ruleTitle": "Installing Azure Functions Core Tools on macOS",
      "sourcePath": "docs/getting-started/azure-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to initialize a TypeScript Node.js V4 project and how to change the default route prefix of the host in Azure Functions. This is a fundamental step in setting up a serverless function in Azure using the Hono framework.",
      "ruleFile": "## Initialize a TypeScript Node.js V4 project and change default route prefix\n\nThis code snippet demonstrates how to initialize a TypeScript Node.js V4 project and change the default route prefix of the host in Azure Functions.\n\n```sh\nfunc init --typescript\n```\n\nAfter initializing the project, you can change the default route prefix of the host by adding the following property to the root json object of `host.json`:\n\n```json\n\"extensions\": {\n    \"http\": {\n        \"routePrefix\": \"\"\n    }\n}\n```\n\n### How it works\n\nThe `func init --typescript` command initializes a new TypeScript Node.js V4 project in the current folder. The `routePrefix` property in `host.json` determines the default route prefix for all HTTP routes.\n\n### Important notes\n\n- The `routePrefix` property should be set to an empty string to remove the default route prefix.\n\n### References\n\n- [Azure Functions documentation](https://docs.microsoft.com/en-us/azure/azure-functions/)\n\n### Common use cases\n\n- Setting up a serverless function in Azure\n- Changing the default route prefix for HTTP routes",
      "ruleTitle": "Initializing a TypeScript Node.js V4 Project and Changing Default Route Prefix in Azure Functions",
      "sourcePath": "docs/getting-started/azure-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to change the default route prefix in Azure Functions when using the Hono framework. By default, Azure Functions uses '/api' as the route prefix. If this is not changed, all Hono routes must start with '/api'. This rule shows how to change this default setting, which can be useful in cases where a different route prefix is desired.",
      "ruleFile": "## Changing the Default Route Prefix in Azure Functions with Hono\n\nThis code snippet demonstrates how to change the default route prefix in Azure Functions when using the Hono framework.\n\n```json\n\"extensions\": {\n    \"http\": {\n        \"routePrefix\": \"\"\n    }\n}\n```\n\n### How it works\n\nThis code should be added to the root JSON object of `host.json` in your Azure Functions project. The `routePrefix` property is set to an empty string, which removes the default '/api' prefix.\n\n### Important notes\n\nThe default Azure Functions route prefix is '/api'. If you don't change it as shown above, be sure to start all your Hono routes with '/api'.\n\n### References\n\n- [Azure Functions documentation](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference)\n\n### Common use cases\n\nThis rule is commonly used when you want to customize the route prefix in your Azure Functions project using the Hono framework.",
      "ruleTitle": "Changing the Default Route Prefix in Azure Functions with Hono",
      "sourcePath": "docs/getting-started/azure-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic Hono application with Azure Functions. It shows how to install necessary dependencies and create a simple 'Hello World' route.",
      "ruleFile": "## Installing Hono and Azure Functions Adapter\n\nTo start with, you need to install Hono and the Azure Functions adapter. Depending on your package manager, you can use one of the following commands:\n\n```sh\nyarn add @marplex/hono-azurefunc-adapter hono\n```\n\n```sh\npnpm add @marplex/hono-azurefunc-adapter hono\n```\n\n```sh\nbun add @marplex/hono-azurefunc-adapter hono\n```\n\n## Creating a Basic Hono Application\n\nNext, create a new file `src/app.ts` and add the following code:\n\n```ts\n// src/app.ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Azure Functions!'))\n\nexport default app\n```\n\nThis code creates a new Hono application and defines a GET route at the root path (`/`). When this route is accessed, it responds with the text 'Hello Azure Functions!'.\n\n## Creating an Azure Functions HTTP Trigger\n\nFinally, create a new file `src/functions/httpTrigger.ts` and add the necessary code to set up an Azure Functions HTTP trigger.\n\n## Important Notes\n\n- Make sure to install the Azure Functions adapter alongside Hono. This adapter is necessary for Hono to work with Azure Functions.\n- The `app.get` method is used to define a GET route. The first argument is the path, and the second argument is a callback function that takes a context object `c` and returns the response.\n\n## References\n\n- [Hono Documentation](https://marplex.github.io/hono/)\n- [Azure Functions Documentation](https://docs.microsoft.com/en-us/azure/azure-functions/)\n\n## Common Use Cases\n\n- Setting up a basic Hono application with Azure Functions\n- Defining simple routes in a Hono application",
      "ruleTitle": "Setting Up a Basic Hono Application with Azure Functions",
      "sourcePath": "docs/getting-started/azure-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a basic Hono application and how to create a HTTP trigger function in Azure using Hono. Understanding this rule is crucial for developers who want to use Hono with Azure Functions.",
      "ruleFile": "## Creating a Basic Hono Application and a HTTP Trigger Function in Azure\n\nThis code demonstrates how to set up a basic Hono application and how to create a HTTP trigger function in Azure using Hono.\n\n```ts\n// src/app.ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Azure Functions!'))\n\nexport default app\n```\n\n```ts\n// src/functions/httpTrigger.ts\nimport { app } from '@azure/functions'\nimport { azureHonoHandler } from '@marplex/hono-azurefunc-adapter'\nimport honoApp from '../app'\n\napp.http('httpTrigger', {\n  m\n```\n\n### How it works\n\n1. The first code snippet creates a new Hono application and sets up a route handler for GET requests at the root URL (`/`). The handler simply returns a text response.\n\n2. The second code snippet imports the Hono application and sets up a HTTP trigger function in Azure. The `httpTrigger` function is configured to use the Hono application.\n\n### Important notes\n\n- The `azureHonoHandler` function from the `@marplex/hono-azurefunc-adapter` package is used to adapt the Hono application to work with Azure Functions.\n\n### References\n\n- [Hono documentation](https://hono.marplex.net/)\n\n### Common use cases\n\n- Setting up a basic Hono application\n- Creating a HTTP trigger function in Azure using Hono",
      "ruleTitle": "Creating a Basic Hono Application and a HTTP Trigger Function in Azure",
      "sourcePath": "docs/getting-started/azure-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define HTTP methods supported by the Hono application, how to run the development server locally, and how to start the application using different package managers. Understanding this rule is crucial for setting up and running a Hono application.",
      "ruleFile": "## Defining Supported HTTP Methods and Running the Hono Application\n\nThis code snippet demonstrates how to define the HTTP methods supported by your Hono application and how to run the development server locally.\n\n```text\nds: [\n    //Add all your supported HTTP methods here\n    'GET',\n    'POST',\n    'DELETE',\n    'PUT',\n],\nauthLevel: 'anonymous',\nroute: '{*proxy}',\nhandler: azureHonoHandler(honoApp.fetch),\n})\n```\n\nTo run the development server locally, use the following command:\n\n```text\nnpm run start\n```\n\nYou can also start the application using different package managers like yarn, pnpm, or bun:\n\n```text\nyarn start\n```\n\n```text\npnpm start\n```\n\n```text\nbun run start\n```\n\n### How it works\n\nThe `ds` array is where you define all the HTTP methods your application supports. The `authLevel` is set to 'anonymous', which means no authentication is required. The `route` is set to '{*proxy}', which means all routes are handled by the specified handler.\n\nThe `npm run start` command starts the development server locally. You can access the application in your web browser at `http://localhost:7071`.\n\n### Important notes\n\nMake sure to define all the HTTP methods your application supports in the `ds` array. If a method is not defined, the application will not respond to requests using that method.\n\n### References\n\n- [Hono documentation](https://www.eclipse.org/hono/docs/)\n\n### Common use cases\n\n- Setting up and running a Hono application\n- Defining supported HTTP methods",
      "ruleTitle": "Defining Supported HTTP Methods and Running a Hono Application",
      "sourcePath": "docs/getting-started/azure-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to prepare a project for deployment to Azure using different package managers. It highlights the necessary steps to build the project before deploying it to the cloud infrastructure.",
      "ruleFile": "## Preparing a Project for Deployment to Azure\n\nThis code snippet demonstrates how to prepare a project for deployment to Azure. It involves building the project using different package managers such as npm, yarn, pnpm, and bun.\n\n```text\n:::\n\n## 5. Deploy\n\n::: info\nBefore you can deploy to Azure, you need to create some resources in your cloud infrastructure. Please visit the Microsoft documentation on [Create supporting Azure resources for your function](https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-typescript?pivots=nodejs-model-v4&tabs=windows%2Cazure-cli%2Cbrowser#create-supporting-azure-resources-for-your-function)\n:::\n\nBuild the project for deployment:\n\n::: code-group\n```\n\n### How it Works\n\nBefore deploying a project to Azure, it's necessary to build the project. This can be done using the `build` command of the package manager that's being used. The `build` command compiles the source code into a format that can be run on the server.\n\n### Important Notes\n\n- Before deploying to Azure, it's necessary to create some resources in the cloud infrastructure. This can be done by following the provided Microsoft documentation link.\n\n### References\n\n- [Microsoft Documentation: Create supporting Azure resources for your function](https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-typescript?pivots=nodejs-model-v4&tabs=windows%2Cazure-cli%2Cbrowser#create-supporting-azure-resources-for-your-function)\n\n### Common Use Cases\n\n- Preparing a project for deployment to Azure\n- Building a project using different package managers",
      "ruleTitle": "Preparing a Project for Deployment to Azure",
      "sourcePath": "docs/getting-started/azure-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy a Hono project to the Azure Cloud. Understanding this process is crucial for developers who want to host their applications on the Azure platform.",
      "ruleFile": "## Deploying a Hono Project to Azure Cloud\n\nThis code snippet demonstrates how to deploy a Hono project to the Azure Cloud.\n\n```sh\nfunc azure functionapp publish <YourFunctionAppName>\n```\n\n### How it works\n\nThe `func azure functionapp publish` command is used to deploy your project to the function app in Azure Cloud. You need to replace `<YourFunctionAppName>` with the name of your app.\n\n### Important notes\n\n- Ensure that you have the Azure Functions Core Tools installed on your machine.\n\n- You need to be logged in to your Azure account in the terminal or command prompt from which you are running the command.\n\n### References\n\n- [Azure Functions Core Tools](https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=windows%2Ccsharp%2Cbash)\n\n### Common use cases\n\n- Deploying a Hono project to Azure Cloud for hosting.\n\n- Updating a Hono project that is already hosted on Azure Cloud.",
      "ruleTitle": "Deploying a Hono Project to Azure Cloud",
      "sourcePath": "docs/getting-started/azure-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a new Hono application and install its dependencies using different package managers. Understanding this rule is crucial for setting up a new Hono project correctly.",
      "ruleFile": "## Creating a New Hono Application and Installing Dependencies\n\nThis code snippet demonstrates how to create a new Hono application and install its dependencies using different package managers.\n\n```sh\nyarn create hono my-app\n```\n\n```sh\npnpm create hono my-app\n```\n\n```sh\nbun create hono@latest my-app\n```\n\n```sh\ndeno init --npm hono my-app\n```\n\nAfter creating the application, you need to move to the application directory and install the dependencies.\n\n```sh\ncd my-app\nnpm i\n```\n\n```sh\ncd my-app\nyarn\n```\n\n```sh\ncd my-app\npnpm i\n```\n\n```sh\ncd my-app\nbun i\n```\n\n### How it Works\n\nThe `create` command is used to create a new application. The `cd` command is used to move to the application directory. The `i` or `install` command is used to install the dependencies.\n\n### Important Notes\n\n- Ensure that you have the package manager installed on your system before running these commands.\n\n### References\n\n- Hono Documentation\n\n### Common Use Cases\n\n- Setting up a new Hono project",
      "ruleTitle": "Creating a New Hono Application and Installing Dependencies",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono web framework. It shows how to import the necessary modules, create a new Hono application, define a route, and serve the application.",
      "ruleFile": "## Creating a Basic Hono Application\n\nThis code snippet demonstrates how to create a basic 'Hello World' application using the Hono web framework.\n\n```ts\nimport { serve } from '@hono/node-server'\nimport { Hono } from 'hono'\n\nconst app = new Hono()\napp.get('/', (c) => c.text('Hello Node.js!'))\n\nserve(app)\n```\n\n### How it works\n\n1. The necessary modules are imported.\n2. A new Hono application is created.\n3. A route is defined for the root URL ('/') that responds with the text 'Hello Node.js!'.\n4. The application is served using the 'serve' function.\n\n### Important notes\n\n- The 'serve' function starts the server and listens for requests.\n- The 'get' method is used to define a route for HTTP GET requests.\n\n### References\n\n- Hono documentation: https://hono.beyondco.de/docs/getting-started\n\n### Common use cases\n\n- Creating a simple web server with Hono.\n- Defining routes and handling requests in a Hono application.",
      "ruleTitle": "Creating a Basic Hono Application",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to run a Hono application locally. It shows the commands to start the development server using different package managers like npm, yarn, and pnpm. Understanding how to run the server is crucial for local development and testing.",
      "ruleFile": "## Running a Hono Application Locally\n\nThis code snippet demonstrates how to run a Hono application on your local machine for development and testing purposes.\n\n```text\n## 3. Run\n\nRun the development server locally. Then, access `http://localhost:3000` in your Web browser.\n\n::: code-group\n```\n\n### How it works\n\n1. The `npm run dev`, `yarn dev`, or `pnpm dev` command starts the development server.\n2. Once the server is running, you can access the application by navigating to `http://localhost:3000` in your web browser.\n\n### Important notes\n\n- Make sure to install the necessary dependencies before running the server.\n- Ensure that the port 3000 is not being used by another service.\n\n### References\n\n- [Hono Documentation](https://hono.boutique/docs/)\n\n### Common use cases\n\n- Running the application for local development and testing.\n- Debugging the application in a local environment.",
      "ruleTitle": "Running a Hono Application Locally",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to change the port number in a Hono application. This is a common requirement in web development, as different environments may require the application to run on different ports.",
      "ruleFile": "## Changing the Port Number in Hono\n\nIn Hono, you can specify the port number with the `port` option when calling the `serve` function. This is useful when you need to run your application on a different port than the default one.\n\nHere is a code snippet demonstrating this:\n\n```ts\nserve({\n  fetch: app.fetch,\n  port: 8787,\n})\n```\n\nIn this example, the Hono application will run on port 8787.\n\n### How it works\n\nThe `serve` function takes an options object as its argument. One of the options you can specify is `port`, which determines the port number the application will run on.\n\n### Important notes\n\n- The `port` option only changes the port number for the current run of the application. If you want to permanently change the port number, you should set it in your application's configuration.\n\n### References\n\n- [Hono API Documentation](https://hono.beyondnlp.com/api)\n\n### Common use cases\n\n- Running your application on a different port in a development environment.\n- Temporarily changing the port number for testing purposes.",
      "ruleTitle": "Changing the Port Number in Hono",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to access the raw Node.js APIs from within the Hono framework. This can be useful when developers need to use specific Node.js features that are not directly exposed by Hono.",
      "ruleFile": "## Access the raw Node.js APIs in Hono\n\nIn Hono, you can access the raw Node.js APIs from `c.env.incoming` and `c.env.outgoing`. This can be useful when you need to use specific Node.js features that are not directly exposed by Hono.\n\nHere is a code snippet demonstrating this:\n\n```ts\nimport { Hono } from 'hono'\nimport { serve, type HttpBindings } from '@hono/node-server'\n\n// or `Http2Bindings` if you use HTTP2\ntype Bindings = HttpBindings & {\n  /* ... */\n}\n\nconst app = new Hono\n```\n\n### How it works\n\nThe `c.env.incoming` and `c.env.outgoing` are properties of the context object `c` in Hono. They provide access to the raw incoming and outgoing Node.js APIs respectively.\n\n### Important notes\n\n- Be careful when using the raw Node.js APIs as they may not be compatible with the rest of your Hono application.\n\n### References\n\n- [Hono documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common use cases\n\n- When you need to use specific Node.js features that are not directly exposed by Hono.",
      "ruleTitle": "Accessing Raw Node.js APIs in Hono",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic HTTP server using Hono and how to serve static files from the local file system. Serving static files is a common requirement in many web applications, and understanding how to do this in Hono is crucial.",
      "ruleFile": "## Serve static files with Hono\n\nIn Hono, you can create a basic HTTP server and serve static files from the local file system. The code snippet below demonstrates this:\n\n```javascript\nconst app = new Hono<{ Bindings: Bindings }>()\n\napp.get('/', (c) => {\n  return c.json({\n    remoteAddress: c.env.incoming.socket.remoteAddress,\n  })\n})\n\nserve(app)\n```\n\nIn this example, an instance of Hono is created and a GET route is defined for the root URL (`/`). The callback function for this route returns a JSON response containing the remote address of the client.\n\nTo serve static files, you can use the `serveStatic` function. For example, if a request to the path `/static/*` comes in and you want to return a file under `./static`, you can use `serveStatic` to achieve this.\n\n### Important notes\n\n- The `serveStatic` function is not shown in the code snippet but is mentioned in the text. It's a common function used in many web frameworks to serve static files.\n\n### References\n\n- Hono documentation: https://hono.bike/\n\n### Common use cases\n\n- Serving static files like images, CSS, and JavaScript in a web application.\n- Creating a basic HTTP server.",
      "ruleTitle": "Creating a Basic HTTP Server and Serving Static Files with Hono",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files from a local file system using Hono web framework. It shows how to handle incoming requests to a specific path and return a file from a specified directory. This is a common requirement in many web applications where static resources like images, CSS, and JavaScript files are served from the server.",
      "ruleFile": "## Serving Static Files in Hono\n\nThis code demonstrates how to serve static files from a local file system using Hono web framework.\n\n```ts\nimport { serveStatic } from '@hono/node-server/serve-static'\n\napp.use('/static/*', serveStatic({ root: './' }))\n```\n\nWhen a request to the path `/static/*` comes in, Hono will return a file under `./static` directory.\n\n### How it works\n\nThe `serveStatic` function from `@hono/node-server/serve-static` is used as a middleware in the application. This function takes an options object where `root` property specifies the root directory from which to serve static assets.\n\n### Important notes\n\n- The path `/static/*` is a wildcard path that matches any path starting with `/static/`.\n- The `root` option in `serveStatic` function specifies the root directory from which to serve static assets.\n\n### References\n\n- [Hono documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Serving images, CSS, and JavaScript files in a web application.",
      "ruleTitle": "Serving Static Files in Hono",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files in a specific path using the Hono web framework. It shows how to use the 'serveStatic' function from '@hono/node-server/serve-static' to serve a specific file (in this case, 'favicon.ico') in the directory root. This is a common requirement in web development, where certain files need to be served statically and at specific paths.",
      "ruleFile": "## Serving Static Files in Specific Paths with Hono\n\nIn Hono, you can serve static files in specific paths using the 'serveStatic' function from '@hono/node-server/serve-static'. Here's an example of how to serve a 'favicon.ico' file in the directory root:\n\n```ts\napp.use('/favicon.ico', serveStatic({ path: './favicon.ico' }))\n```\n\nIn this code snippet, 'app.use' is used to define a middleware function to be used for requests to the '/favicon.ico' path. The 'serveStatic' function is then used with the 'path' option set to './favicon.ico', which means that requests to '/favicon.ico' will be served the 'favicon.ico' file in the directory root.\n\n### Important Notes\n\n- The 'serveStatic' function can be used to serve any static file, not just 'favicon.ico'.\n- The path provided to 'serveStatic' should be relative to the directory where your server script is running.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs)\n\n### Common Use Cases\n\n- Serving a custom 404 page\n- Serving images, stylesheets, and scripts for a website",
      "ruleTitle": "Serving Static Files in Specific Paths with Hono",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to serve static files in different directories using Hono. It shows how to map requests to specific paths to the corresponding static files in the server's file system. This is a common requirement in web development, and understanding how to do it efficiently can greatly improve the performance and responsiveness of a web application.",
      "ruleFile": "## Serving Static Files in Hono\n\nIn Hono, you can serve static files from different directories by mapping requests to specific paths to the corresponding static files in the server's file system. This is done using the `serveStatic` function and specifying the `root` or `path` option.\n\nHere is an example of how to serve all files in the root directory when a request to the path `/static/*` comes in:\n\n```ts\napp.use('/static/*', serveStatic({ root: './' }))\n```\n\nIf you want to serve a specific file, like `favicon.ico`, from the root directory, you can do it like this:\n\n```ts\napp.use('/favicon.ico', serveStatic({ path: './favicon.ico' }))\n```\n\nAnd if a request to the path `/hello.txt` or `/image.png` comes in and you want to return a file named `./static/hello.txt` or `./static/image.png`, you can use the following:\n\n```ts\napp.use('*', serveStatic({ root: './static' }))\n```\n\n### Important Notes\n\n- The `serveStatic` function is part of the Hono framework and is used to serve static files.\n- The `root` option specifies the root directory from which to serve static files.\n- The `path` option specifies the path to a specific file to serve.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common Use Cases\n\n- Serving static files like images, CSS, and JavaScript in a web application.\n- Serving a favicon for a website.\n- Serving files from different directories based on the request path.",
      "ruleTitle": "Serving Static Files with Hono",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'rewriteRequestPath' option in Hono to map a specific URL path to a different directory. This is useful in cases where you want to serve static files from a different directory than the one specified in the URL.",
      "ruleFile": "## Rule: Using 'rewriteRequestPath' to Map URL Paths to Different Directories\n\nIn Hono, you can use the 'rewriteRequestPath' option to map a specific URL path to a different directory. This is particularly useful when you want to serve static files from a directory that is different from the one specified in the URL.\n\nHere is a code snippet demonstrating this:\n\n```ts\napp.get(\n  '/static/*',\n  serveStatic({\n    root: './',\n    rewriteRequestPath: (path) =>\n      path.replace(/^\\/static/, '/statics'),\n  })\n)\n```\n\nIn this example, any request to 'http://localhost:3000/static/*' will be mapped to the './statics' directory instead of the './static' directory.\n\n### How it Works\n\nThe 'rewriteRequestPath' option takes a function that modifies the request path. In this case, the function replaces '/static' with '/statics' in the request path.\n\n### Important Notes\n\n- The 'rewriteRequestPath' option only modifies the request path for the purpose of serving static files. It does not change the actual URL of the request.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common Use Cases\n\n- Serving static files from a different directory than the one specified in the URL.\n- Redirecting requests to a different directory based on certain conditions.",
      "ruleTitle": "Using 'rewriteRequestPath' to Map URL Paths to Different Directories in Hono",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to run Hono on a Node.js http2 Server. It shows the basic setup for an unencrypted http2 server, which is crucial for developers who want to leverage the benefits of http2, such as server push, header compression, and full request and response multiplexing.",
      "ruleFile": "## Running Hono on a Node.js http2 Server\n\nThis code snippet demonstrates how to run Hono on a Node.js http2 Server.\n\n```ts\nimport { createServer } from 'node:http2'\n\nconst server = serve({\n  fetch: app.fetch,\n  createServer,\n})\n```\n\n### How it works\n\n1. The `createServer` function from the `node:http2` module is imported.\n2. The `serve` function is called with an object that includes the `fetch` method from the Hono application and the `createServer` function.\n\n### Important notes\n\n- This setup is for an unencrypted http2 server. For an encrypted server, you would need to use the `createSecureServer` function from the `node:http2` module.\n\n### References\n\n- [Node.js http2 Server](https://nodejs.org/api/http2.html)\n\n### Common use cases\n\n- When you want to leverage the benefits of http2 in your Hono application.",
      "ruleTitle": "Running Hono on a Node.js http2 Server",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up both unencrypted and encrypted http2 servers in Node.js using the Hono framework. Understanding how to correctly implement these servers is crucial for ensuring the security and functionality of your web application.",
      "ruleFile": "## Setting Up Unencrypted and Encrypted HTTP2 Servers in Node.js with Hono\n\nThis guide demonstrates how to set up both unencrypted and encrypted http2 servers in Node.js using the Hono framework.\n\n### Unencrypted HTTP2 Server\n\n```ts\nimport { createServer } from 'node:http2'\n\nconst server = serve({\n  fetch: app.fetch,\n  createServer,\n})\n```\n\n### Encrypted HTTP2 Server\n\n```ts\nimport { createSecureServer } from 'node:http2'\nimport { readFileSync } from 'node:fs'\n\nconst server = serve({\n  fetch: app.fetch,\n  createServer: createSecureServer,\n  serverOptions: {\n    key: readFileSync('path/to/key'),\n    cert: readFileSync('path/to/cert')\n  }\n})\n```\n\nIn the unencrypted server setup, the `createServer` function from the `node:http2` module is used. In the encrypted server setup, the `createSecureServer` function is used instead, along with server options for the SSL key and certificate.\n\n**Important Notes:**\n\n- Ensure that the paths to your SSL key and certificate are correct in the encrypted server setup.\n\n**References:**\n\n- [Node.js http2 Server](https://nodejs.org/api/http2.html)\n\n**Common Use Cases:**\n\n- Setting up a basic http2 server for a web application.\n- Setting up a secure http2 server for a web application that handles sensitive data.",
      "ruleTitle": "Setting Up Unencrypted and Encrypted HTTP2 Servers in Node.js with Hono",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates the process of building and deploying a Hono application. It covers the necessary steps to configure TypeScript and package.json, install necessary dependencies, and build the application. It also provides an example of a Dockerfile for containerizing the application, which is a common practice for deploying web applications.",
      "ruleFile": "## Building and Deploying a Hono Application\n\nThis code snippet demonstrates the necessary steps to build and deploy a Hono application.\n\n```text\n1. Add \"outDir\": \"./dist\" to the `compilerOptions` section `tsconfig.json`.\n2. Add \"exclude\": [\"node_modules\"] to `tsconfig.json`.\n3. Add \"build\": \"tsc\" to `script` section of `package.json`.\n4. Run `npm install typescript --save-dev`.\n5. Add \"type\": \"module\" to `package.json`.\n6. Run `npm run build`!\n```\n\nAfter these steps, a Dockerfile is provided for building a Docker image of the application.\n\n```Dockerfile\nFROM node:20-alpine AS base\n\nFROM base AS builder\n\nRUN apk add --no-cache gcompat\nWORKDIR /app\n\nCOPY package*json tsconfig.json src ./\n\nRUN npm ci && \\\n    npm run build && \\\n    npm prune\n```\n\n### How it Works\n\nThe steps configure TypeScript and package.json for the application, install TypeScript as a development dependency, and build the application. The Dockerfile then creates a Docker image of the application, which can be deployed to any environment that supports Docker.\n\n### Important Notes\n\n- The Dockerfile assumes that the application's source code is in a directory named 'src'. If your application's source code is in a different directory, you will need to modify the Dockerfile accordingly.\n\n### References\n\n- [Hono's Vite plugins](https://github.com/honojs/vite-plugins)\n\n### Common Use Cases\n\n- Building and deploying a Hono application\n- Containerizing a Hono application for deployment",
      "ruleTitle": "Building and Deploying a Hono Application",
      "sourcePath": "docs/getting-started/nodejs.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates the initialization of a new Supabase project, which is a fundamental step in starting any project with Supabase. Understanding this command is crucial for developers to get started with their projects.",
      "ruleFile": "## Initializing a New Supabase Project\n\nThis code snippet demonstrates how to initialize a new Supabase project in the current directory.\n\n```bash\nsupabase init\n```\n\n### How it works\n\nThe `supabase init` command initializes a new Supabase project in the current directory. This is the first step in creating a new project with Supabase.\n\n### Important notes\n\n- Ensure that you have Supabase CLI installed on your machine before running this command.\n- This command should be run in the directory where you want to create your new Supabase project.\n\n### References\n\n- [Supabase CLI Documentation](https://supabase.io/docs/guides/cli)\n\n### Common use cases\n\n- Starting a new project with Supabase.",
      "ruleTitle": "Initializing a New Supabase Project",
      "sourcePath": "docs/getting-started/supabase-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a new Edge Function in a Supabase project using the Hono framework. Understanding this rule allows developers to effectively add new functionalities to their Supabase projects.",
      "ruleFile": "## Creating a New Edge Function in Supabase\n\nThis guide demonstrates how to create a new Edge Function in a Supabase project using the Hono framework.\n\n### Code Snippet\n\n```bash\nsupabase functions new hello-world\n```\n\n### How It Works\n\nThe `supabase functions new` command is used to create a new Edge Function in your Supabase project. The `hello-world` argument specifies the name of the new function.\n\n### Important Notes\n\n- The new function is created in the `supabase/functions` directory of your project.\n- The function name should be unique within your project.\n\n### References\n\n- [Supabase Documentation](https://supabase.io/docs)\n\n### Common Use Cases\n\n- Adding new functionalities to your Supabase project.\n- Creating a function to handle specific tasks in your application.",
      "ruleTitle": "Creating a New Edge Function in Supabase",
      "sourcePath": "docs/getting-started/supabase-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic 'Hello World' function using the Hono framework. It shows how to import the Hono module, define a function name, set a base path for the function, define a GET request handler for the '/hello' path, and serve the function using Deno. Understanding this pattern is crucial for developers to get started with creating web applications using the Hono framework.",
      "ruleFile": "## Creating a Basic Function in Hono\n\nThis code snippet demonstrates how to create a basic 'Hello World' function using the Hono framework.\n\n```ts\nimport { Hono } from 'jsr:@hono/hono'\n\n// change this to your function name\nconst functionName = 'hello-world'\nconst app = new Hono().basePath(`/${functionName}`)\n\napp.get('/hello', (c) => c.text('Hello from hono-server!'))\n\nDeno.serve(app.fetch)\n```\n\n### How it works\n\n1. The Hono module is imported.\n2. A constant `functionName` is defined with the name of the function.\n3. A new Hono instance is created and the base path for the function is set using the `basePath` method.\n4. A GET request handler for the '/hello' path is defined using the `get` method. The handler sends a text response 'Hello from hono-server!'.\n5. The function is served using the `Deno.serve` method and the `fetch` method of the Hono instance.\n\n### Important notes\n\n- The function name should be unique within the project.\n- The `basePath` method sets the base URL path for all routes of the Hono instance.\n\n### References\n\n- Hono documentation: https://hono.bayrell.org/\n\n### Common use cases\n\n- Creating a basic web server\n- Defining request handlers for specific paths",
      "ruleTitle": "Creating a Basic Function in Hono",
      "sourcePath": "docs/getting-started/supabase-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to start a Supabase stack and serve a function locally using Hono. It also shows how to bypass JWT verification during local development, which can be useful for testing and debugging.",
      "ruleFile": "## Running Supabase Stack and Serving Functions Locally\n\nThis code snippet demonstrates how to start a Supabase stack and serve a function locally using Hono. It also shows how to bypass JWT verification during local development.\n\n```bash\nsupabase start # start the supabase stack\nsupabase functions serve --no-verify-jwt # start the Functions watcher\n```\n\n### How it works\n\n1. `supabase start` command is used to start the Supabase stack.\n2. `supabase functions serve --no-verify-jwt` command is used to start the Functions watcher. The `--no-verify-jwt` flag allows you to bypass JWT verification during local development.\n\n### Important notes\n\n- The `--no-verify-jwt` flag should only be used during local development and should not be used in a production environment.\n\n### References\n\n- [Supabase Documentation](https://supabase.io/docs)\n\n### Common use cases\n\n- Starting a Supabase stack and serving functions locally for testing and debugging purposes.",
      "ruleTitle": "Starting Supabase Stack and Serving Functions Locally",
      "sourcePath": "docs/getting-started/supabase-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to make a GET request to a Hono server and how to deploy all Edge Functions in Supabase with a single command. Understanding these commands is crucial for local development and deployment of applications using the Hono framework.",
      "ruleFile": "## Making a GET Request and Deploying Functions in Hono\n\nThis guide demonstrates how to make a GET request to a Hono server and how to deploy all Edge Functions in Supabase with a single command.\n\n### Code Snippet\n\n```bash\ncurl  --location  'http://127.0.0.1:54321/functions/v1/hello-world/hello'\n```\n\n### How it Works\n\nThe `curl` command is used to make a GET request to the specified URL. The `--location` flag tells curl to handle redirects.\n\nTo deploy all your Edge Functions in Supabase, use the command:\n\n```bash\nsupabase functions deploy\n```\n\n### Important Notes\n\nThe `--no-verify-jwt` flag allows you to bypass JWT verification during local development.\n\n### References\n\n- [Hono Documentation](https://hono.eclipse.org/)\n- [Supabase Documentation](https://supabase.io/docs)\n\n### Common Use Cases\n\nThese commands are commonly used during local development and deployment of applications using the Hono framework.",
      "ruleTitle": "Making GET Requests and Deploying Functions in Hono",
      "sourcePath": "docs/getting-started/supabase-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy functions in Supabase using Hono. It shows both the method to deploy all functions at once and the method to deploy a specific function. Understanding this rule is crucial for managing and deploying functions in a Supabase project.",
      "ruleFile": "## Deploying Functions in Supabase with Hono\n\nThis code snippet demonstrates how to deploy functions in Supabase using Hono.\n\nTo deploy all of your Edge Functions in Supabase, use the following command:\n\n```bash\nsupabase functions deploy\n```\n\nAlternatively, you can deploy individual Edge Functions by specifying the name of the function in the deploy command:\n\n```bash\nsupabase functions deploy hello-world\n```\n\n### How it works\n\nThe `supabase functions deploy` command deploys all the Edge Functions in your Supabase project. If you want to deploy a specific function, you can specify the function name after the `deploy` keyword.\n\n### Important notes\n\n- Make sure you have the necessary permissions to deploy functions in your Supabase project.\n\n### References\n\n- [Supabase Functions Documentation](https://supabase.io/docs/guides/database)\n\n### Common use cases\n\n- Deploying changes to your functions in a Supabase project.\n- Deploying a specific function after making changes to it.",
      "ruleTitle": "Deploying Functions in Supabase with Hono",
      "sourcePath": "docs/getting-started/supabase-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy functions in Supabase, either all at once or individually. Understanding how to deploy functions is crucial for the development and production process, as it allows changes to be pushed live.",
      "ruleFile": "## Deploying Functions in Supabase\n\nThis code snippet demonstrates how to deploy functions in Supabase. You can either deploy all functions at once or deploy individual functions by specifying the function name.\n\n```bash\nsupabase functions deploy\n```\n\nTo deploy an individual function, specify the function name in the deploy command:\n\n```bash\nsupabase functions deploy hello-world\n```\n\n### How it Works\n\nThe `supabase functions deploy` command deploys all the functions in your Supabase project. If you want to deploy a specific function, you can do so by specifying the function name after the deploy command.\n\n### Important Notes\n\n- Make sure you have the correct permissions to deploy functions.\n- Ensure your function is working correctly before deploying to avoid breaking changes.\n\n### References\n\n- [Supabase Documentation](https://supabase.com/docs/guides/functions/deploy)\n\n### Common Use Cases\n\n- Deploying changes to a function in production\n- Deploying all functions after a major update",
      "ruleTitle": "Deploying Functions in Supabase",
      "sourcePath": "docs/getting-started/supabase-functions.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a new Hono application and install its dependencies using different package managers. Understanding this rule is crucial for setting up a new Hono project correctly.",
      "ruleFile": "## Creating a new Hono application and installing dependencies\n\nThe following code snippets demonstrate how to create a new Hono application and install its dependencies using different package managers.\n\n```sh\nyarn create hono my-app\n```\n\n```sh\npnpm create hono my-app\n```\n\n```sh\nbun create hono@latest my-app\n```\n\n```sh\ndeno init --npm hono my-app\n```\n\nAfter creating the application, move to the application directory and install the dependencies.\n\n```sh\ncd my-app\nnpm i\n```\n\n```sh\ncd my-app\nyarn\n```\n\n```sh\ncd my-app\npnpm i\n```\n\n```sh\ncd my-app\nbun i\n```\n\n### How it works\n\nThe `create` command is used to create a new Hono application. The `cd` command is used to move to the application directory. The `i` or `install` command is used to install the dependencies of the application.\n\n### Important notes\n\n- Make sure to use the correct command for your package manager.\n- The `@latest` tag can be used to create an application with the latest version of Hono.\n\n### References\n\n- [Hono documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Setting up a new Hono project",
      "ruleTitle": "Creating a new Hono application and installing dependencies",
      "sourcePath": "docs/getting-started/fastly.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono web framework. It shows the basic structure of a Hono application, how to define a route, and how to send a response from the server to the client.",
      "ruleFile": "## Creating a Basic 'Hello World' Application in Hono\n\nThis code snippet demonstrates how to create a basic 'Hello World' application using the Hono web framework.\n\n```ts\n// src/index.ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello Fastly!'))\n\napp.fire()\n```\n\n### How it works\n\n1. Import the Hono web framework.\n2. Create a new instance of Hono.\n3. Define a GET route for the root URL ('/') that sends the text 'Hello Fastly!' as a response.\n4. Start the Hono application with the `fire` method.\n\n### Important notes\n\n- The `c.text` method sends a text response to the client.\n- The `fire` method starts the Hono application and begins listening for incoming requests.\n\n### References\n\n- [Hono Documentation](https://hono.bun.dev/)\n\n### Common use cases\n\n- Creating a basic web application with Hono.\n- Defining routes and sending responses in a Hono application.",
      "ruleTitle": "Creating a Basic 'Hello World' Application in Hono",
      "sourcePath": "docs/getting-started/fastly.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to run a Hono application locally. Running the application locally is a crucial step in the development process as it allows developers to test and debug their application before deploying it to a live environment.",
      "ruleFile": "## Running a Hono Application Locally\n\nThis code snippet demonstrates how to run a Hono application locally. After setting up your application, you can start the development server and access your application via `http://localhost:7676` in your web browser.\n\n```sh\nnpm run start\n```\n\n```sh\nyarn start\n```\n\n```sh\npnpm run start\n```\n\n```sh\nbun run start\n```\n\n### How it works\n\nThese commands start the development server for your Hono application. Depending on the package manager you're using, you can use either `npm`, `yarn`, `pnpm`, or `bun` to start the server.\n\n### Important notes\n\nEnsure that you have installed all the necessary dependencies before running these commands. If you encounter any errors, they are likely due to missing dependencies or configuration issues.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs/getting-started)\n\n### Common use cases\n\nThis is a common step that you'll perform regularly during the development process. It's typically done after making changes to your code to test and debug your application.",
      "ruleTitle": "Running a Hono Application Locally",
      "sourcePath": "docs/getting-started/fastly.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy an application to Fastly using different package managers. It shows the commands needed to build and deploy the application, which is a crucial step in the development process.",
      "ruleFile": "## Deploying an Application to Fastly\n\nThis code snippet demonstrates how to deploy an application to Fastly using different package managers like npm, yarn, pnpm, and bun.\n\n```text\n:::\n\n## 4. Deploy\n\nTo build and deploy your application to your Fastly account, type the following command. The first time you deploy the application, you will be prompted to create a new service in your account.\n\nIf you don't have an account yet, you must [create your Fastly account](https://www.fastly.com/signup/).\n\n::: code-group\n```\n\n### How it works\n\n1. The command `npm run deploy`, `yarn deploy`, `pnpm run deploy`, or `bun run deploy` is used to build and deploy the application.\n2. If it's the first time deploying the application, you will be prompted to create a new service in your Fastly account.\n\n### Important notes\n\n- You must have a Fastly account to deploy the application. If you don't have one, you can create it [here](https://www.fastly.com/signup/).\n\n### References\n\n- [Fastly Documentation](https://docs.fastly.com/)\n\n### Common use cases\n\n- Deploying an application to Fastly for the first time.\n- Updating an existing application on Fastly.",
      "ruleTitle": "Deploying an Application to Fastly",
      "sourcePath": "docs/getting-started/fastly.md",
      "category": "getting-started"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic Hono application and how to start a new Hono project using different package managers. Understanding this rule is crucial for developers to get started with Hono.",
      "ruleFile": "## Creating a Basic Hono Application and Starting a New Project\n\nThis code snippet demonstrates how to create a basic Hono application and how to start a new Hono project using different package managers.\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hono!'))\n\nexport default app\n```\n\nTo start a new Hono project, you can use the following commands depending on the package manager you are using:\n\n```sh [npm]\nnpm create hono@latest\n```\n\n```sh [yarn]\nyarn create hono\n```\n\n```sh [pnpm]\npnpm create hono@latest\n```\n\n```sh [bun]\nbun create hono@latest\n```\n\n```sh [deno]\ndeno init --npm hono@latest\n```\n\n### How it works\n\nThe `Hono` class is imported from the `hono` package. An instance of `Hono` is created and a GET route is defined for the root URL (`/`). The route handler function takes a context object `c` and sends a text response 'Hono!'.\n\nTo start a new project, the `create` command is used with the package manager. This command creates a new Hono project with the latest version.\n\n### Important notes\n\n- The `create` command may vary depending on the package manager.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common use cases\n\n- Creating a basic Hono application\n- Starting a new Hono project",
      "ruleTitle": "Creating a Basic Hono Application and Starting a New Project",
      "sourcePath": "docs/index.md",
      "category": "docs"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a new Hono project using different package managers. It also provides an overview of Hono's features, use-cases, and who is using it. This information is crucial for developers who are considering using Hono for their projects.",
      "ruleFile": "## Creating a new Hono project\n\nYou can create a new Hono project using different package managers. Here are the commands for npm, yarn, pnpm, bun, and deno:\n\n```sh\nnpm create hono@latest\n```\n\n```sh\nyarn create hono\n```\n\n```sh\npnpm create hono@latest\n```\n\n```sh\nbun create hono@latest\n```\n\n```sh\ndeno init --npm hono@latest\n```\n\n## Features of Hono\n\nHono is a simple web application framework that is ultrafast, lightweight, and works on multiple runtimes. It has built-in middleware, custom middleware, third-party middleware, and helpers. It also has first-class TypeScript support.\n\n## Use-cases of Hono\n\nHono can be used for building Web APIs, proxy of backend servers, front of CDN, edge application, base server for a library, and full-stack application.\n\n## Who is using Hono?\n\nHono is used by various projects such as cdnjs, Cloudflare D1, Cloudflare Workers KV, BaseAI, Unkey, OpenStatus, Deno Benchmarks, Clerk, Drivly, and repeat.dev.\n\n## References\n\n- [Who is using Hono in production?](https://github.com/orgs/honojs/discussions/1510)\n\n## Common use cases\n\n- Building Web APIs\n- Proxy of backend servers\n- Front of CDN\n- Edge application\n- Base server for a library\n- Full-stack application",
      "ruleTitle": "Creating a new Hono project and understanding its features, use-cases, and who is using it",
      "sourcePath": "docs/index.md",
      "category": "docs"
    },
    {
      "reasoning": "This rule is important as it demonstrates the lightweight nature of the Hono web framework. It shows that Hono, when minified, is significantly smaller in size compared to other web frameworks like Express. This is crucial for developers who are concerned about the performance and efficiency of their web applications.",
      "ruleFile": "## Hono's Lightweight Nature\n\nThis code snippet demonstrates the lightweight nature of the Hono web framework. With the `hono/tiny` preset, its size is under 14KB when minified. This is significantly smaller compared to other web frameworks like Express, which is 572KB in size. This makes Hono a more efficient choice for developers who are concerned about the performance of their web applications.\n\n```text\nSee [more benchmarks](/docs/concepts/benchmarks).\n\n## Lightweight\n\n**Hono is so small**. With the `hono/tiny` preset, its size is **under 14KB** when minified. There are many middleware and adapters, but they are bundled only when used. For context, the size of Express is 572KB.\n```\n\n### How it works\n\nHono achieves its small size by only bundling middleware and adapters when they are used. This means that unused features do not contribute to the overall size of the application.\n\n### Important notes\n\n- The size of the Hono framework can vary depending on the middleware and adapters used.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs)\n\n### Common use cases\n\n- Building lightweight web applications\n- Building web applications where performance is a key concern",
      "ruleTitle": "Understanding Hono's Lightweight Nature",
      "sourcePath": "docs/index.md",
      "category": "docs"
    },
    {
      "reasoning": "This rule is important as it demonstrates the versatility and flexibility of the Hono web framework. It shows how Hono supports multiple routers, adheres to web standards, and provides a wide range of middleware and helpers. Understanding these features allows developers to effectively use Hono in various environments and for various use cases.",
      "ruleFile": "## Hono Framework Features\n\nThis code snippet provides an overview of the key features of the Hono web framework.\n\n```text\n## Multiple routers\n\nHono has multiple routers. RegExpRouter is the fastest router in the JavaScript world. It matches the route using a single large Regex created before dispatch. With SmartRouter, it supports all route patterns.\n\nLinearRouter registers the routes very quickly, so it's suitable for an environment that initializes applications every time. PatternRouter simply adds and matches the pattern, making it small.\n\n## Web Standards\n\nThanks to the use of the Web Standards, Hono works on a lot of platforms.\n\n- Cloudflare Workers\n- Cloudflare Pages\n- Fastly Compute\n- Deno\n- Bun\n- Vercel\n- AWS Lambda\n- Lambda@Edge\n- Others\n\nAnd by using a Node.js adapter, Hono works on Node.js.\n\n## Middleware & Helpers\n\nHono has many middleware and helpers. This makes 'Write Less, do more' a reality.\n\nOut of the box, Hono provides middleware and helpers for:\n\n- Basic Authentication\n- Bearer Authentication\n- Body Limit\n- Cache\n- Compress\n- Context Storage\n- Cookie\n- CORS\n- ETag\n- html\n- JSX\n- JWT Authentication\n- Logger\n- Language\n- Pretty JSON\n- Secure Headers\n- SSG\n- Streaming\n- GraphQL Server\n- Firebase Authentication\n- Sentry\n- Others!\n\nFor example, adding ETag and request logging only takes a few lines of code with Hono:\n```\n\n### How it works\n\nHono provides a variety of routers, each with their own strengths and use cases. It also adheres to web standards, making it compatible with a wide range of platforms. Additionally, Hono provides a multitude of middleware and helpers to streamline development.\n\n### Important notes\n\nUnderstanding the different routers, the platforms Hono supports, and the available middleware and helpers is crucial for effective use of the Hono framework.\n\n### References\n\n- [Hono Documentation](https://honojs.com/docs)\n\n### Common use cases\n\nHono can be used in a variety of web development scenarios, from creating serverless applications to building robust APIs.",
      "ruleTitle": "Understanding Key Features of Hono Framework",
      "sourcePath": "docs/index.md",
      "category": "docs"
    },
    {
      "reasoning": "This rule is important as it emphasizes the best practice of avoiding the creation of 'Ruby on Rails-like Controllers' in Hono. This is because the path parameter cannot be inferred in the Controller without writing complex generics. This rule demonstrates the incorrect way of creating a controller in Hono.",
      "ruleFile": "## Don't make 'Ruby on Rails-like Controllers' when possible\n\nIn Hono, it is recommended to avoid creating 'Ruby on Rails-like Controllers'. This is because the path parameter cannot be inferred in the Controller without writing complex generics, which can make the code more complicated and harder to maintain.\n\nHere is an example of what not to do:\n\n```ts\n// ðŸ™\n// A RoR-like Controller\nconst booksList = (c: Context) => {\n  return c.json('list books')\n}\n\napp.get('/books', booksList)\n```\n\nIn this example, the `booksList` function is a 'Ruby on Rails-like Controller'. This is not recommended in Hono because the path parameter cannot be inferred in the Controller without writing complex generics.\n\n### Important notes\n\n- Avoid creating 'Ruby on Rails-like Controllers' in Hono.\n- The path parameter cannot be inferred in the Controller without writing complex generics.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/guide)\n\n### Common use cases\n\n- When defining routes and their corresponding handlers in a Hono application.",
      "ruleTitle": "Avoid Creating 'Ruby on Rails-like Controllers' in Hono",
      "sourcePath": "docs/guides/best-practices.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates the best practice of writing handlers directly after path definitions in Hono. This is because the path parameter cannot be inferred in the Controller without writing complex generics, which can lead to unnecessary complexity and potential errors in the code.",
      "ruleFile": "## Avoid RoR-like Controllers in Hono\n\nIn Hono, it's recommended to write handlers directly after path definitions. This is because the path parameter cannot be inferred in the Controller without writing complex generics. Here's an example of what not to do:\n\n```ts\n// ðŸ™\n// A RoR-like Controller\nconst bookPermalink = (c: Context) => {\n  const id = c.req.param('id') // Can't infer the path param\n  return c.json(`get ${id}`)\n}\n```\n\nIn this example, the `id` parameter cannot be inferred, leading to potential issues. Instead, write the handler directly after the path definition to avoid this issue.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs)\n\n### Common Use Cases\n\nThis rule is commonly used when defining routes and handlers in a Hono application.",
      "ruleTitle": "Avoid RoR-like Controllers in Hono",
      "sourcePath": "docs/guides/best-practices.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates the best practice for defining handlers directly after path definitions in Hono. This approach allows for better inference of path parameters, leading to cleaner and more efficient code.",
      "ruleFile": "## Best Practice for Defining Handlers in Hono\n\nIn Hono, it is recommended to define handlers directly after path definitions. This allows for better inference of path parameters, leading to cleaner and more efficient code.\n\nHere is an example of how to do this:\n\n```ts\napp.get('/books/:id', (c) => {\n  const id = c.req.param('id') // Can infer the path param\n  return c.json(`get ${id}`)\n})\n```\n\nIn this example, the handler for the GET request to '/books/:id' is defined directly after the path definition. This allows the 'id' path parameter to be easily inferred and used within the handler.\n\nNote: If you still want to create a RoR-like Controller, you can use `factory.createHandlers()` in `hono/factory`. However, this approach may not allow for as clean inference of path parameters.",
      "ruleTitle": "Defining Handlers Directly After Path Definitions in Hono",
      "sourcePath": "docs/guides/best-practices.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a RoR-like Controller using Hono's factory.createHandlers() method. It also shows how to use middleware in the Hono framework. This pattern ensures that type inference works correctly, which is crucial for maintaining type safety in TypeScript.",
      "ruleFile": "## Creating a RoR-like Controller with Hono's factory.createHandlers()\n\nThis code demonstrates how to create a RoR-like Controller using Hono's factory.createHandlers() method and how to use middleware in the Hono framework.\n\n```ts\nimport { createFactory } from 'hono/factory'\nimport { logger } from 'hono/logger'\n\n// ...\n\nconst factory = createFactory()\n\nconst middleware = factory.createMiddleware(async (c, next) => {\n  c.set('foo', 'bar')\n  await next()\n})\n\nconst handlers = factory.createHandlers(logger(), middleware, (c) => {\n  return c.json(c.var.foo)\n})\n\napp.get('/api', ...handlers)\n```\n\n### How it works\n\n1. A factory is created using the createFactory() method from 'hono/factory'.\n2. Middleware is created using the factory's createMiddleware() method. This middleware sets a variable 'foo' to 'bar' and then calls the next middleware in the stack.\n3. Handlers are created using the factory's createHandlers() method. These handlers use the previously created logger and middleware, and return a JSON response containing the value of 'foo'.\n4. The handlers are then used in an Express.js route.\n\n### Important notes\n\n- Using factory.createHandlers() ensures that type inference works correctly in TypeScript.\n\n### References\n\n- Hono factory documentation: https://hono.bespokejs.com/docs/helpers/factory\n\n### Common use cases\n\n- Creating RoR-like Controllers in Hono.\n- Using middleware in Hono.",
      "ruleTitle": "Creating RoR-like Controllers with Hono's factory.createHandlers()",
      "sourcePath": "docs/guides/best-practices.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to structure a Hono application by separating different endpoints into their own files. This is a common practice in web development to keep code organized and maintainable. It also shows how to define basic CRUD operations using Hono's routing methods.",
      "ruleFile": "## Hono: Organizing Endpoints into Separate Files\n\nIn Hono, it's a good practice to separate different endpoints into their own files. This helps in keeping the code organized and maintainable. For instance, if your application has `/authors` and `/books` endpoints, you can create `authors.ts` and `books.ts` files.\n\nHere is an example of how to define basic CRUD operations in `authors.ts`:\n\n```ts\n// authors.ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.json('list authors'))\napp.post('/', (c) => c.json('create an author', 201))\napp.get('/:id', (c) => c.json(`get ${c.req.param('id')}`))\n\nexport default app\n```\n\nIn this code:\n\n- We first import the Hono framework.\n- We create a new Hono application.\n- We define three routes: a GET route for listing authors, a POST route for creating an author, and another GET route for fetching a specific author by ID.\n- Finally, we export the Hono application so it can be used in other parts of our code.\n\n**Important notes:**\n\n- Make sure to export the Hono application at the end of the file so it can be imported and used in other parts of your code.\n- The `c.req.param('id')` in the `app.get('/:id', (c) => c.json(`get ${c.req.param('id')}`))` line is used to access route parameters.\n\n**References:**\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n**Common use cases:**\n\n- Structuring a large Hono application with multiple endpoints.\n- Defining basic CRUD operations for a resource.",
      "ruleTitle": "Organizing Endpoints into Separate Files in Hono",
      "sourcePath": "docs/guides/best-practices.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes for different resources in separate files and then import them into a main file in the Hono framework. This approach promotes modularity and separation of concerns, making the code easier to maintain and understand.",
      "ruleFile": "## Defining and Importing Routes in Hono Framework\n\nThis code demonstrates how to define routes for different resources in separate files and then import them into a main file in the Hono framework.\n\n```ts\n// books.ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.json('list books'))\napp.post('/', (c) => c.json('create a book', 201))\napp.get('/:id', (c) => c.json(`get ${c.req.param('id')}`))\n\nexport default app\n```\n\nIn the above code, we define routes for the 'books' resource. We then export the 'app' instance so that it can be imported in other files.\n\nThis approach promotes modularity and separation of concerns, making the code easier to maintain and understand. It's a common practice in web development to separate routes based on the resources they handle.\n\n### Important Notes\n\n- Each route handler is a function that takes a context object 'c' and returns a response using the 'json' method of the context object.\n- The 'get' and 'post' methods of the 'app' instance are used to define GET and POST routes respectively.\n- The ':id' in the path of the third route is a route parameter that can be accessed using 'c.req.param('id')'.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common Use Cases\n\n- Defining routes for different resources in a web application.\n- Separating route definitions into different files for better code organization.",
      "ruleTitle": "Defining and Importing Routes in Hono Framework",
      "sourcePath": "docs/guides/best-practices.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to structure a Hono application by separating routes into different modules and then importing and mounting them on the main application. This promotes code organization and modularity, making the code easier to maintain and understand.",
      "ruleFile": "## Hono Route Separation and Mounting\n\nThis code snippet demonstrates how to separate routes into different modules and then import and mount them on the main application in Hono.\n\n```ts\n// index.ts\nimport { Hono } from 'hono'\nimport authors from './authors'\nimport books from './books'\n\nconst app = new Hono()\n\n// ðŸ˜ƒ\napp.route('/authors', authors)\napp.route('/books', books)\n\nexport default app\n```\n\n### How it works\n\n1. Import the Hono module and the route modules (authors and books in this case).\n2. Create a new Hono application.\n3. Use the `app.route()` method to mount the imported route modules on the desired paths.\n\n### Important notes\n\n- This pattern promotes code organization and modularity.\n- It's a good practice to separate different parts of the application into different modules.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common use cases\n\n- Building a large scale application with Hono where routes need to be organized in a modular way.",
      "ruleTitle": "Route Separation and Mounting in Hono",
      "sourcePath": "docs/guides/best-practices.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to correctly use the RPC feature in Hono. It shows how to chain methods to get the correct type and how to pass the type of the app to the hc function to get the correct type. This is crucial for ensuring type safety and correct functionality when using the RPC feature in Hono.",
      "ruleFile": "## Using RPC Features in Hono\n\nThe code snippet demonstrates how to use the RPC feature in Hono by chaining methods to get the correct type and passing the type of the app to the hc function.\n\n```ts\n// authors.ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n  .get('/', (c) => c.json('list authors'))\n  .post('/', (c) => c.json('create an author', 201))\n  .get('/:id', (c) => c.json(`get ${c.req.param('id')}`))\n\nexport default app\n```\n\nTo use the RPC feature, pass the type of the app to the hc function as follows:\n\n```ts\nimport app from './authors'\nimport { hc } from 'hono/client'\n\n// ðŸ˜ƒ\nconst client = hc<typeof app>('http://localhost')\n```\n\n### How it works\n\nThe Hono framework allows you to chain methods to define routes and their handlers. When you want to use the RPC feature, you can get the correct type by chaining as shown in the code snippet. The type of the app is then passed to the hc function to get the correct type.\n\n### Important notes\n\nEnsure that you correctly chain the methods and pass the correct type to the hc function to avoid type errors and ensure correct functionality.\n\n### References\n\n- Hono documentation: https://hono.bevry.me/\n\n### Common use cases\n\n- When you want to use the RPC feature in Hono and need to ensure type safety.",
      "ruleTitle": "Using RPC Features in Hono",
      "sourcePath": "docs/guides/best-practices.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to correctly type the client in Hono framework. By passing the type of the 'app' to 'hc', the client gets the correct type. This is crucial for maintaining type safety and ensuring that the client behaves as expected.",
      "ruleFile": "## Correctly Typing the Client in Hono Framework\n\nIn Hono framework, it's important to correctly type the client. This can be achieved by passing the type of the 'app' to 'hc'. Here is a code snippet demonstrating this:\n\n```ts\nimport app from './authors'\nimport { hc } from 'hono/client'\n\n// ðŸ˜ƒ\nconst client = hc<typeof app>('http://localhost') // Typed correctly\n```\n\nBy doing this, the client gets the correct type, ensuring type safety and expected behavior.\n\n### How it Works\n\nThe 'hc' function in Hono takes the type of the 'app' as an argument and returns a client of that type. This is how the client gets correctly typed.\n\n### Important Notes\n\n- Always pass the type of the 'app' to 'hc' to correctly type the client.\n\n### References\n\n- [Hono RPC page](/docs/guides/rpc#using-rpc-with-larger-applications)\n\n### Common Use Cases\n\n- When you want to ensure type safety and expected behavior of the client in Hono framework.",
      "ruleTitle": "Correctly Typing the Client in Hono Framework",
      "sourcePath": "docs/guides/best-practices.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to share the API specification with the client in Hono. By exporting the type, the client can import it and understand the structure of the API. This is crucial for ensuring that the client and server are communicating with the same API structure, reducing potential errors and misunderstandings.",
      "ruleFile": "## Exporting API Specification to the Client in Hono\n\nIn Hono, you can share the API specification with the client by exporting the type. This allows the client to import it and understand the structure of the API.\n\nHere is a code snippet demonstrating this:\n\n```ts\nexport type AppType = typeof route\n```\n\nOn the client side, you can then import this type along with `hc` from Hono:\n\n```ts\nimport type { AppType } from '.'\nimport { hc } from 'hono/client'\n```\n\n`hc` is a function in Hono that helps with handling client-side operations.\n\nBy doing this, you ensure that the client and server are communicating with the same API structure, reducing potential errors and misunderstandings.",
      "ruleTitle": "Sharing API Specification with the Client in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a client in Hono. It shows the process of importing the necessary modules and types, and then using the 'hc' function to create a client. This is a fundamental step in setting up communication between the client and the server in a Hono application.",
      "ruleFile": "## Creating a Client in Hono\n\nThis guide demonstrates how to create a client in Hono.\n\nFirst, import the necessary modules and types. In this case, we need `hc` from 'hono/client' and `AppType`.\n\n```ts\nimport type { AppType } from '.'\nimport { hc } from 'hono/client'\n```\n\nThen, use the 'hc' function to create a client. Pass `AppType` as Generics and specify the server URL as an argument.\n\n```ts\nconst client = hc<AppType>('http://localhost:3000')\n```\n\n### How it works\n\nThe 'hc' function is used to create a client in Hono. It takes a type and a server URL as arguments. The type is used to ensure that the client and server are using the same API specification.\n\n### Important notes\n\n- Ensure that the server URL is correct. If the server is not running or the URL is incorrect, the client will not be able to communicate with the server.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/guide/)\n\n### Common use cases\n\n- Setting up a client to communicate with a Hono server.",
      "ruleTitle": "Creating a Client in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a client using the Hono framework, specify the server URL, and make a POST request to the server. Understanding this rule is crucial for developers to interact with the server and send data using the Hono framework.",
      "ruleFile": "## Creating a Client and Making a POST Request in Hono\n\nThis guide demonstrates how to create a client using the Hono framework, specify the server URL, and make a POST request to the server.\n\nHere is the code snippet:\n\n```ts\nconst client = hc<AppType>('http://localhost:8787/')\n\nconst res = await client.posts.$post({\n  form: {\n    title: 'Hello',\n    body: 'Hono is a cool project',\n  },\n})\n```\n\nIn the above code:\n\n1. `hc` is a function to create a client. `AppType` is passed as Generics and the server URL is specified as an argument.\n2. `client.{path}.{method}` is called and the data to be sent to the server is passed as an argument. In this case, `client.posts.$post` is making a POST request to the 'posts' path.\n\nThe response (`res`) is compatible with the 'fetch' Response, and data can be retrieved from it.\n\n### Important Notes\n\n- Ensure the server URL is correct when creating the client.\n- The data to be sent to the server should be in the correct format.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/)\n\n### Common Use Cases\n\n- Sending data to the server\n- Making POST requests",
      "ruleTitle": "Creating a Client and Making a POST Request in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to make a POST request using Hono and how to handle the response. It shows how to send data to the server and retrieve the response data. Understanding this is crucial for any server-client communication in web development using the Hono framework.",
      "ruleFile": "## Making a POST request and handling response in Hono\n\nThis guide demonstrates how to make a POST request using Hono and handle the response.\n\nHere is the code snippet:\n\n```ts\nconst res = await client.posts.$post({\n  form: {\n    title: 'Hello',\n    body: 'Hono is a cool project',\n  },\n})\n\nif (res.ok) {\n  const data = await res.json()\n  console.log(data.message)\n}\n```\n\n### How it works\n\n1. We make a POST request to the 'posts' endpoint using the `$post` method. The data we wish to send to the server is passed as an argument.\n2. The response (`res`) is compatible with the 'fetch' Response.\n3. We check if the response is ok (status code in the range 200-299).\n4. If the response is ok, we retrieve the data from the server using `res.json()`.\n\n### Important notes\n\n- Always check if the response is ok before trying to retrieve the data.\n\n### References\n\n- [Hono documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Sending data to the server and retrieving the response data.",
      "ruleTitle": "Making a POST request and handling response in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to explicitly specify the status code in Hono framework. This is crucial for client-server communication as it allows the server to inform the client about the status of the processed request.",
      "ruleFile": "## Specifying Status Code in Hono\n\nIn Hono, you can explicitly specify the status code, such as `200` or `404`, in `c.json()`. This status code will be added as a type for passing to the client. This is useful in scenarios where you want to inform the client about the status of the processed request.\n\n```text\n## Status code\n\nIf you explicitly specify the status code, such as `200` or `404`, in `c.json()`. It will be added as a type for passing to the client.\n```\n\n### How it works\n\nWhen you specify a status code in `c.json()`, Hono adds it as a type that can be passed to the client. This allows the client to understand the status of the processed request.\n\n### Important notes\n\n- Always ensure to specify the correct status code based on the result of the processed request.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Informing the client about the status of the processed request.",
      "ruleTitle": "Specifying Status Code in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle error responses in Hono. It shows how to return different HTTP status codes and response bodies depending on the result of the operation. This is a common pattern in web development where different status codes indicate different outcomes to the client.",
      "ruleFile": "## Handling Error Responses in Hono\n\nThis code snippet demonstrates how to handle error responses in Hono. It shows how to return different HTTP status codes and response bodies depending on the result of the operation.\n\n```ts\nif (post === undefined) {\n  return c.json({ error: 'not found' }, 404)\n}\n\nreturn c.json({ post }, 200)\n```\n\nIn this example, if the post is not found (i.e., `post === undefined`), a 404 status code along with an error message is returned. If the post is found, a 200 status code along with the post is returned.\n\n### How it works\n\nThe `c.json` function is used to send a JSON response. The first argument is the response body and the second argument is the HTTP status code.\n\n### Important notes\n\n- It's important to return appropriate HTTP status codes to indicate the result of the operation.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/)\n\n### Common use cases\n\n- Returning different responses based on the result of a database query.",
      "ruleTitle": "Handling Error Responses in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates the correct way to handle 'Not Found' responses in Hono. Using 'c.notFound()' can lead to incorrect inference of the data that the client gets from the server. This can lead to unexpected behavior and bugs in the application.",
      "ruleFile": "## Handling Not Found Responses in Hono\n\nIn Hono, it's important to handle 'Not Found' responses correctly. Using 'c.notFound()' can lead to incorrect inference of the data that the client gets from the server. This can lead to unexpected behavior and bugs in the application.\n\nHere's an example of how not to handle 'Not Found' responses:\n\n```ts\n## Not Found\n\nIf you want to use a client, you should not use `c.notFound()` for the Not Found response. The data that the client gets from the server cannot be inferred correctly.\n```\n\nInstead, you should handle 'Not Found' responses in a way that allows the client to correctly infer the data from the server.\n\n### How it Works\n\nWhen a 'Not Found' response is returned, the client needs to be able to correctly infer the data from the server. Using 'c.notFound()' can interfere with this process, leading to incorrect data inference.\n\n### Important Notes\n\nAlways handle 'Not Found' responses in a way that allows the client to correctly infer the data from the server.\n\n### References\n\n- Hono Documentation\n\n### Common Use Cases\n\n- Handling 'Not Found' responses in a web application built with Hono.",
      "ruleTitle": "Handling Not Found Responses in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle routes that include path parameters in Hono. It shows how to define a route with a path parameter and how to use the zValidator to validate the query parameters. This is a common pattern in web development where you need to handle dynamic routes and validate the incoming request parameters.",
      "ruleFile": "## Handling Routes with Path Parameters in Hono\n\nThis code snippet demonstrates how to handle routes that include path parameters in Hono.\n\n```ts\nconst route = app.get(\n  '/posts/:id',\n  zValidator(\n    'query',\n    z.object({\n      page: z.string().optional(),\n    })\n  ),\n  (c) => {\n    // ...\n    return c.json({\n      title: 'Night',\n```\n\n### How it works\n\n1. The `app.get` method is used to define a GET route.\n2. The route includes a path parameter `:id` which can be used to get a specific post.\n3. The `zValidator` function is used to validate the query parameters. In this case, it checks if the `page` query parameter is a string and is optional.\n\n### Important notes\n\n- The `zValidator` function is part of the zod library which is a runtime validation library.\n\n### References\n\n- [Hono Documentation](https://hono.bayfrontcloud.com/)\n\n### Common use cases\n\n- Fetching a specific resource based on the id from the URL.\n- Validating query parameters in the request.",
      "ruleTitle": "Handling Routes with Path Parameters in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to include a string in the path using the 'param' keyword in Hono. It also shows how to return a JSON object from a function. Understanding this rule is crucial for developers to manipulate URL parameters and handle responses in Hono.",
      "ruleFile": "## Including a String in the Path with 'param' and Returning a JSON Object\n\nThis code snippet demonstrates how to include a string in the path using the 'param' keyword and how to return a JSON object from a function in Hono.\n\n```ts\nSpecify the string you want to include in the path with `param`.\n\nconst res = await client.posts[':id'].$get({\n  param: {\n    id: '123',\n  },\n  query: {},\n})\n```\n\n### How it Works\n\nIn the above code, 'param' is used to specify the string that needs to be included in the path. The 'id' is set to '123', which will be included in the URL path. The '$get' function is then called to send a GET request to the server.\n\n### Important Notes\n\n- The 'param' keyword is used to include a string in the path.\n- The '$get' function is used to send a GET request to the server.\n\n### References\n\n- [Hono Documentation](https://hono.eclipse.org/documentation/)\n\n### Common Use Cases\n\n- When you need to include a specific string in the URL path.\n- When you need to return a JSON object from a function.",
      "ruleTitle": "Including a String in the Path with 'param' and Returning a JSON Object in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use parameters and headers in Hono client requests. Parameters are used to specify the string you want to include in the path, while headers can be appended to the request to provide additional information that the server needs to process the request.",
      "ruleFile": "## Using Parameters and Headers in Hono Client Requests\n\nIn Hono, you can specify the string you want to include in the path with `param`.\n\n```ts\nconst res = await client.posts[':id'].$get({\n  param: {\n    id: '123',\n  },\n  query: {},\n})\n```\n\nYou can also append headers to the request to provide additional information that the server needs to process the request.\n\n```ts\nconst res = await client.search.$get(\n  {\n    //...\n  },\n  {\n    headers: {\n      'X-Custom-Header': 'Here is Hono Client',\n      'X-User-Agent': 'hc',\n    },\n  }\n)\n```\n\n### How it Works\n\nIn the first code snippet, the `param` object is used to specify the string you want to include in the path. In this case, the `id` parameter is set to '123'.\n\nIn the second code snippet, the `headers` object is used to append headers to the request. Here, the 'X-Custom-Header' and 'X-User-Agent' headers are set to 'Here is Hono Client' and 'hc' respectively.\n\n### Important Notes\n\n- The `param` and `headers` objects are optional. If not provided, Hono will use the default values.\n- The `param` object should match the parameters defined in the path. If the parameters do not match, Hono will throw an error.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs)\n\n### Common Use Cases\n\n- Retrieving a specific post by its ID\n- Sending custom headers with a request",
      "ruleTitle": "Using Parameters and Headers in Hono Client Requests",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to add custom headers to all requests in Hono. Headers are often used to carry information for HTTP requests and responses. In this case, the headers are used for authentication and user agent identification. Understanding how to set these headers is crucial for secure and efficient communication between the client and server.",
      "ruleFile": "## Adding Custom Headers to All Requests in Hono\n\nThis code snippet demonstrates how to add custom headers to all requests in Hono.\n\n```ts\nconst client = hc<AppType>('/api', {\n  headers: {\n    Authorization: 'Bearer TOKEN',\n  }\n})\n```\n\nIn the above code, `hc` function is used to create a Hono client. The second argument to the `hc` function is an options object where we can specify common headers for all requests.\n\nIn this case, an `Authorization` header is added with a value of 'Bearer TOKEN'. This means that all requests made using this client will include this authorization token in their headers.\n\n### Important Notes\n\n- Headers are case-insensitive.\n- Not all headers can be set. Some are restricted because they are controlled by the user agent.\n\n### References\n\n- [Hono Documentation](https://hono.bryntum.com/docs/)\n\n### Common Use Cases\n\n- Adding authentication tokens to all requests.\n- Setting custom user-agent strings for all requests.",
      "ruleTitle": "Adding Custom Headers to All Requests in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to pass the fetch's `RequestInit` object to the request as the `init` option in Hono. This is a key feature of Hono that allows developers to customize the request with various options such as method, headers, body, mode, credentials, cache, redirect, referrer, integrity, and keepalive.",
      "ruleFile": "## Using the `init` option in Hono\n\nIn Hono, you can pass the fetch's `RequestInit` object to the request as the `init` option. This allows you to customize the request with various options such as method, headers, body, mode, credentials, cache, redirect, referrer, integrity, and keepalive.\n\n```ts\n## `init` option\n\nYou can pass the fetch's `RequestInit` object to the request as the `init` option. Below is an example of aborting a Request.\n```\n\n### How it works\n\nThe `init` option is passed as an argument to the Hono client function. The `RequestInit` object is a built-in fetch API object that allows you to customize the request.\n\n### Important notes\n\n- The `init` option is optional. If not provided, Hono will use the default fetch options.\n\n### References\n\n- [Fetch API - RequestInit](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request)\n\n### Common use cases\n\n- Aborting a request\n- Customizing request headers\n- Sending a request with credentials",
      "ruleTitle": "Using the `init` option to customize requests in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `RequestInit` object and the `$url()` method in Hono. The `RequestInit` object allows users to overwrite default settings such as `body`, `method`, and `headers`. The `$url()` method is used to access the endpoint URL, but it requires an absolute URL to function correctly.",
      "ruleFile": "## Using RequestInit Object and $url() Method in Hono\n\nIn Hono, the `RequestInit` object defined by `init` takes the highest priority. It can be used to overwrite things set by other options like `body`, `method`, and `headers`.\n\n```ts\nclient.api.posts.$post(\n  {\n    json: {\n      // Request body\n    },\n  },\n  {\n    // RequestInit object\n    init: {\n      signal: abortController.signal,\n    },\n  }\n)\n\n// ...\n\nabortController.abort()\n```\n\nYou can get a `URL` object for accessing the endpoint by using `$url()`. However, you must pass in an absolute URL for this to work. Passing in a relative URL `/` will result in an error.\n\n```ts\n// âŒ Will throw error\nconst client = hc<AppType>('/')\nclient.api.post.$url()\n\n// âœ… Will work as expected\nconst client = hc<AppType>('http://localhost:8787/')\nclient.api.post.$url()\n```\n\n### Important Notes\n\n- Always use an absolute URL with the `$url()` method to avoid errors.\n- The `RequestInit` object can be used to overwrite default settings, providing flexibility in request configuration.\n\n### References\n\n- [Hono Documentation](https://hono.bike/#/)\n\n### Common Use Cases\n\n- Overwriting default request settings with the `RequestInit` object.\n- Accessing the endpoint URL using the `$url()` method.",
      "ruleTitle": "Using RequestInit Object and $url() Method in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to upload files using a form body in Hono. Understanding this rule is crucial for developers to handle file uploads in their applications.",
      "ruleFile": "## File Uploads in Hono\n\nIn Hono, you can upload files using a form body. This is demonstrated in the following code snippet:\n\n```ts\n// client\nconst res = await client.user.picture.$put({\n  form: {\n    file: new File([fileToUpload], filename, { type: fileToUpload.type })\n  },\n});\n```\n\nHow it works:\n\n1. The `$put` method is used to send a PUT request to the server.\n2. The `form` object is used to send form data. In this case, it's a file.\n3. The `File` constructor is used to create a new File object from the given fileToUpload, filename, and file type.\n\nImportant notes:\n\n- Ensure that the fileToUpload, filename, and file type are correctly defined.\n\nReferences:\n\n- [Hono Documentation](https://hono.bevry.me/)\n\nCommon use cases:\n\n- Uploading profile pictures\n- Uploading documents\n- Uploading media files",
      "ruleTitle": "Uploading Files Using a Form Body in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set a custom `fetch` method in Hono. This is useful in scenarios where the default `fetch` method may not be suitable or needs to be overridden for specific use cases, such as in a Cloudflare Worker environment.",
      "ruleFile": "## Custom `fetch` method in Hono\n\nIn Hono, you can set a custom `fetch` method. This is particularly useful when the default `fetch` method is not suitable or needs to be overridden for specific use cases. For instance, in a Cloudflare Worker environment, you might want to use the Service Bindings' `fetch` method instead of the default one.\n\nHere is an example of how to do this:\n\n```toml\n# wrangler.toml\nservices = [\n  { binding = \"AUTH\", service = \"auth-service\" },\n]\n```\n\n```ts\n// src/client.ts\nconst client = hc<CreateProfileType>('/', {\n  fetch: c.env.AUTH.fetch.bind(c.env.AUTH)\n```\n\nIn this example, the `fetch` method from the `AUTH` service binding is used instead of the default `fetch` method.\n\n### Important notes\n\n- The custom `fetch` method should be compatible with the Fetch API.\n- Be careful when binding the context (`this`) of the `fetch` method, as it might have unintended side effects if not done correctly.\n\n### References\n\n- [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\n\n### Common use cases\n\n- Overriding the default `fetch` method in a Cloudflare Worker environment.",
      "ruleTitle": "Setting a Custom `fetch` Method in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the InferRequestType and InferResponseType in Hono to understand the type of object to be requested and the type of object to be returned. This is crucial in ensuring type safety and predictability in your code.",
      "ruleFile": "## Using InferRequestType and InferResponseType in Hono\n\nIn Hono, you can use `InferRequestType` and `InferResponseType` to understand the type of object to be requested and the type of object to be returned. This is crucial in ensuring type safety and predictability in your code.\n\nHere is a code snippet demonstrating this:\n\n```ts\nimport type { InferRequestType, InferResponseType } from 'hono/client'\n\n// InferRequestType\nconst $post = client.todo.$post\ntype ReqType = InferRequestType<typeof $post>['form']\n\n// InferResponseType\n```\n\nIn this code snippet, `InferRequestType` is used to infer the type of the request object for a POST request. Similarly, `InferResponseType` can be used to infer the type of the response object.\n\nThis is particularly useful when you want to ensure that your code is type-safe and predictable, as it allows you to know exactly what type of object you are dealing with.\n\nReferences:\n- [Hono Documentation](https://hono.bike/docs/client/)\n\nCommon use cases:\n- When you want to ensure type safety in your code\n- When you want to understand the type of object you are dealing with",
      "ruleTitle": "Using InferRequestType and InferResponseType in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the SWR library with the Hono framework. SWR is a React Hooks library for remote data fetching. The rule shows how to import the SWR library and use it in a Hono application. This is a common pattern when dealing with data fetching in a React application using the Hono framework.",
      "ruleFile": "## Using SWR with Hono\n\nThis guide demonstrates how to use the SWR library with the Hono framework. SWR is a React Hooks library for remote data fetching.\n\nHere is the code snippet:\n\n```tsx\nimport useSWR from 'swr'\nimport { hc } from 'hono/client'\nimport type { InferRequestType } from 'hono/client'\nimport type { AppType } from '../functions/api/[[route]]'\n\nconst App = () => {\n  const\n```\n\n### How it works\n\n1. First, import the `useSWR` function from the SWR library.\n2. Then, import the `hc` object from the 'hono/client' module.\n3. Import the `InferRequestType` type from the 'hono/client' module.\n4. Import the `AppType` type from the '../functions/api/[[route]]' module.\n5. Finally, use these imports in your React component.\n\n### Important notes\n\n- The SWR library is not included with Hono, so you need to install it separately.\n\n### References\n\n- [SWR Documentation](https://swr.vercel.app)\n\n### Common use cases\n\n- Fetching data from a remote source in a React application using the Hono framework.",
      "ruleTitle": "Using SWR with Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use RPC (Remote Procedure Call) in larger applications with Hono. It emphasizes the importance of type inference and how to maintain it by chaining handlers. This is crucial in larger applications to ensure consistency and avoid potential type-related errors.",
      "ruleFile": "## Using RPC with Larger Applications in Hono\n\nWhen working with larger applications in Hono, it's important to be careful about type inference. To ensure that types are always correctly inferred, you can chain the handlers. This approach helps to maintain consistency and avoid potential type-related errors.\n\nHere is a code snippet demonstrating this:\n\n```ts\n// authors.ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n  .get('/', (c) => c.json('list authors'))\n  .post('/', (c) => c.json('create an author', 201))\n  .get('/:id', (c) => c.json(`get author ${c.params.id}`))\n```\n\nIn this example, the handlers for GET and POST requests are chained together. This ensures that the types are always inferred correctly.\n\n### Important Notes\n\n- Always chain handlers in larger applications to ensure correct type inference.\n\n### References\n\n- [Building a larger application](/docs/guides/best-practices#building-a-larger-application)\n\n### Common Use Cases\n\n- Building larger applications with Hono\n- Ensuring correct type inference in larger applications",
      "ruleTitle": "Chaining Handlers for Correct Type Inference in Larger Applications with Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes and sub-routes in a Hono application. It shows how to use the 'get' and 'post' methods to handle HTTP GET and POST requests respectively, and how to use route parameters. It also shows how to chain route handlers and how to import and use sub-routers.",
      "ruleFile": "## Defining Routes and Sub-routes in Hono\n\nThis code snippet demonstrates how to define routes and sub-routes in a Hono application.\n\n```javascript\nconst app = new Hono()\n  .get('/', (c) => c.json('list books'))\n  .post('/', (c) => c.json('create a book', 201))\n  .get('/:id', (c) => c.json(`get ${c.req.param('id')}`))\n\nexport default app\n```\n\nIn this example, the 'get' and 'post' methods are used to handle HTTP GET and POST requests respectively. The route parameter ':id' is used to get the id from the request URL.\n\nSub-routers can be imported and used as shown below:\n\n```javascript\nimport { Hono } from 'hono'\nimport authors from './authors'\nimport books from './books'\n\nconst app = new Hono()\n\nconst routes = app.route('/authors', authors).route('/books', books)\n```\n\nHere, the 'route' method is used to define sub-routes for authors and books. The route handlers for these sub-routes are chained using the '.' operator.\n\n### Important Notes\n\n- Make sure to chain the route handlers for the top level of the app.\n- Export the app after defining all the routes.\n\n### References\n\n- [Hono documentation](https://hono.bike/)\n\n### Common Use Cases\n\n- Defining routes for different resources in a web application.",
      "ruleTitle": "Defining Routes and Sub-routes in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it highlights the performance implications of using RPC with Hono and how the number of routes can impact the IDE performance. It demonstrates how Hono infers the type of your app based on the routes and the potential performance issues that can arise due to massive amounts of type instantiations.",
      "ruleFile": "## Hono RPC Performance Considerations\n\nWhen using RPC with Hono, the number of routes can impact the performance of your IDE. This is due to the fact that Hono executes a large number of type instantiations to infer the type of your app based on the routes.\n\nHere is an example of how Hono infers the type of your app:\n\n```ts\n// app.ts\nexport const app = new Hono().get('foo/:id', (c) =>\n  c.json({ ok: true }, 200)\n)\n```\n\nHono will infer the type as follows:\n\n```ts\nexport const app = Hono<BlankEnv, BlankSchema, '/'>().get\n```\n\n### Important Notes\n\nThe more routes you have, the slower your IDE will become. Therefore, it's important to consider the number of routes in your app and the potential performance implications.\n\n### References\n\n- Hono Documentation\n\n### Common Use Cases\n\n- Building a web app with multiple routes using Hono\n- Using RPC with Hono",
      "ruleTitle": "Understanding Performance Implications of RPC with Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how Hono infers the type of your application based on the route. Understanding this inference mechanism is crucial for developers to ensure that they are defining their routes correctly and that the application behaves as expected.",
      "ruleFile": "## Hono Type Inference Based on Route\n\nIn Hono, the type of your application is inferred based on the route. For example, if your application has a route like this:\n\n```ts\n// app.ts\nexport const app = new Hono().get('foo/:id', (c) =>\n  c.json({ ok: true }, 200)\n)\n```\n\nHono will infer the type as follows:\n\n```ts\nexport const app = Hono<BlankEnv, BlankSchema, '/'>().get<\n  'foo/:id',\n  'foo/:id',\n  JSONRespondReturn<{ ok: boolean }, 200>,\n  BlankInput,\n  BlankEnv\n>('foo/:id', (c) => c.json({ ok: true }, 200)\n```\n\n### How it works\n\nHono uses the route definition to infer the type of the application. This type inference is based on the parameters and return type of the route handler function.\n\n### Important notes\n\n- The type inference is based on the route definition, so it's important to define your routes correctly.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs)\n\n### Common use cases\n\n- Defining routes in a Hono application\n- Understanding how Hono infers the type of your application",
      "ruleTitle": "Hono Type Inference Based on Route",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle type instantiation in Hono, which can be time-consuming and slow down your IDE if not managed properly. It also provides tips on how to mitigate this issue, such as ensuring Hono versions match between backend and frontend, using TypeScript project references, and compiling your code before using it.",
      "ruleFile": "## Handling Type Instantiation in Hono\n\nType instantiation in Hono can be time-consuming and slow down your IDE. This is especially true when you have a lot of routes. However, there are ways to mitigate this issue.\n\n### Code Snippet\n\n```typescript\nexport const app = Hono<BlankEnv, BlankSchema, '/'>().get<\n  'foo/:id',\n  'foo/:id',\n  JSONRespondReturn<{ ok: boolean }, 200>,\n  BlankInput,\n  BlankEnv\n>('foo/:id', (c) => c.json({ ok: true }, 200))\n```\n\n### How it Works\n\nThe code snippet is a type instantiation for a single route. While the user doesn't need to write these type arguments manually, `tsserver` in your IDE does this time-consuming task every time you use the app.\n\n### Important Notes\n\n1. **Hono version mismatch**: If your backend is separate from the frontend and lives in a different directory, ensure that the Hono versions match. Using different Hono versions can lead to issues such as '_Type instantiation is excessively deep and possibly infinite_'.\n\n2. **TypeScript project references**: If your backend and frontend are separate and you want to access code from the backend on the frontend, use TypeScript's project references. This allows one TypeScript codebase to access and use code from another TypeScript codebase.\n\n3. **Compile your code before using it**: `tsc` can do heavy tasks like type instantiation at compile time, making your IDE faster. Compiling your client including the server app gives you the best performance.\n\n### References\n\n- [Hono RPC And TypeScript Project References](https://catalins.tech/hono-rpc-in-monorepos/)\n- [TypeScript Project References](https://www.typescriptlang.org/docs/handbook/project-references.html)\n\n### Common Use Cases\n\nThis rule is commonly used in large projects with many routes, where type instantiation can significantly slow down the IDE.",
      "ruleTitle": "Handling Type Instantiation in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'hcWithType' function instead of 'hc' to get the client with the type already calculated in Hono. This is a best practice in Hono framework usage as it simplifies the process of getting the client and improves code readability.",
      "ruleFile": "## Using hcWithType instead of hc in Hono\n\nThis guide demonstrates how to use the 'hcWithType' function instead of 'hc' to get the client with the type already calculated in Hono. This is a best practice in Hono framework usage as it simplifies the process of getting the client and improves code readability.\n\nHere is the code snippet:\n\n```ts\nconst client = hc<typeof app>('')\nexport type Client = typeof client\n\nexport const hcWithType = (...args: Parameters<typeof hc>): Client =>\n  hc<typeof app>(...args)\n```\n\nAfter compiling, you can use `hcWithType` instead of `hc` to get the client with the type already calculated.\n\n```ts\nconst client = hcWithType('http://localhost:8787/')\nconst res = await client.posts.$post({\n  form: {\n    title: 'Hello',\n    body: 'Hono is a cool project',\n  },\n})\n```\n\n### How it works\n\nThe 'hcWithType' function takes the same parameters as 'hc' and returns a client with the type already calculated. This simplifies the process of getting the client and improves code readability.\n\n### Important notes\n\n- The 'hcWithType' function is a best practice in Hono framework usage.\n\n### References\n\n- [Hono Documentation](https://hono.beeceptor.com)\n\n### Common use cases\n\n- When you need to get the client with the type already calculated in Hono.",
      "ruleTitle": "Using hcWithType instead of hc to get the client with the type already calculated in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to manage dependencies in a monorepo project using Hono. It also shows how to manually specify type arguments to avoid type instantiation, which can be beneficial for performance.",
      "ruleFile": "## Managing Dependencies in a Monorepo and Specifying Type Arguments Manually\n\nIn a monorepo project, you can use a tool like `turborepo` to easily separate the server project and the client project and manage dependencies between them. This can lead to better integration. Here is a working example: [Hono RPC Performance Tips Example](https://github.com/m-shaka/hono-rpc-perf-tips-example).\n\nYou can also coordinate your build process manually with tools like `concurrently` or `npm-run-all`.\n\n```text\nIf your project is a monorepo, this solution does fit well. Using a tool like [`turborepo`](https://turbo.build/repo/docs), you can easily separate the server project and the client project and get better integration managing dependencies between them. Here is [a working example](https://github.com/m-shaka/hono-rpc-perf-tips-example).\n\nYou can also coordinate your build process manually with tools like `concurrently` or `npm-run-all`.\n```\n\nIn Hono, you can specify type arguments manually to avoid type instantiation. This can be a bit cumbersome, but it can make a difference in performance.\n\n```ts\nconst app = new Hono().get<'foo/:id'>('foo/:id', (c) =>\n  c.json({ ok: true }, 200)\n)\n```\n\n### References\n\n- [TurboRepo Documentation](https://turbo.build/repo/docs)\n- [Hono RPC Performance Tips Example](https://github.com/m-shaka/hono-rpc-perf-tips-example)",
      "ruleTitle": "Managing Dependencies in a Monorepo and Specifying Type Arguments Manually in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to improve performance in Hono by specifying a single type argument. It also shows how to structure larger applications by splitting the app and client into multiple files. This can make the code more manageable and easier to understand.",
      "ruleFile": "## Specifying Single Type Argument and Splitting App and Client into Multiple Files\n\nThis code demonstrates how to specify a single type argument in Hono to improve performance. It also shows how to split your app and client into multiple files for better code organization and manageability.\n\n```text\nSpecifying just single type argument make a difference in performance, while it may take you a lot of time and effort if you have a lot of routes.\n\n#### Split your app and client into multiple files\n\nAs described in [Using RPC with larger applications](#using-rpc-with-larger-applications), you can split your app into multiple apps. You can also create a client for each app:\n```\n\n### How it works\n\n1. Specify a single type argument when defining routes in Hono. This can improve performance.\n2. Split your app into multiple apps and create a client for each app. This can make the code more manageable and easier to understand.\n\n### Important notes\n\n- Specifying a single type argument can improve performance but may require more time and effort if you have many routes.\n- Splitting your app and client into multiple files can make the code more manageable but requires careful organization.\n\n### References\n\n- [Using RPC with larger applications](#using-rpc-with-larger-applications)\n\n### Common use cases\n\n- Large applications with many routes\n- Applications where performance is a concern",
      "ruleTitle": "Improving Performance by Specifying Single Type Argument and Splitting App and Client into Multiple Files in Hono",
      "sourcePath": "docs/guides/rpc.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the Cookie helper in Hono to get and set cookies. Cookies are often used in web development for session management, personalization, and tracking user behavior.",
      "ruleFile": "## Using the Cookie Helper in Hono\n\nThe following code snippet demonstrates how to use the Cookie helper in Hono to get and set cookies.\n\n```ts\nimport { getCookie, setCookie } from 'hono/cookie'\n\nconst app = new Hono()\n\napp.get('/cookie', (c) => {\n  const yummyCookie = getCookie(c, 'yummy_cookie')\n  // ...\n  setCookie(c, 'delicious_cookie', 'macha')\n  //\n})\n```\n\n### How it works\n\n1. First, the `getCookie` and `setCookie` functions are imported from `hono/cookie`.\n2. A new Hono application is created.\n3. A GET route '/cookie' is defined. In the callback function for this route, the `getCookie` function is used to retrieve a cookie named 'yummy_cookie'. The `setCookie` function is then used to set a cookie named 'delicious_cookie' with the value 'macha'.\n\n### Important notes\n\n- The `getCookie` function takes two arguments: the context object `c` and the name of the cookie.\n- The `setCookie` function takes three arguments: the context object `c`, the name of the cookie, and the value of the cookie.\n\n### References\n\n- [Hono Cookie Helper Documentation](/docs/helpers/cookie)\n\n### Common use cases\n\n- Retrieving user preferences stored in cookies\n- Setting session cookies for user authentication",
      "ruleTitle": "Using the Cookie Helper in Hono",
      "sourcePath": "docs/guides/helpers.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the validator module from the Hono framework. The validator module is crucial for validating incoming values in applications, ensuring data integrity and preventing potential issues related to incorrect or malicious data.",
      "ruleFile": "## Importing and Using Validator from Hono Framework\n\nThis guide demonstrates how to import and use the validator module from the Hono framework. The validator module is used to validate incoming values in applications.\n\nHere is the code snippet:\n\n```ts\nimport { validator } from 'hono/validator'\n```\n\n### How it works\n\n1. The `import` statement is used to import the `validator` module from the `hono/validator` package.\n\n### Important notes\n\n- The `validator` module should be imported at the beginning of your script, before it's used.\n\n### References\n\n- [Hono Documentation](https://hono.bosch.io/docs/)\n\n### Common use cases\n\n- Validating form data: You can use the `validator` module to validate form data, ensuring that the data entered by users is in the correct format and preventing potential issues related to incorrect data.",
      "ruleTitle": "Importing and Using Validator from Hono Framework",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'validator' middleware in Hono to validate form data in a POST request. This is a common requirement in web applications where user input needs to be validated before processing. The rule also shows how to access the validated data within the request handler.",
      "ruleFile": "## Hono Form Validation with Validator Middleware\n\nThis code snippet demonstrates how to use the 'validator' middleware in Hono to validate form data in a POST request.\n\n```ts\napp.post(\n  '/posts',\n  validator('form', (value, c) => {\n    const body = value['body']\n    if (!body || typeof body !== 'string') {\n      return c.text('Invalid!', 400)\n    }\n    return {\n      body: body,\n    }\n  }),\n  //...\n```\n\nIn the above code, 'validator' is used as a middleware for the POST '/posts' route. The first argument to 'validator' is 'form', indicating that the data to be validated is form data. The second argument is a callback function that takes the form data and a context object 'c'. The function checks if the 'body' field of the form data is a string and if it's not, it returns a 400 response with the text 'Invalid!'. If the 'body' is valid, it returns an object with the 'body'.\n\nWithin the request handler, the validated data can be accessed using `c.req.valid('form')`.\n\n### Important Notes\n\n- The 'validator' middleware is a powerful tool for validating user input in Hono. It should be used whenever user input needs to be validated.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/)\n\n### Common Use Cases\n\n- Validating form data in POST requests\n- Returning custom error responses for invalid data",
      "ruleTitle": "Form Validation with Validator Middleware in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to validate and extract data from a request in the Hono framework. It shows how to use the 'valid' method to validate and extract data from different parts of the request such as 'json', 'query', 'header', 'param', 'cookie' and 'form'. It also highlights the importance of setting the correct 'Content-Type' when validating 'json'.",
      "ruleFile": "## Hono Request Validation and Data Extraction\n\nThis code snippet demonstrates how to validate and extract data from a request in the Hono framework.\n\n```ts\n, (c) => {\n  const { body } = c.req.valid('form')\n  // ... do something\n  return c.json(\n    {\n      message: 'Created!',\n    },\n    201\n  )\n}\n```\n\nIn this example, the 'valid' method is used to validate and extract data from the 'form' part of the request. The validated data is then used in the handler.\n\nValidation targets can include 'json', 'query', 'header', 'param', 'cookie' in addition to 'form'. When validating 'json', it is important to ensure that the request contains a 'Content-Type: application/json'.\n\n### Important Notes\n\n- Always validate and sanitize data from the request before using it.\n- Ensure the correct 'Content-Type' is set when validating 'json'.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common Use Cases\n\n- Validating and extracting data from the request in a POST or PUT API endpoint.",
      "ruleTitle": "Validating and Extracting Data from a Request in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to correctly use the 'validator' middleware in Hono to validate and parse incoming request bodies. It also shows the importance of setting the 'content-type' header in the request, as without it, the request body will not be parsed and a warning will be issued.",
      "ruleFile": "## Setting Content-Type Header and Using Validator Middleware in Hono\n\nIn Hono, it's important to set the `content-type` header when testing using `app.request()`. Without it, the request body will not be parsed and a warning will be issued.\n\nHere is an example of how to use the 'validator' middleware to validate and parse incoming request bodies.\n\n```ts\nconst app = new Hono()\napp.post(\n  '/testing',\n  validator('json', (value, c) => {\n    // pass-through validator\n    return value\n  }),\n  (c) => {\n    const body = c.req.valid('json')\n    return c.json(body)\n  }\n)\n```\n\nIn this code, a POST route '/testing' is defined. The 'validator' middleware is used to validate and parse the request body as JSON. The validated and parsed body is then returned in the response.\n\n### Important Notes\n\n- Always set the 'content-type' header in your requests when testing using `app.request()`.\n- The 'validator' middleware is a powerful tool for validating and parsing request bodies in Hono.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common Use Cases\n\n- Validating and parsing request bodies in API endpoints.",
      "ruleTitle": "Setting Content-Type Header and Using Validator Middleware in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to correctly validate and handle JSON data in Hono. It also shows the importance of setting the correct 'Content-Type' header when sending a request, and the need to use lowercase keys when validating headers.",
      "ruleFile": "## Rule File\n\nThis rule demonstrates how to correctly validate and handle JSON data in Hono. It also shows the importance of setting the correct 'Content-Type' header when sending a request, and the need to use lowercase keys when validating headers.\n\n### Code Snippet\n\n```ts\nr('json', (value, c) => {\n    // pass-through validator\n    return value\n  }),\n  (c) => {\n    const body = c.req.valid('json')\n    return c.json(body)\n  }\n)\n```\n\n### How it Works\n\nThe code first defines a pass-through validator for JSON data. Then, it uses this validator to validate the JSON data in the request body. If the 'Content-Type' header is not set to 'application/json', the validation will fail.\n\n### Important Notes\n\nWhen validating headers, you need to use lowercase keys. For example, to validate the 'Idempotency-Key' header, you need to use 'idempotency-key' as the key.\n\n### References\n\n- Hono Documentation\n\n### Common Use Cases\n\n- Validating JSON data in a request\n- Sending a request with a specific 'Content-Type' header\n- Validating headers in a request",
      "ruleTitle": "Validating JSON Data and Headers in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates the correct way to validate headers in Hono. It shows that when validating headers, the key should be in lowercase. Using a non-lowercase key will result in an undefined value, leading to unexpected behavior.",
      "ruleFile": "## Rule: Always Use Lowercase for Header Key in Validation\n\nWhen validating headers in Hono, always use lowercase for the header key. This is because Hono converts all header keys to lowercase. If you use a non-lowercase key, it will result in an undefined value, leading to unexpected behavior.\n\nHere is an example of how to correctly validate the `Idempotency-Key` header:\n\n```ts\n// âŒ this will not work\napp.post(\n  '/api',\n  validator('header', (value, c) => {\n    // idempotencyKey is always undefined\n    // so this middleware always return 400 as not expected\n    const idempotencyKey = value['Idempotency-Key']\n\n    if (idempotencyKey == undefined || idempotencyKey === '') {\n      throw HTTPException(400, {\n        message: 'Idempotency-Key is required',\n      })\n    }\n    return { idempotencyKey }\n  }),\n  (c) => {\n    const { idempotencyKey } = c.req.valid('header')\n    // ...\n  }\n)\n\n// âœ… this will work\napp.post(\n  '/api',\n  validator('header', (value, c) => {\n    // can retrieve the value of the header as expected\n    const idempotencyKey = value['idempotency-key']\n\n    if (idempotencyKey == undefined || idempotencyKey === '') {\n      throw HTTPException(400, {\n        message: 'Idempotency-Key is required',\n      })\n    }\n    return { idempotencyKey }\n  }),\n  (c) => {\n    const { idempotencyKey } = c.req.valid('header')\n    // ...\n  }\n)\n```\n\n### How it works\n\nIn the incorrect example, `Idempotency-Key` is used as the key, which results in an undefined value because Hono converts all header keys to lowercase. In the correct example, `idempotency-key` is used as the key, which allows the value of the header to be retrieved as expected.\n\n### Important notes\n\nAlways use lowercase for header keys when validating headers in Hono.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/guides/validation/)\n\n### Common use cases\n\nThis rule is commonly used when validating headers in Hono.",
      "ruleTitle": "Always Use Lowercase for Header Key in Validation",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use multiple validators in Hono to validate different parts of a request. It also shows how to integrate third-party validators like Zod into the Hono framework. This is essential for ensuring that the data being received in the request is valid and as expected, thereby preventing potential errors or security vulnerabilities.",
      "ruleFile": "## Using Multiple Validators and Third-Party Validators in Hono\n\nIn Hono, you can use multiple validators to validate different parts of a request. This is useful when you want to ensure that all parts of the request, such as parameters, query strings, and JSON body, are valid.\n\nHere is an example of how to use multiple validators:\n\n```ts\napp.post(\n  '/posts/:id',\n  validator('param', ...),\n  validator('query', ...),\n  validator('json', ...),\n  (c) => {\n    //...\n  }\n```\n\nHono also supports the use of third-party validators like Zod. To use Zod, you need to install it from the Npm registry:\n\n```sh [npm]\nnpm i zod\n```\n\nThen you can use it in your Hono application as follows:\n\n```ts\napp.post(\n  '/posts/:id',\n  validator('param', ...),\n  validator('query', ...),\n  validator('json', ...),\n  (c) => {\n    //...\n  }\n```\n\n### Important Notes\n\n- Always validate the data you receive in requests to prevent potential errors or security vulnerabilities.\n- You can use any third-party validator that you prefer. Zod is just one of the many options available.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n- [Zod Documentation](https://zod.dev)\n\n### Common Use Cases\n\n- Validating user input in a form submission\n- Checking the validity of parameters in a URL\n- Ensuring the JSON body of a request is as expected",
      "ruleTitle": "Using Multiple Validators and Third-Party Validators in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use a third-party validator, Zod, for data validation in Hono. It shows how to install Zod using different package managers, import it into your project, and define a schema for validation. This is a common practice in web development to ensure that the data being processed meets certain criteria, thereby preventing potential errors and security vulnerabilities.",
      "ruleFile": "## Installing and Using Zod for Data Validation in Hono\n\nThis guide demonstrates how to install Zod, a third-party data validation library, and use it in a Hono project.\n\nFirst, install Zod from the Npm registry using your preferred package manager:\n\n```sh\nnpm i zod\n```\n\n```sh\nyarn add zod\n```\n\n```sh\npnpm add zod\n```\n\n```sh\nbun add zod\n```\n\nNext, import `z` from `zod` in your project:\n\n```ts\nimport { z } from 'zod'\n```\n\nThen, define your schema for validation:\n\n```ts\nconst schema = z.object({\n  body: z.string(),\n})\n```\n\nYou can use this schema in the callback function for validation and return the validated data.\n\n### Important Notes\n\n- Zod is a powerful and flexible library for data validation, but there are many others available. Choose the one that best fits your project's needs.\n\n### References\n\n- [Zod Documentation](https://github.com/colinhacks/zod)\n\n### Common Use Cases\n\n- Validating user input in a form\n- Checking the format of data received from an API",
      "ruleTitle": "Installing and Using Zod for Data Validation in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the Zod library for schema validation in Hono. Schema validation is a crucial part of any application as it ensures that the data being processed adheres to a certain structure, thus preventing potential errors or security vulnerabilities.",
      "ruleFile": "## Zod Schema Validation in Hono\n\nThis guide demonstrates how to use the Zod library for schema validation in Hono.\n\nFirst, install the Zod library using your preferred package manager:\n\n```sh\nnpm i zod\n```\n\nor\n\n```sh\nyarn add zod\n```\n\nor\n\n```sh\npnpm add zod\n```\n\nor\n\n```sh\nbun add zod\n```\n\nNext, import `z` from `zod`:\n\n```ts\nimport { z } from 'zod'\n```\n\nThen, write your schema:\n\n```ts\nconst schema = z.object({\n  body: z.string(),\n})\n```\n\nYou can use the schema in the callback function for validation and return the validated value.\n\n```ts\nconst route = app.post(\n  '/posts',\n  val\n```\n\n### How it works\n\nZod is a library for creating schemas that can be used to validate JavaScript and TypeScript data. In this example, we create a schema for a post object that has a `body` property of type `string`.\n\n### Important notes\n\n- Zod is a zero-dependency library, meaning it doesn't require any other packages to work.\n\n### References\n\n- [Zod Documentation](https://github.com/colinhacks/zod)\n\n### Common use cases\n\n- Validating API request bodies\n- Validating data before saving it to a database",
      "ruleTitle": "Using Zod for Schema Validation in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the zod library for input validation in Hono. It shows how to define a schema and use it to validate incoming data in a route handler. This is a common pattern in web development to ensure that the data received from the client meets certain criteria before it is processed.",
      "ruleFile": "## Rule: Using Zod for Input Validation in Hono\n\nThis rule demonstrates how to use the zod library for input validation in Hono. Zod is a JavaScript library for building schemas and validating data.\n\nFirst, you need to install zod using either pnpm or bun:\n\n```sh\npnpm add zod\n```\n\nor\n\n```sh\nbun add zod\n```\n\nThen, you can import zod in your code:\n\n```ts\nimport { z } from 'zod'\n```\n\nYou can define a schema for the data you want to validate. In this example, we define a schema for an object with a string property named 'body':\n\n```ts\nconst schema = z.object({\n  body: z.string(),\n})\n```\n\nYou can use the schema to validate the data in the route handler. If the data does not match the schema, a 401 response is returned:\n\n```ts\nconst route = app.post(\n  '/posts',\n  validator('form', (value, c) => {\n    const parsed = schema.safeParse(value)\n    if (!parsed.success) {\n      return c.text('Invalid!', 401)\n    }\n    return parsed.data\n  })\n)\n```\n\n### Important notes\n\n- Zod provides a variety of methods to define complex schemas.\n- The 'safeParse' method is used to validate the data. It returns an object with a 'success' property that indicates whether the validation was successful.\n\n### References\n\n- [Zod documentation](https://github.com/colinhacks/zod)\n\n### Common use cases\n\n- Validating user input in form submissions\n- Validating API request payloads",
      "ruleTitle": "Using Zod for Input Validation in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the Zod Validator Middleware in the Hono framework. The Zod Validator Middleware is a tool that simplifies the process of validating data in Hono applications. This rule shows how to install and import the middleware, which is a common pattern in Hono framework usage.",
      "ruleFile": "## Using Zod Validator Middleware in Hono\n\nThe following code snippet shows how to use the Zod Validator Middleware in the Hono framework.\n\n```sh\nnpm i @hono/zod-validator\n```\n\n```sh\nyarn add @hono/zod-validator\n```\n\n```sh\npnpm add @hono/zod-validator\n```\n\n```sh\nbun add @hono/zod-validator\n```\n\nAfter installing the middleware, you can import it into your application.\n\nThis middleware simplifies the process of validating data in Hono applications. It provides a set of tools for validating data of various types and formats.\n\n### Important Notes\n\n- The Zod Validator Middleware is a third-party package, and you need to install it separately.\n\n### References\n\n- [Zod Validator Middleware](https://github.com/honojs/middleware/tree/main/packages/zod-validator)\n\n### Common Use Cases\n\n- Validating form data in a Hono application.\n- Validating API request data in a Hono application.",
      "ruleTitle": "Using Zod Validator Middleware in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to install and use the zod-validator package in Hono. The zod-validator is used for data validation, ensuring that the data received in the request matches the expected format. This is crucial for maintaining data integrity and preventing potential errors or security vulnerabilities.",
      "ruleFile": "## Installing and Using zod-validator in Hono\n\nThe `@hono/zod-validator` package is used for data validation in Hono. It ensures that the data received in the request matches the expected format. This is crucial for maintaining data integrity and preventing potential errors or security vulnerabilities.\n\nFirst, install the package using npm, yarn, pnpm, or bun:\n\n```sh\nnpm i @hono/zod-validator\n```\n\n```sh\nyarn add @hono/zod-validator\n```\n\n```sh\npnpm add @hono/zod-validator\n```\n\n```sh\nbun add @hono/zod-validator\n```\n\nThen, import `zValidator` from the package:\n\n```ts\nimport { zValidator } from '@hono/zod-validator'\n```\n\nYou can then use `zValidator` in your routes to validate the request data. For example, to validate that the `body` field of a POST request is a string:\n\n```ts\nconst route = app.post(\n  '/posts',\n  zValidator(\n    'form',\n    z.object({\n      body: z.string(),\n    })\n  ),\n```\n\n### Important Notes\n\n- Always validate your request data to maintain data integrity and prevent potential errors or security vulnerabilities.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/)\n\n### Common Use Cases\n\n- Validating request data in a POST route.",
      "ruleTitle": "Installing and Using zod-validator in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the zod-validator in Hono framework for data validation. It shows how to install the zod-validator, import it into your project, and use it to validate incoming data in a POST request. This is crucial for ensuring data integrity and preventing invalid or malicious data from being processed by your application.",
      "ruleFile": "## Installing and Using zod-validator in Hono\n\nFirst, install the zod-validator package using either pnpm or bun:\n\n```sh\npnpm add @hono/zod-validator\n```\n\nor\n\n```sh\nbun add @hono/zod-validator\n```\n\nThen, import the zValidator from the installed package:\n\n```ts\nimport { zValidator } from '@hono/zod-validator'\n```\n\nYou can now use the zValidator in your routes to validate incoming data. Here's an example of a POST route that uses zValidator to ensure the 'body' field of the incoming data is a string:\n\n```ts\nconst route = app.post(\n  '/posts',\n  zValidator(\n    'form',\n    z.object({\n      body: z.string(),\n    })\n  ),\n  (c) => {\n    const validated = c.req.valid('form')\n    // ... use your validated data\n  }\n)\n```\n\nIn this example, `zValidator('form', z.object({ body: z.string() }))` is a middleware that validates the 'form' field of the request. If the validation fails, the request is rejected. If it passes, the validated data can be accessed with `c.req.valid('form')`.\n\n### Important Notes\n\n- Always validate incoming data to prevent invalid or malicious data from being processed.\n\n### References\n\n- [Hono Framework Documentation](https://hono.bun.dev/)\n\n### Common Use Cases\n\n- Validating form data in POST requests.\n- Validating query parameters in GET requests.",
      "ruleTitle": "Installing and Using zod-validator for Data Validation in Hono",
      "sourcePath": "docs/guides/validation.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to register middleware in Hono web framework. Middleware is a crucial part of any web application as it allows you to run code before the final request handler, perform operations on the request and response objects, end the request-response cycle, or call the next middleware function in the stack. Understanding how to register middleware is essential for building robust applications with Hono.",
      "ruleFile": "## Registering Middleware in Hono\n\nThis code snippet demonstrates how to register middleware in Hono web framework.\n\n```ts\n// match any method, all routes\napp.use(logger())\n\n// specify path\napp.use('/posts/*', cors())\n\n// specify method and path\napp.post('/posts/*', basicAuth())\n```\n\n### How it works\n\n1. `app.use(logger())`: This registers a logger middleware that will be applied to all routes and methods.\n\n2. `app.use('/posts/*', cors())`: This registers a CORS middleware that will be applied to all routes that match the pattern '/posts/*'.\n\n3. `app.post('/posts/*', basicAuth())`: This registers a basic authentication middleware that will be applied to all POST requests that match the pattern '/posts/*'.\n\n### Important notes\n\n- Middleware functions are executed in the order they are registered.\n\n- Middleware can be applied to specific HTTP methods by using `app.HTTP_METHOD`.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common use cases\n\n- Logging requests and responses\n- Enabling CORS\n- Authenticating requests",
      "ruleTitle": "Registering Middleware in Hono",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates the order of execution of middleware in the Hono framework. Middleware are functions that have access to the request object (req), the response object (res), and the next middleware function in the applicationâ€™s request-response cycle. Understanding the order of execution of middleware is crucial for managing the flow of data and control in the application.",
      "ruleFile": "## Middleware Execution Order in Hono\n\nIn Hono, middleware are processed in the order they are defined. This is demonstrated in the following code snippet:\n\n```ts\napp.use('/posts/*', cors())\napp.post('/posts/*', basicAuth())\napp.post('/posts', (c) => c.text('Created!', 201))\n```\n\nIn this case, four middleware are processed before dispatching like this:\n\n```ts\nlogger() -> cors() -> basicAuth() -> *handler*\n```\n\nThis means that the logger middleware is executed first, followed by the cors middleware, then the basicAuth middleware, and finally the handler.\n\n### How it works\n\nWhen a request is made to the '/posts' path, the middleware functions cors and basicAuth are executed in the order they are defined. If the handler returns `Response`, it will be used for the end-user, and stop the processing.\n\n### Important notes\n\n- The order of middleware definition matters in Hono.\n- Middleware functions can either end the request-response cycle or pass control to the next middleware function.\n\n### References\n\n- [Hono Documentation](https://hono.boutique/docs/)\n\n### Common use cases\n\n- Use middleware for tasks such as logging, authentication, and handling CORS.",
      "ruleTitle": "Middleware Execution Order in Hono",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates the execution order of middleware in Hono. Middleware in Hono runs in a stack-like manner, where the first middleware function can perform operations before and after the next middleware are run. This is crucial for understanding how to structure your middleware and control the flow of execution in your application.",
      "ruleFile": "## Hono Middleware Execution Order\n\nIn Hono, middleware functions are executed in the order they are defined. However, due to the use of the `await next()` statement, each middleware function can perform operations both before and after the next middleware functions are run. This results in a stack-like execution order.\n\nConsider the following code snippet:\n\n```text\nmiddleware 1 start\n  middleware 2 start\n    middleware 3 start\n      handler\n    middleware 3 end\n  middleware 2 end\nmiddleware 1 end\n```\n\nIn this example, 'middleware 1 start' is logged first, followed by 'middleware 2 start', and then 'middleware 3 start'. After 'handler' is logged, 'middleware 3 end' is logged, followed by 'middleware 2 end', and finally 'middleware 1 end'. This demonstrates that each middleware function can perform operations before and after the next middleware functions are run.\n\nThis pattern is useful for tasks such as logging, authentication, or any other operations that need to be performed before and/or after the main handler function.",
      "ruleTitle": "Understanding Middleware Execution Order in Hono",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use built-in middleware in Hono. Middleware is a crucial part of many web frameworks, including Hono, as it allows for pre-processing of requests and post-processing of responses. This rule also highlights the potential issues that can arise when using different versions of middleware than the Hono version, which can lead to bugs.",
      "ruleFile": "## Using Built-in Middleware in Hono\n\nThis code demonstrates how to use built-in middleware in Hono.\n\n```ts\nimport { Hono } from 'hono'\nimport { poweredBy } from 'hono/powered-by'\nimport { logger } from 'hono/logger'\nimport { basicAuth } from 'hono/basic-auth'\n\nconst app = new Hono()\n\napp.use(poweredBy())\napp.use(logger())\n\napp.use(\n  '/auth/*',\n  basicAuth({\n    username: 'hono',\n    password: 'acoolproject',\n  })\n)\n```\n\nIn this code, we first import the necessary modules from Hono. We then create a new Hono application. After that, we use the `app.use()` function to add the `poweredBy` and `logger` middleware to our application. Finally, we add the `basicAuth` middleware to any routes that match '/auth/*'.\n\nIt's important to note that using a different version of middleware than the Hono version can lead to bugs. Therefore, it's recommended to always use the same version of middleware as the Hono version.\n\n### References\n\n- [Hono Documentation](https://hono.bryntum.com/docs)\n\n### Common Use Cases\n\n- Adding pre-processing or post-processing functionality to your Hono application.\n- Adding authentication to certain routes in your Hono application.",
      "ruleTitle": "Using Built-in Middleware in Hono",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important because it highlights the potential issues that can arise when using different versions of middleware and the Hono version. It demonstrates the correct way to import and use middleware in Hono, and the potential bugs that can occur when the versions mismatch.",
      "ruleFile": "## Rule: Ensure Consistent Versioning Between Hono and Middleware\n\nIn Hono, it's possible to use a different version of middleware than the Hono version. However, this can lead to bugs and inconsistencies in your application. This rule demonstrates the correct way to import and use middleware in Hono, and the potential bugs that can occur when the versions mismatch.\n\n```ts\nimport { Hono } from 'jsr:@hono/hono@4.4.0'\nimport { upgradeWebSocket } from 'jsr:@hono/hono@4.4.5/deno'\n\nconst app = new Hono()\n\napp.get(\n  '/ws',\n  upgradeWebSocket(() => ({\n    // ...\n  }))\n)\n```\n\nIn the above code snippet, the `Hono` and `upgradeWebSocket` are imported from different versions, which can lead to bugs. Always ensure that the versions of Hono and the middleware you're using are consistent.\n\n### References\n\n- Hono Documentation\n\n### Common Use Cases\n\n- When setting up a new Hono application\n- When adding new middleware to your Hono application",
      "ruleTitle": "Ensure Consistent Versioning Between Hono and Middleware",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create and use custom middleware in Hono. Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the applicationâ€™s request-response cycle. They can execute any code, make changes to the request and the response objects, end the request-response cycle, and call the next middleware function in the stack.",
      "ruleFile": "## Creating and Using Custom Middleware in Hono\n\nThis code snippet demonstrates how to create and use custom middleware in Hono. Middleware functions are used for tasks like logging, adding headers, etc.\n\n```ts\n// Custom logger\napp.use(async (c, next) => {\n  console.log(`[${c.req.method}] ${c.req.url}`)\n  await next()\n})\n\n// Add a custom header\napp.use('/message/*', async (c, next) => {\n  await next()\n  c.header('x-message', 'This is middleware!')\n})\n\napp.get('/message/hello', (c) => c.text('Hello Middleware!'))\n```\n\nIn this example, the first middleware function logs the request method and URL. The second middleware function adds a custom header to the response for any request that matches the path '/message/*'.\n\n### How it works\n\n1. The `app.use()` function is used to add middleware functions to the application.\n2. The `next` function is called to pass control to the next middleware function. If `next` is not called, the request-response cycle will be halted.\n\n### Important notes\n\n- Middleware functions are executed in the order they are added.\n- Middleware functions can end the request-response cycle by not calling `next`, or they can pass control to the next middleware function by calling `next`.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Logging\n- Adding headers\n- Authentication",
      "ruleTitle": "Creating and Using Custom Middleware in Hono",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a middleware in Hono using the 'createMiddleware' function from Hono's factory. Middleware is a crucial part of any web application as it allows the execution of code, modification of request and response objects, and ending the request-response cycle. This code snippet shows how to create a simple logging middleware that logs the HTTP method and URL of each request.",
      "ruleFile": "## Creating a Middleware in Hono\n\nIn Hono, you can create a middleware using the 'createMiddleware' function from Hono's factory. Here is an example of a simple logging middleware:\n\n```ts\nimport { createMiddleware } from 'hono/factory'\n\nconst logger = createMiddleware(async (c, next) => {\n  console.log(`[${c.req.method}] ${c.req.url}`)\n  await next()\n})\n```\n\nIn this example, the middleware logs the HTTP method and URL of each request. The 'next' function is called to pass control to the next middleware function in the stack.\n\n### How it Works\n\nThe 'createMiddleware' function takes a callback function as an argument. This callback function is the actual middleware function that gets executed. It has access to the context object 'c' and a 'next' function. The context object 'c' contains the request and response objects, among other things. The 'next' function is used to pass control to the next middleware function in the stack.\n\n### Important Notes\n\n- Middleware functions are called in the order they are defined.\n- Don't forget to call the 'next' function to avoid hanging the request-response cycle.\n\n### References\n\n- [Hono Factory](https://hono.dev/docs/api/factory)\n- [Hono Context](https://hono.dev/docs/api/context)\n\n### Common Use Cases\n\n- Logging\n- Authentication\n- Error handling",
      "ruleTitle": "Creating a Middleware in Hono",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a middleware in Hono using the 'createMiddleware' function. It also shows how to use type generics with 'createMiddleware' and how to modify responses in middleware. Understanding this rule is crucial for developers to effectively manage HTTP requests and responses in a Hono application.",
      "ruleFile": "## Creating and Modifying Middleware in Hono\n\nIn Hono, you can create middleware using the 'createMiddleware' function. This function takes a callback function as an argument, which receives the context 'c' and the 'next' function. The context 'c' contains the request and response objects, and 'next' is a function that passes control to the next middleware.\n\nHere is an example of creating a middleware that logs the request method and URL:\n\n```ts\nconst logger = createMiddleware(async (c, next) => {\n  console.log(`[${c.req.method}] ${c.req.url}`)\n  await next()\n})\n```\n\nYou can also use type generics with 'createMiddleware' to specify the type of the context:\n\n```ts\ncreateMiddleware<{Bindings: Bindings}>(async (c, next) =>\n```\n\nMoreover, middleware can be designed to modify responses. After calling 'next', you can modify the response object 'c.res':\n\n```ts\nconst stripRes = createMiddleware(async (c, next) => {\n  await next()\n  // modify c.res here\n})\n```\n\n### Important Notes\n\n- Middleware functions are executed in the order they are added.\n- Always call 'next' in your middleware to avoid blocking the request-response cycle.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common Use Cases\n\n- Logging requests\n- Authenticating users\n- Modifying responses",
      "ruleTitle": "Creating and Modifying Middleware in Hono",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to modify the response after the 'next' function has been called in a middleware function. It also shows how to access the context inside middleware arguments. This is a common pattern in Hono and other web frameworks, allowing developers to manipulate the response object before it is sent back to the client.",
      "ruleFile": "## Modifying the Response in Middleware and Accessing Context\n\nIn Hono, middleware functions can be designed to modify responses if necessary. This is typically done after the 'next' function has been called. The 'next' function passes control to the next middleware function in the stack. After it has been called, you can modify the response object.\n\nHere is an example of how to do this:\n\n```ts\nconst stripRes = createMiddleware(async (c, next) => {\n  await next()\n  c.res = undefined\n  c.res = new Response('New Response')\n})\n```\n\nIn this code snippet, the response object 'c.res' is first set to undefined, then a new Response is created with the message 'New Response'.\n\nTo access the context inside middleware arguments, you can directly use the context parameter provided by 'app.use'.\n\n### Important Notes\n\n- The 'next' function should be called before modifying the response object.\n- The context parameter 'c' provides access to the request and response objects, among other things.\n\n### References\n\n- [Hono Middleware Documentation](https://hono.bayrell.org/docs/middleware)\n\n### Common Use Cases\n\n- Modifying the response object based on certain conditions.\n- Accessing the context to get information about the request or response.",
      "ruleTitle": "Modifying the Response in Middleware and Accessing Context in Hono",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to access and use the context inside middleware arguments in Hono. It shows how to use the context parameter provided by `app.use` to configure middleware, in this case, the cors middleware. Understanding this pattern is crucial for developers to effectively use and configure middleware in their Hono applications.",
      "ruleFile": "## Context Access and Middleware Configuration in Hono\n\nThis guide demonstrates how to access and use the context inside middleware arguments in Hono. The context parameter provided by `app.use` is used to configure middleware.\n\nHere is the code snippet:\n\n```ts\nimport { cors } from 'hono/cors'\n\napp.use('*', async (c, next) => {\n  const middleware = cors({\n    origin: c.env.CORS_ORIGIN,\n  })\n  return middleware(c, next)\n})\n```\n\n### How it works\n\nIn the code snippet, the cors middleware is being configured. The context `c` is used to access the environment variable `CORS_ORIGIN` which is then passed as the `origin` option to the cors middleware.\n\n### Important notes\n\n- The context `c` is a parameter provided by `app.use` and it contains useful information about the request and response, as well as any environment variables.\n\n- Middleware in Hono is configured by passing an options object to the middleware function. The options object can use values from the context.\n\n### References\n\n- [Hono documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Configuring middleware based on environment variables or other context information.\n- Accessing request and response information in middleware.",
      "ruleTitle": "Context Access and Middleware Configuration in Hono",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to extend the context inside middleware using the 'c.set' method in Hono. It also shows how to make this type-safe by passing a `{ Variables: { yourVariable: YourVariableType } }` generic argument to the `createMiddleware` function. This is a common pattern in Hono framework usage and is crucial for creating reusable and modular code.",
      "ruleFile": "# Extending Context Inside Middleware in Hono\n\nThis guide demonstrates how to extend the context inside middleware using the 'c.set' method in Hono. It also shows how to make this type-safe by passing a `{ Variables: { yourVariable: YourVariableType } }` generic argument to the `createMiddleware` function.\n\n```ts\nimport { createMiddleware } from 'hono/factory'\n\nconst echoMiddleware = createMiddleware<{\n  Variables: {\n    echo: (str: string) => string\n  }\n}>(async (c, next) => {\n  c.set('echo', (str) => str)\n  await next()\n})\n\napp.get('/echo', echoMiddleware, (c) => {\n  return c.text(c.var.echo('Hello!'))\n})\n```\n\n## How it Works\n\n1. The `createMiddleware` function is imported from 'hono/factory'.\n2. A middleware named 'echoMiddleware' is created. This middleware is type-safe and has a variable 'echo' that is a function taking a string and returning a string.\n3. Inside the middleware, the 'echo' variable is set to a function that returns the input string.\n4. The middleware is then used in a GET request handler for the '/echo' route. The 'echo' function is called with the string 'Hello!' and the result is sent as a text response.\n\n## Important Notes\n\n- The 'c.set' method is used to extend the context inside middleware.\n- The `{ Variables: { yourVariable: YourVariableType } }` generic argument is used to make the middleware type-safe.\n\n## References\n\n- Hono Documentation: [Middleware](https://hono.bayfront.io/Reference/Middleware)\n\n## Common Use Cases\n\n- Extending the context with custom functions or data in middleware.\n- Making middleware type-safe.",
      "ruleTitle": "Extending Context Inside Middleware in Hono",
      "sourcePath": "docs/guides/middleware.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use a third-party Renovate configuration in a Hono project. Renovate is a tool that helps to automate dependency updates, which is crucial for maintaining the security and reliability of the project. Since the Hono team does not maintain a Renovate configuration, users are advised to use a third-party configuration.",
      "ruleFile": "## Using Third-Party Renovate Configuration in Hono\n\nSince the Hono team does not maintain a Renovate configuration, it's recommended to use a third-party configuration. This can be done by extending the third-party configuration in your `renovate.json` file.\n\nHere is a code snippet demonstrating this:\n\n```json\n// renovate.json\n{\n  \"$schema\": \"https://docs.renovatebot.com/renovate-schema.json\",\n  \"extends\": [\n    \"github>shinGangan/renovate-config-hono\" // [!code ++]\n  ]\n}\n```\n\nIn this code snippet, the `extends` field is used to specify the third-party configuration that should be used. The value `github>shinGangan/renovate-config-hono` indicates that the configuration from the `renovate-config-hono` repository on GitHub, owned by the user `shinGangan`, should be used.\n\n### Important Notes\n\n- Always ensure that the third-party configuration you are using is reliable and secure.\n\n### References\n\n- [Renovate Configuration](https://docs.renovatebot.com/configuration-options/)\n- [renovate-config-hono Repository](https://github.com/shinGangan/renovate-config-hono)\n\n### Common Use Cases\n\n- Automating dependency updates in a Hono project.",
      "ruleTitle": "Using Third-Party Renovate Configuration in Hono",
      "sourcePath": "docs/guides/faq.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes and handle HTTP GET and POST requests in Hono. It also shows how to send different types of responses, such as text and JSON, and how to set custom headers in the response.",
      "ruleFile": "## Defining Routes and Handling Requests in Hono\n\nThis code snippet demonstrates how to define routes and handle HTTP GET and POST requests in Hono. It also shows how to send different types of responses, such as text and JSON, and how to set custom headers in the response.\n\n```ts\napp.get('/posts', (c) => {\n  return c.text('Many posts')\n})\n\napp.post('/posts', (c) => {\n  return c.json(\n    {\n      message: 'Created',\n    },\n    201,\n    {\n      'X-Custom': 'Thank you',\n    }\n  )\n})\n```\n\n### How it works\n\nThe `app.get` method is used to handle HTTP GET requests to the '/posts' path. The callback function takes a context object `c` and returns a text response 'Many posts'.\n\nThe `app.post` method is used to handle HTTP POST requests to the '/posts' path. The callback function takes a context object `c` and returns a JSON response with a status code of 201 and a custom header 'X-Custom'.\n\n### Important notes\n\n- The context object `c` provides methods for sending different types of responses and for accessing request information.\n- The `c.text` method is used to send a text response.\n- The `c.json` method is used to send a JSON response. It takes three arguments: the JSON object, the status code, and the headers.\n\n### References\n\n- [Hono documentation](https://hono.bike/docs)\n\n### Common use cases\n\n- Defining routes and handling requests in a web application.\n- Sending different types of responses based on the request.",
      "ruleTitle": "Defining Routes and Handling Requests in Hono",
      "sourcePath": "docs/guides/testing.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to test GET and POST requests in Hono. It shows how to make requests to specific endpoints and how to check the responses for expected status codes and content. This is crucial for ensuring the correct functionality of your web application.",
      "ruleFile": "## Testing GET and POST Requests in Hono\n\nThis guide demonstrates how to test GET and POST requests in Hono. It shows how to make requests to specific endpoints and how to check the responses for expected status codes and content.\n\n### Code Snippet\n\n```ts\ndescribe('Example', () => {\n  test('GET /posts', async () => {\n    const res = await app.request('/posts')\n    expect(res.status).toBe(200)\n    expect(await res.text()).toBe('Many posts')\n  })\n})\n```\n\n### How it Works\n\n1. The `describe` function groups related tests.\n2. The `test` function defines a test for the 'GET /posts' endpoint.\n3. `app.request('/posts')` makes a GET request to the '/posts' endpoint.\n4. `expect(res.status).toBe(200)` checks that the response status code is 200.\n5. `expect(await res.text()).toBe('Many posts')` checks that the response text is 'Many posts'.\n\n### Important Notes\n\n- Ensure that your application is running and that the '/posts' endpoint is correctly configured before running these tests.\n\n### References\n\n- [Hono Documentation](https://hono.boutique/docs/)\n\n### Common Use Cases\n\n- Use this pattern to test any GET or POST request in your Hono application.",
      "ruleTitle": "Testing GET and POST Requests in Hono",
      "sourcePath": "docs/guides/testing.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to make a POST request using the Hono framework, and how to test the response status, headers, and JSON body. Understanding this pattern is crucial for developers to ensure their APIs are functioning as expected.",
      "ruleFile": "## Making and Testing a POST Request in Hono\n\nThis code snippet demonstrates how to make a POST request using the Hono framework, and how to test the response status, headers, and JSON body.\n\n```ts\ntest('POST /posts', async () => {\n  const res = await app.request('/posts', {\n    method: 'POST',\n  })\n  expect(res.status).toBe(201)\n  expect(res.headers.get('X-Custom')).toBe('Thank you')\n  expect(await res.json()).toEqual({\n    message: 'Created',\n  })\n})\n```\n\n### How it works\n\n1. The `app.request` function is used to make a POST request to the '/posts' endpoint.\n2. The response (`res`) is then tested for a status of 201, indicating that the resource was successfully created.\n3. The response headers are checked for a custom header 'X-Custom' with a value of 'Thank you'.\n4. The JSON body of the response is parsed and tested to be an object with a 'message' property of 'Created'.\n\n### Important notes\n\n- Ensure that the endpoint '/posts' is set up to handle POST requests in your application.\n- The 'X-Custom' header and the JSON response body are specific to this example and may vary based on your application's requirements.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/guide/)\n\n### Common use cases\n\n- Testing API endpoints in a Hono application.",
      "ruleTitle": "Making and Testing a POST Request in Hono",
      "sourcePath": "docs/guides/testing.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to make a POST request in Hono with JSON data, and how to assert the response status, headers, and body. Understanding this pattern is crucial for testing endpoints in a Hono application.",
      "ruleFile": "## Making a POST Request and Asserting the Response in Hono\n\nThis code snippet demonstrates how to make a POST request to the '/posts' endpoint with JSON data, and how to assert the response status, headers, and body.\n\n```ts\ntest('POST /posts', async () => {\n  const res = await app.request('/posts', {\n    method: 'POST',\n    body: JSON.stringify({ message: 'hello hono' }),\n    headers: new Headers({ 'Content-Type': 'application/json' }),\n  })\n  expect(res.status).toBe(201)\n  expect(res.headers.get('X-Custom')).toBe('Thank you')\n  expect(await res.json()).toEqual({\n    message: 'Created',\n  })\n})\n```\n\n### How it works\n\n1. The `app.request` function is used to make a request to the '/posts' endpoint with a 'POST' method.\n2. The body of the request is a JSON stringified object.\n3. The headers of the request include a 'Content-Type' of 'application/json'.\n4. The response status is asserted to be 201, indicating that a resource was successfully created.\n5. The response headers are asserted to include a custom header 'X-Custom' with a value of 'Thank you'.\n6. The response body is asserted to be a JSON object with a 'message' property of 'Created'.\n\n### Important notes\n\n- Ensure that the endpoint and method used in the `app.request` function match the endpoint and method of the route being tested.\n- The assertions made on the response should match the expected behavior of the endpoint.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common use cases\n\n- Testing endpoints in a Hono application.",
      "ruleTitle": "Making a POST Request and Asserting the Response in Hono",
      "sourcePath": "docs/guides/testing.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to make a POST request with multipart/form-data using the Hono framework. It also shows how to perform assertions on the response, checking the status, headers, and body of the response. This is a common operation in web development, especially when dealing with forms and file uploads.",
      "ruleFile": "## Making a POST request with multipart/form-data in Hono\n\nThis code snippet demonstrates how to make a POST request with multipart/form-data using the Hono framework.\n\n```ts\ntest('POST /posts', async () => {\n  const formData = new FormData()\n  formData.append('message', 'hello')\n  const res = await app.request('/posts', {\n    method: 'POST',\n    body: formData,\n  })\n  expect(res.status).toBe(201)\n  expect(res.headers.get('X-Custom')).toBe('Thank you')\n  expect(await res.json()).toEqual({\n    message: 'Created',\n  })\n})\n```\n\n### How it works\n\n1. A new FormData instance is created and a 'message' field is appended to it.\n2. The app.request method is used to make a POST request to the '/posts' endpoint, passing the FormData instance as the body of the request.\n3. Assertions are performed on the response, checking that the status is 201 (Created), the 'X-Custom' header is 'Thank you', and the body of the response is `{ message: 'Created' }`.\n\n### Important notes\n\n- The FormData API is used to construct a set of key/value pairs representing form fields and their values.\n- The app.request method returns a Promise that resolves to the Response to that request, whether it is successful or not.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Submitting forms with file uploads\n- Making POST requests with complex data structures",
      "ruleTitle": "Making a POST request with multipart/form-data in Hono",
      "sourcePath": "docs/guides/testing.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a test for a POST request in Hono. It shows how to create a new Request instance, how to send the request using the app.request method, and how to assert the response status, headers, and body. This is a common pattern in testing HTTP endpoints in Hono.",
      "ruleFile": "## Testing POST requests in Hono\n\nThis guide demonstrates how to create a test for a POST request in Hono.\n\n### Code Snippet\n\n```ts\ntest('POST /posts', async () => {\n  const req = new Request('http://localhost/posts', {\n    method: 'POST',\n  })\n  const res = await app.request(req)\n  expect(res.status).toBe(201)\n  expect(res.headers.get('X-Custom')).toBe('Thank you')\n  expect(await res.json()).toEqual({\n    message: 'Created',\n  })\n})\n```\n\n### How it works\n\n1. A new Request instance is created with the URL and method set to 'POST'.\n2. The request is sent using the app.request method.\n3. The response status, headers, and body are asserted using Jest's expect function.\n\n### Important notes\n\n- The URL in the Request constructor should be the URL of the endpoint you want to test.\n- The method in the Request constructor should be the HTTP method that the endpoint accepts.\n- The assertions should match the expected response of the endpoint.\n\n### References\n\n- [Hono documentation](https://hono.boutique/docs)\n\n### Common use cases\n\n- Testing HTTP endpoints in Hono.",
      "ruleTitle": "Testing POST Requests in Hono",
      "sourcePath": "docs/guides/testing.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to mock environment variables for testing in Hono. It allows developers to simulate different environments and test how their application behaves under those conditions. This is particularly useful when testing components that interact with external services or databases.",
      "ruleFile": "## Mocking Environment Variables for Testing in Hono\n\nThis code snippet demonstrates how to mock environment variables for testing in Hono. This is useful when you want to simulate different environments and see how your application behaves under those conditions.\n\n```ts\nconst MOCK_ENV = {\n  API_HOST: 'example.com',\n  DB: {\n    prepare: () => {\n      /* mocked D1 */\n    },\n  },\n}\n\ntest('GET /posts', async () => {\n  const res = await app.request('/posts', {}, MOCK_ENV)\n})\n```\n\n### How it works\n\n1. Define a `MOCK_ENV` object with the environment variables you want to mock.\n2. Pass `MOCK_ENV` as the third parameter to `app.request` in your test.\n\n### Important notes\n\n- The `MOCK_ENV` object should mirror the structure of your actual environment variables.\n\n### References\n\n- [Cloudflare Workers Bindings](https://hono.dev/getting-started/cloudflare-workers#bindings)\n\n### Common use cases\n\n- Mocking database connections or API hosts for testing.",
      "ruleTitle": "Mocking Environment Variables for Testing in Hono",
      "sourcePath": "docs/guides/testing.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a simple counter component using the Hono framework. It shows how to use the useState hook for state management and the render function to insert JSX components within a specified HTML element. Understanding this rule is crucial for developers to create interactive web applications using Hono.",
      "ruleFile": "## Creating a Simple Counter Component in Hono\n\nThis guide demonstrates how to create a simple counter component using the Hono framework. The counter increments when the button is clicked.\n\nHere is the code snippet:\n\n```tsx\nimport { useState } from 'hono/jsx'\nimport { render } from 'hono/jsx/dom'\n\nfunction Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  )\n}\n\nfunction App() {\n  return (\n    <html>\n      <body>\n        <Counter />\n      </body>\n    </html>\n  )\n}\n\nconst root = document.getElementById('root')\nrender(<App />, root)\n```\n\n### How it works\n\n1. The `useState` hook is used to manage the state of the counter.\n2. The `render` function is used to insert the `App` component within the HTML element with id 'root'.\n\n### Important notes\n\n- Hono's hooks are compatible with React, so if you're familiar with React, you can easily transition to Hono.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs)\n\n### Common use cases\n\n- Creating interactive components in web applications using Hono.",
      "ruleTitle": "Creating a Simple Counter Component in Hono",
      "sourcePath": "docs/guides/jsx-dom.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `render()` function in Hono to insert JSX components within a specified HTML element. Understanding this rule is crucial for developers to properly display their JSX components on the webpage.",
      "ruleFile": "## Rendering JSX Components in Hono\n\nIn Hono, you can use the `render()` function to insert JSX components within a specified HTML element. This is a fundamental aspect of displaying your components on the webpage.\n\nHere is a code snippet demonstrating this:\n\n```tsx\nrender(<Component />, container)\n```\n\nIn this code snippet, `<Component />` is the JSX component you want to render, and `container` is the HTML element where you want to insert your component.\n\nIt's important to note that the `render()` function is part of the hono/jsx/dom library, which provides hooks that are compatible or partially compatible with React. You can learn more about these APIs in the [React documentation](https://react.de).\n\nCommon use cases for this function include rendering the main app component into the root HTML element of your webpage.",
      "ruleTitle": "Rendering JSX Components in Hono",
      "sourcePath": "docs/guides/jsx-dom.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `startViewTransition` function in Hono to create a transition effect when changing the state of a component. It also shows how to use the `useState` hook to manage component state and how to apply CSS styles using the `css` function from Hono.",
      "ruleFile": "## Using startViewTransition in Hono\n\nThe following code demonstrates how to use the `startViewTransition` function in Hono to create a transition effect when changing the state of a component. It also shows how to use the `useState` hook to manage component state and how to apply CSS styles using the `css` function from Hono.\n\n```tsx\nimport { useState, startViewTransition } from 'hono/jsx'\nimport { css, Style } from 'hono/css'\n\nexport default function App() {\n  const [showLargeImage, setShowLargeImage] = useState(false)\n  return (\n    <>\n      <Style />\n      <button\n        onClick={() =>\n          startViewTransition(() =>\n            setShowLargeImage((state) => !state)\n          )\n        }\n      >\n        Click!\n      </button>\n      <div>\n        {!showLargeImage ? (\n          <img src='https://hono.dev/images/logo.png' />\n        ) : (\n          <div\n            class={css`\n              background: url('https://hono.dev/images/logo-large.png');\n              background-size: contain;\n              background-repeat: no-repeat;\n              background-position: center;\n              width: 600px;\n              height: 600px;\n            `}\n          ></div>\n        )}\n      </div>\n    </>\n  )\n}\n```\n\n### How it works\n\nThe `startViewTransition` function is used to create a transition effect when the state of the `showLargeImage` variable is changed. The `useState` hook is used to manage the state of the `showLargeImage` variable. The `css` function is used to apply CSS styles to the div element.\n\n### Important notes\n\n- The `startViewTransition` function should be used inside an event handler, such as `onClick`.\n- The `useState` hook should be used at the top of your function component.\n- The `css` function can be used to apply inline styles to your JSX elements.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs)\n\n### Common use cases\n\n- Creating transition effects when changing component state\n- Managing component state with the `useState` hook\n- Applying CSS styles with the `css` function",
      "ruleTitle": "Using startViewTransition, useState, and css in Hono",
      "sourcePath": "docs/guides/jsx-dom.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use view transitions in Hono. It shows how to use the `viewTransition` function to create a unique transition name and apply it to a CSS class. It also demonstrates how to use the `startViewTransition` function to start a view transition when a button is clicked.",
      "ruleFile": "## Using View Transitions in Hono\n\nThis guide demonstrates how to use view transitions in Hono. The `viewTransition` function is used to create a unique transition name and apply it to a CSS class. The `startViewTransition` function is used to start a view transition when a button is clicked.\n\n```tsx\nimport { useState, startViewTransition } from 'hono/jsx'\nimport { viewTransition } from 'hono/jsx/dom/css'\nimport { css, keyframes, Style } from 'hono/css'\n\nconst rotate = keyframes`\n  from {\n    rotate: 0deg;\n  }\n  to {\n    rotate: 360deg;\n  }\n`\n\nexport default function App() {\n  const [showLargeImage, setShowLargeImage] = useState(false)\n  const [transitionNameClass] = useState(() =>\n    viewTransition(css`\n      ::view-transition-old() {\n        animation-name: ${rotate};\n      }\n      ::view-transition-new() {\n        animation-name: ${rotate};\n      }\n    `)\n  )\n  return (\n    <>\n      <Style />\n      <button\n        onClick={() =>\n          startViewTransition(() =>\n            setShowLargeImage((state) => !state)\n          )\n        }\n      >\n        Click!\n      </button>\n      <div>\n        {!showLargeImage ? (\n          <img src='https://hono.dev/images/logo.png' />\n        ) : (\n          <div\n            class={css`\n              ${transitionNameClass}\n              background: url('https://hono.dev/images/logo-large.png');\n              background-size: contain;\n              background-repeat: no-repeat;\n              background-position: center;\n              width: 600px;\n              height: 600px;\n            `}\n          ></div>\n        )}\n      </div>\n    </>\n  )\n}\n```\n\n### How it works\n\n1. The `viewTransition` function is used to create a unique transition name and apply it to a CSS class.\n2. The `startViewTransition` function is used to start a view transition when a button is clicked.\n\n### Important notes\n\n- The `viewTransition` function returns a unique transition name that can be used in CSS.\n- The `startViewTransition` function starts a view transition.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs)\n\n### Common use cases\n\n- Creating unique transitions for different views in a web application.",
      "ruleTitle": "Using View Transitions in Hono",
      "sourcePath": "docs/guides/jsx-dom.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use Hono's `useViewTransition` and `viewTransition` functions to create a view transition with a rotation animation. It also shows how to use the `useState` function to manage state within a component, and how to conditionally render components based on state.",
      "ruleFile": "## Using `useViewTransition` and `viewTransition` for Animated Transitions\n\nThis code snippet demonstrates how to use Hono's `useViewTransition` and `viewTransition` functions to create a view transition with a rotation animation. It also shows how to use the `useState` function to manage state within a component, and how to conditionally render components based on state.\n\n```tsx\nimport { useState, useViewTransition } from 'hono/jsx'\nimport { viewTransition } from 'hono/jsx/dom/css'\nimport { css, keyframes, Style } from 'hono/css'\n\nconst rotate = keyframes`\n  from {\n    rotate: 0deg;\n  }\n  to {\n    rotate: 360deg;\n  }\n`\n\nexport default function App() {\n  const [isUpdating, startViewTransition] = useViewTransition()\n  const [showLargeImage, setShowLargeImage] = useState(false)\n  const [transitionNameClass] = useState(() =>\n    viewTransition(css`\n      ::view-transition-old() {\n        animation-name: ${rotate};\n      }\n      ::view-transition-new() {\n        animation-name: ${rotate};\n      }\n    `)\n  )\n  return (\n    <>\n      <Style />\n      <button\n        onClick={() =>\n          startViewTransition(() =>\n            setShowLargeImage((state) => !state)\n          )\n        }\n      >\n        Click!\n      </button>\n      <div>\n        {!showLargeImage ? (\n          <img src='https://hono.dev/images/logo.png' />\n        ) : (\n          <div\n            class={css`\n              ${transitionNameClass}\n              background: url('https://hono.dev/images/logo-large.png');\n              background-size: contain;\n              background-repeat: no-repeat;\n              background-position: center;\n              width: 600px;\n              height: 600px;\n              position: relative;\n              ${isUpdating &&\n              css`\n                &:before {\n                  content: 'Loading...';\n                  position: absolute;\n                  top: 50%;\n                  left: 50%;\n                }\n              `}\n            `}\n          ></div>\n        )}\n      </div>\n    </>\n  )\n}\n```\n\n### How it works\n\n1. The `useViewTransition` function is used to create a view transition. The `startViewTransition` function is called when the button is clicked, triggering a state change that toggles the `showLargeImage` state.\n2. The `viewTransition` function is used to define the transition animation. The `rotate` keyframes are used for the animation.\n3. The `useState` function is used to manage the `showLargeImage` state. This state determines whether the large image or the small image is displayed.\n\n### Important notes\n\n- The `useViewTransition` and `viewTransition` functions are part of Hono's JSX Runtime for Client Components. Using this will result in smaller bundled results than using `hono/jsx`.\n\n### References\n\n- [Hono Documentation](https://hono.dev)\n\n### Common use cases\n\n- Creating animated transitions between views in a single-page application.",
      "ruleTitle": "Using `useViewTransition` and `viewTransition` for Animated Transitions in Hono",
      "sourcePath": "docs/guides/jsx-dom.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure the JSX runtime for client components in Hono framework. It shows how to specify 'hono/jsx/dom' in 'tsconfig.json' for smaller bundled results. It also provides an alternative way to specify 'hono/jsx/dom' in the esbuild transform options in 'vite.config.ts'.",
      "ruleFile": "## Configuring JSX Runtime for Client Components in Hono\n\nThis guide demonstrates how to configure the JSX runtime for client components in Hono framework. Using this configuration will result in smaller bundled results than using `hono/jsx`.\n\n### Code Snippet\n\n```json\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"hono/jsx/dom\"\n  }\n}\n```\n\n### How it Works\n\nThis configuration tells the compiler to use 'react-jsx' for JSX and to import JSX from 'hono/jsx/dom'.\n\n### Important Notes\n\n- This configuration should be specified in 'tsconfig.json'.\n- For Deno, modify the deno.json.\n\n### References\n\n- [Hono Documentation](https://hono.io/docs)\n\n### Common Use Cases\n\n- When you want to optimize the bundle size of your Hono application.\n- When you are building client components in Hono.",
      "ruleTitle": "Configuring JSX Runtime for Client Components in Hono",
      "sourcePath": "docs/guides/jsx-dom.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to specify the JSX import source in the Vite configuration file when using the Hono framework. This is crucial for correctly compiling JSX syntax in a Hono project.",
      "ruleFile": "## Specifying JSX Import Source in Vite Configuration\n\nWhen using the Hono framework with Vite, you can specify the JSX import source in the Vite configuration file. This is necessary for correctly compiling JSX syntax in a Hono project.\n\nHere is a code snippet demonstrating this:\n\n```ts\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxImportSource: 'hono/jsx/dom',\n  },\n})\n```\n\nIn this code snippet, we import the `defineConfig` function from Vite and use it to export a configuration object. Inside this object, we specify the `jsxImportSource` option under the `esbuild` property. This tells Vite to use 'hono/jsx/dom' as the source for JSX imports.\n\n### Important Notes\n\n- Make sure to install the necessary dependencies for using JSX with Hono and Vite.\n\n### References\n\n- [Vite Configuration Guide](https://vitejs.dev/config/)\n\n### Common Use Cases\n\n- Use this configuration when you want to use JSX syntax in a Hono project that is built with Vite.",
      "ruleTitle": "Specifying JSX Import Source in Vite Configuration for Hono",
      "sourcePath": "docs/guides/jsx-dom.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure the TypeScript compiler to use JSX syntax in a Hono project. JSX is a syntax extension for JavaScript, primarily used with React to describe what the UI should look like. By setting the 'jsx' compiler option to 'react-jsx' and 'jsxImportSource' to 'hono/jsx', we instruct the TypeScript compiler to transform JSX syntax into JavaScript that can be understood by the Hono framework.",
      "ruleFile": "## Configuring TypeScript Compiler for JSX in Hono\n\nThis code demonstrates how to configure the TypeScript compiler to use JSX syntax in a Hono project.\n\n```json\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"hono/jsx\"\n  }\n}\n```\n\n### How it works\n\nIn the `tsconfig.json` file, we set the 'jsx' compiler option to 'react-jsx' and 'jsxImportSource' to 'hono/jsx'. This instructs the TypeScript compiler to transform JSX syntax into JavaScript that can be understood by the Hono framework.\n\n### Important notes\n\n- This configuration is necessary if you are using JSX syntax in your Hono project.\n- If you are using Deno, you should modify the `deno.json` instead of the `tsconfig.json`.\n\n### References\n\n- [TypeScript Handbook: JSX](https://www.typescriptlang.org/docs/handbook/jsx.html)\n\n### Common use cases\n\n- Developing a Hono project that uses JSX syntax for UI description.",
      "ruleTitle": "Configuring TypeScript Compiler for JSX in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure the TypeScript or Deno compiler to use JSX syntax with the Hono framework. JSX is a syntax extension for JavaScript, often used with React, that allows for writing HTML-like code in your JavaScript code. Hono also supports JSX, but it needs to be enabled in the compiler options.",
      "ruleFile": "## Configuring JSX for Hono\n\nWhen using JSX with the Hono framework, you need to modify the `tsconfig.json` or `deno.json` file to specify the JSX syntax and import source.\n\nFor TypeScript, the `tsconfig.json` should look like this:\n\n```json\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"hono/jsx\"\n  }\n}\n```\n\nAlternatively, you can use pragma directives at the top of your TypeScript file:\n\n```ts\n/** @jsx jsx */\n/** @jsxImportSource hono/jsx */\n```\n\nFor Deno, modify the `deno.json` file instead:\n\n```json\n{\n  \"compilerOptions\": {\n    \"jsx\": \"precompile\",\n    \"jsxImportSource\": \"hono/jsx\"\n  }\n}\n```\n\n### How it works\n\nThe `jsx` option in the compiler options specifies the JSX factory function to use when targeting react JSX emit. The `jsxImportSource` option specifies the module specifier to use when importing the JSX factory functions when targeting react JSX emit.\n\n### Important notes\n\n- Make sure to use the correct file (`tsconfig.json` for TypeScript, `deno.json` for Deno) and correct options (`react-jsx` for TypeScript, `precompile` for Deno).\n\n### References\n\n- [TypeScript Compiler Options](https://www.typescriptlang.org/tsconfig#jsx)\n- [Deno Compiler Options](https://deno.land/manual/getting_started/typescript#compiler-options)\n\n### Common use cases\n\n- Using JSX syntax in a Hono project",
      "ruleTitle": "Configuring JSX for Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure the compiler options for JSX in Hono. It shows how to set the JSX processing mode and specify the module to import JSX functions from, which is crucial for using JSX syntax in Hono.",
      "ruleFile": "## Configuring JSX in Hono\n\nThis code snippet demonstrates how to configure the compiler options for JSX in Hono.\n\n```json\n{\n  \"compilerOptions\": {\n    \"jsx\": \"precompile\",\n    \"jsxImportSource\": \"hono/jsx\"\n  }\n}\n```\n\n### How it works\n\nIn the `compilerOptions` object, `jsx` is set to `precompile` which means the TypeScript compiler will convert JSX syntax to JavaScript. The `jsxImportSource` is set to `hono/jsx`, which specifies the module to import JSX functions from.\n\n### Important notes\n\n- This configuration is necessary to use JSX syntax in Hono.\n- For Deno, you have to modify the `deno.json` instead of the `tsconfig.json`.\n\n### References\n\n- [Hono JSX Documentation](https://hono.io/docs/jsx)\n\n### Common use cases\n\n- When you want to use JSX syntax in your Hono project, you need to configure the compiler options as shown.",
      "ruleTitle": "Configuring JSX Compiler Options in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a basic Hono application with JSX syntax. It shows how to define functional components, how to pass props to components, and how to use these components to render HTML responses in Hono routes.",
      "ruleFile": "## Creating a Basic Hono Application with JSX\n\nThis code snippet demonstrates how to create a basic Hono application using JSX syntax.\n\n```tsx\nimport { Hono } from 'hono'\nimport type { FC } from 'hono/jsx'\n\nconst app = new Hono()\n\nconst Layout: FC = (props) => {\n  return (\n    <html>\n      <body>{props.children}</body>\n    </html>\n  )\n}\n\nconst Top: FC<{ messages: string[] }> = (props: {\n  messages: string[]\n}) => {\n  return (\n    <Layout>\n      <h1>Hello Hono!</h1>\n      <ul>\n        {props.messages.map((message) => {\n          return <li>{message}!!</li>\n        })}\n      </ul>\n    </Layout>\n  )\n}\n\napp.get('/', (c) => {\n  const messages = ['Good Morning', 'Good Evening', 'Good Night']\n  return c.html(<Top messages={messages} />)\n})\n\nexport default app\n```\n\n### How it works\n\n1. We first import the necessary modules from Hono and define a new Hono application.\n2. We then define two functional components, `Layout` and `Top`, using the `FC` (Functional Component) type from Hono's JSX module.\n3. The `Layout` component takes in `props` and returns an HTML structure with `{props.children}` as the body content.\n4. The `Top` component takes in `props` with a `messages` array and returns the `Layout` component with a list of messages.\n5. In the Hono route handler for the root path (`/`), we return the `Top` component with a `messages` array as the HTML response.\n\n### Important notes\n\n- The `FC` type is used to define functional components in Hono with TypeScript.\n- The `props` argument in functional components is used to pass data to the components.\n\n### References\n\n- [Hono Documentation](https://hono.bun.js.org/)\n\n### Common use cases\n\n- Creating dynamic HTML responses in Hono routes using JSX syntax.",
      "ruleTitle": "Creating a Basic Hono Application with JSX",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to group multiple elements in Hono without adding extra nodes to the DOM. This is crucial for maintaining a clean and efficient DOM structure. It also shows an alternative syntax for Fragments, which can be useful for developers who prefer a more concise syntax.",
      "ruleFile": "## Using Fragments in Hono\n\nIn Hono, you can use Fragments to group multiple elements without adding extra nodes to the DOM. This is useful for maintaining a clean and efficient DOM structure.\n\nHere is an example of how to use Fragments:\n\n```tsx\nimport { Fragment } from 'hono/jsx'\n\nconst List = () => (\n  <Fragment>\n    <p>first child</p>\n    <p>second child</p>\n    <p>third child</p>\n  </Fragment>\n)\n```\n\nAlternatively, you can use a more concise syntax for Fragments if it is set up properly:\n\n```tsx\nconst List = () => (\n  <>\n    <p>first child</p>\n    <p>second child</p>\n    <p>third child</p>\n  </>\n)\n```\n\n### Important Notes\n\n- Fragments are a way to return multiple elements from a component without adding extra nodes to the DOM.\n- The alternative syntax for Fragments (`<></>`) can be used if it is set up properly.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs)\n\n### Common Use Cases\n\n- When you need to return multiple elements from a component but don't want to add extra nodes to the DOM.",
      "ruleTitle": "Using Fragments to Group Multiple Elements in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use Fragments and PropsWithChildren in Hono. Fragments let you group a list of children without adding extra nodes to the DOM. PropsWithChildren is used to correctly infer a child element in a function component, which is crucial for type safety and component reusability.",
      "ruleFile": "## Using Fragments and PropsWithChildren in Hono\n\nIn Hono, you can use Fragments to group a list of children without adding extra nodes to the DOM. This can be done using the `<Fragment>` tag or the shorthand `<>` if it is set up properly.\n\n```tsx\nconst List = () => (\n  <>\n    <p>first child</p>\n    <p>second child</p>\n    <p>third child</p>\n  </>\n)\n```\n\nIn addition, Hono provides `PropsWithChildren` to correctly infer a child element in a function component. This is crucial for type safety and component reusability.\n\n```tsx\nimport { PropsWithChildren } from 'hono/jsx'\n\ntype Post = {\n  id: number\n}\n```\n\n### Important Notes\n\n- Always use `PropsWithChildren` when you need to infer a child element in a function component for type safety.\n- Use Fragments when you need to return multiple elements from a component.\n\n### References\n\n- [Hono Documentation](https://hono.io/docs)\n\n### Common Use Cases\n\n- Grouping multiple elements in a component without adding extra nodes to the DOM.\n- Inferring child elements in a function component for type safety and reusability.",
      "ruleTitle": "Using Fragments and PropsWithChildren in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use 'PropsWithChildren' in Hono to correctly infer a child element in a function component. This is a common pattern in Hono when you want to create a component that accepts children elements.",
      "ruleFile": "## Using PropsWithChildren in Hono\n\nIn Hono, you can use `PropsWithChildren` to correctly infer a child element in a function component. This is particularly useful when you want to create a component that accepts children elements.\n\nHere is an example:\n\n```tsx\nimport { PropsWithChildren } from 'hono/jsx'\n\ntype Post = {\n  id: number\n  title: string\n}\n\nfunction Component({ title, children }: PropsWithChildren<Post>) {\n  return (\n    <div>\n      <h1>{title}</h1>\n      {children}\n    </div>\n  )\n}\n```\n\nIn this code snippet:\n\n1. We import `PropsWithChildren` from 'hono/jsx'.\n2. We define a type 'Post' with properties 'id' and 'title'.\n3. We create a function component 'Component' that takes 'title' and 'children' as props. The type of the props is 'PropsWithChildren<Post>'.\n4. In the return statement of the function, we render a 'div' element with a 'h1' element and the 'children' elements.\n\n### Important Notes\n\n- 'PropsWithChildren' is a utility type provided by Hono. It takes a type and adds a 'children' property to it.\n- The 'children' property can be any valid JSX element or an array of JSX elements.\n\n### References\n\n- [Hono Documentation](https://hono.io/docs/jsx)\n\n### Common Use Cases\n\n- Creating a wrapper component that accepts children elements.\n- Creating a layout component that accepts children elements.",
      "ruleTitle": "Using PropsWithChildren in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to insert raw HTML directly into a component using the 'dangerouslySetInnerHTML' property in Hono. This is a powerful feature but should be used with caution due to potential security risks associated with inserting raw HTML.",
      "ruleFile": "## Inserting Raw HTML in Hono\n\nIn Hono, you can directly insert HTML into a component using the `dangerouslySetInnerHTML` property. This is a powerful feature but should be used with caution due to potential security risks associated with inserting raw HTML.\n\nHere is a code snippet demonstrating this:\n\n```tsx\napp.get('/foo', (c) => {\n  const inner = { __html: 'JSX &middot; SSR' }\n  const Div = <div dangerouslySetInnerHTML={inner} />\n})\n```\n\nIn this example, a raw HTML string 'JSX &middot; SSR' is inserted into a div component. The HTML string is wrapped in an object with a `__html` key, which is then passed to the `dangerouslySetInnerHTML` property.\n\n### Important notes\n\n- Always sanitize any user-supplied input to prevent Cross-Site Scripting (XSS) attacks.\n- Avoid using `dangerouslySetInnerHTML` if possible. It is much safer to use JSX to compose your components.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs)\n\n### Common use cases\n\n- Displaying server-rendered HTML content\n- Inserting third-party content that requires HTML formatting",
      "ruleTitle": "Inserting Raw HTML in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to optimize Hono components by memoizing computed strings using `memo`. This practice can significantly improve the performance of your application by avoiding unnecessary re-rendering of components.",
      "ruleFile": "## Hono Memoization\n\nIn Hono, you can optimize your components by memoizing computed strings using `memo`. This practice can significantly improve the performance of your application by avoiding unnecessary re-rendering of components.\n\nHere is an example of how to use `memo` in Hono:\n\n```tsx\nimport { memo } from 'hono/jsx'\n\nconst Header = memo(() => <header>Welcome to Hono</header>)\nconst Footer = memo(() => <footer>Powered by Hono</footer>)\nconst Layout = (\n  <div>\n    <Header />\n    <p>Hono is cool!</p>\n    <Footer />\n  </div>\n)\n```\n\nIn this example, the `Header` and `Footer` components are wrapped with `memo`, which means that these components will only re-render if their props change. This can be particularly useful in cases where your components are expensive to render.\n\n### Important Notes\n\n- Be careful when using `memo` as it can lead to unexpected behavior if not used correctly. Make sure that you only use it on components that are expensive to render and that you test your application thoroughly.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs)\n\n### Common Use Cases\n\n- Use `memo` to optimize components that are expensive to render.\n- Use `memo` to prevent unnecessary re-renders when the props of your components do not change.",
      "ruleTitle": "Optimizing Hono Components with Memoization",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the useContext hook in Hono to share data globally across any level of the Component tree without passing values through props. This is a common pattern in Hono and other similar frameworks, and understanding it can greatly simplify the process of passing data around in a complex application.",
      "ruleFile": "## Using useContext in Hono\n\nThis code snippet demonstrates how to use the useContext hook in Hono to share data globally across any level of the Component tree without passing values through props.\n\n```tsx\nimport type { FC } from 'hono/jsx'\nimport { createContext, useContext } from 'hono/jsx'\n\nconst themes = {\n  light: {\n    color: '#000000',\n    background: '#eeeeee',\n  },\n  dark: {\n    color: '#ffffff',\n    background: '#222222',\n  },\n}\n\nconst ThemeContext = createContext(themes.light)\n\nconst Button: FC = () => {\n  const theme = useContext(ThemeContext)\n  return <button style={theme}>Push!</button>\n}\n\nconst Toolbar: FC = () => {\n  return (\n    <div>\n      <Button />\n    </div>\n  )\n}\n\n// ...\n\napp.get('/', (c) => {\n  return c.html(\n    <div>\n      <ThemeContext.Provider value={themes.dark}>\n        <Toolbar />\n      </ThemeContext.Provider>\n    </div>\n  )\n})\n```\n\n### How it works\n\n1. A context is created using `createContext` and a default value is provided.\n2. The `useContext` hook is used within a component to access the current value of the context.\n3. The context provider is used to set a new value for the context within a certain part of the component tree.\n\n### Important notes\n\n- The useContext hook can only be used within a function component.\n- The value provided to the context provider will be used by all descendants of the provider that use the useContext hook.\n\n### References\n\n- [Hono documentation](https://hono.dev/docs)\n\n### Common use cases\n\n- Sharing theme information across an application\n- Sharing user data or other global state",
      "ruleTitle": "Using useContext to Share Data Globally in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create and use asynchronous components in Hono. Asynchronous components allow for non-blocking operations, improving the performance and user experience of the application.",
      "ruleFile": "## Async Component in Hono\n\nIn Hono, you can create asynchronous components using the `async`/`await` syntax. When you render it with `c.html()`, it will await automatically. This allows for non-blocking operations, improving the performance and user experience of the application.\n\nHere is a code snippet demonstrating this:\n\n```tsx\nconst AsyncComponent = async () => {\n  await new Promise((r) => setTimeout(r, 1000)) // sleep 1s\n  return <div>Done!</div>\n}\n\napp.get('/', (c) => {\n  return c.html(\n    <html>\n      <body>\n        <AsyncComponent />\n      </body>\n    </html>\n  )\n})\n```\n\nIn this code snippet, `AsyncComponent` is an asynchronous component that waits for 1 second before returning a div with the text 'Done!'. When this component is rendered using `c.html()`, it will automatically wait for the promise to resolve before rendering.\n\n### Important Notes\n\n- Asynchronous components in Hono are useful for operations that may take some time, such as fetching data from an API.\n- Be careful when using asynchronous components as they can lead to unexpected behavior if not handled properly. Always make sure to handle potential errors and consider what should be displayed while the component is loading.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common Use Cases\n\n- Fetching data from an API before rendering a component.\n- Performing calculations or other operations that may take some time before rendering a component.",
      "ruleTitle": "Creating and Using Asynchronous Components in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use Suspense with renderToReadableStream in Hono to handle asynchronous operations and provide a fallback UI while the component is loading. It also shows how to set the response headers for the stream.",
      "ruleFile": "## Using Suspense with renderToReadableStream in Hono\n\nThis code snippet demonstrates how to use Suspense with renderToReadableStream in Hono. Suspense allows you to specify a fallback UI to display while a component is loading, and renderToReadableStream allows you to render your JSX to a Node.js readable stream.\n\n```tsx\nimport { renderToReadableStream, Suspense } from 'hono/jsx/streaming'\n\n//...\n\napp.get('/', (c) => {\n  const stream = renderToReadableStream(\n    <html>\n      <body>\n        <Suspense fallback={<div>loading...</div>}>\n          <Component />\n        </Suspense>\n      </body>\n    </html>\n  )\n  return c.body(stream, {\n    headers: {\n      'Content-Type': 'text/html; charset=UTF-8',\n      'Transfer-Encoding': 'chunked',\n    },\n  })\n})\n```\n\n### How it works\n\n1. The `renderToReadableStream` function is used to render the JSX to a Node.js readable stream.\n2. The `Suspense` component is used to specify a fallback UI to display while the `Component` is loading.\n3. The `c.body` function is used to set the response body to the stream and the response headers.\n\n### Important notes\n\n- The 'Content-Type' header is set to 'text/html; charset=UTF-8' to indicate that the response is an HTML document.\n- The 'Transfer-Encoding' header is set to 'chunked' to indicate that the response body will be sent in chunks.\n\n### References\n\n- [Hono documentation](https://hono.dev/docs/guides/jsx)\n\n### Common use cases\n\n- Providing a fallback UI while a component is loading.\n- Rendering JSX to a Node.js readable stream.",
      "ruleTitle": "Using Suspense with renderToReadableStream in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle errors in child components using the ErrorBoundary component in Hono. It shows how to provide a fallback UI in case of an error, ensuring a better user experience and application stability.",
      "ruleFile": "## Error Handling in Hono using ErrorBoundary\n\nIn Hono, you can catch errors in child components using `ErrorBoundary`. This is useful to provide a fallback UI in case of an error, ensuring a better user experience and application stability.\n\nHere is an example of how to use it:\n\n```tsx\nfunction SyncComponent() {\n  throw new Error('Error')\n  return <div>Hello</div>\n}\n\napp.get('/sync', async (c) => {\n  return c.html(\n    <html>\n      <body>\n        <ErrorBoundary fallback={<div>Out of Service</div>}>\n          <SyncComponent />\n        </ErrorBoundary>\n      </body>\n    </html>\n  )\n})\n```\n\nIn this example, if an error occurs in `SyncComponent`, the `ErrorBoundary` will catch it and display the fallback UI (`<div>Out of Service</div>`).\n\nImportant notes:\n- `ErrorBoundary` can also be used with async components and `Suspense`.\n- The fallback UI can be any React component.\n\nCommon use cases include providing a user-friendly error message or a retry button when an error occurs in a component.",
      "ruleTitle": "Error Handling in Hono using ErrorBoundary",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle errors and loading states in asynchronous components using Hono's JSX and html middlewares. It shows how to use the ErrorBoundary and Suspense components to provide fallback UI when an error occurs or while the component is loading respectively.",
      "ruleFile": "## Handling Errors and Loading States in Asynchronous Components\n\nIn Hono, you can handle errors and loading states in asynchronous components using the ErrorBoundary and Suspense components. The ErrorBoundary component catches JavaScript errors anywhere in their child component tree, logs those errors, and displays a fallback UI. The Suspense component lets you specify a loading state while some suspended component is waiting to render.\n\nHere's an example of how you can use these components:\n\n```tsx\nasync function AsyncComponent() {\n  await new Promise((resolve) => setTimeout(resolve, 2000))\n  throw new Error('Error')\n  return <div>Hello</div>\n}\n\napp.get('/with-suspense', async (c) => {\n  return c.html(\n    <html>\n      <body>\n        <ErrorBoundary fallback={<div>Out of Service</div>}>\n          <Suspense fallback={<div>Loading...</div>}>\n            <AsyncComponent />\n          </Suspense>\n        </ErrorBoundary>\n      </body>\n    </html>\n  )\n})\n```\n\nIn this example, if an error is thrown in the AsyncComponent, the ErrorBoundary will catch it and display 'Out of Service'. If the AsyncComponent is still loading, the Suspense component will display 'Loading...'.\n\n### Important Notes\n\n- Error boundaries do not catch errors for:\n  - Event handlers\n  - Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)\n  - Server side rendering\n  - Errors thrown in the error boundary itself (rather than its children)\n\n### References\n\n- [React Error Boundaries](https://reactjs.org/docs/error-boundaries.html)\n- [React Suspense](https://reactjs.org/docs/concurrent-mode-suspense.html)\n\n### Common Use Cases\n\n- When you want to handle errors in a component and provide a fallback UI\n- When you want to display a loading state while a component is being loaded",
      "ruleTitle": "Handling Errors and Loading States in Asynchronous Components with Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to integrate JSX and html middlewares in Hono for powerful templating. It shows how to define interfaces for site data, create layout and content components using these interfaces, and use these components in a route handler to return HTML content.",
      "ruleFile": "## Rule: Integration of JSX and html middlewares in Hono\n\nThis rule demonstrates how to integrate JSX and html middlewares in Hono for powerful templating.\n\nHere is the code snippet:\n\n```tsx\nimport { Hono } from 'hono'\nimport { html } from 'hono/html'\n\nconst app = new Hono()\n\ninterface SiteData {\n  title: string\n  children?: any\n}\n\nconst Layout = (props: SiteData) =>\n  html`<!doctype html>\n    <html>\n      <head>\n        <title>${props.title}</title>\n      </head>\n      <body>\n        ${props.children}\n      </body>\n    </html>`\n\nconst Content = (props: { siteData: SiteData; name: string }) => (\n  <Layout {...props.siteData}>\n    <h1>Hello {props.name}</h1>\n  </Layout>\n)\n\napp.get('/:name', (c) => {\n  const { name } = c.req.param()\n  const props = {\n    name: name,\n    siteData: {\n      title: 'JSX with html sample',\n    },\n  }\n  return c.html(<Content {...props} />)\n})\n\nexport default app\n```\n\n### How it works\n\n1. The `SiteData` interface is defined to structure the site data.\n2. The `Layout` component is created using the `html` middleware and the `SiteData` interface.\n3. The `Content` component is created using the `Layout` component and additional props.\n4. In the route handler, the `Content` component is used to return HTML content.\n\n### Important notes\n\n- The `html` middleware is used to create HTML templates in Hono.\n- JSX is used to create components in Hono.\n\n### References\n\n- [Hono html middleware documentation](/docs/helpers/html)\n- [Hono JSX Renderer Middleware documentation](/docs/middleware/builtin/jsx-renderer)\n\n### Common use cases\n\n- Creating HTML pages in Hono using JSX and html middlewares.\n- Structuring site data using interfaces in TypeScript.",
      "ruleTitle": "Integration of JSX and html middlewares in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to extend the JSX type definitions in Hono to include custom elements and attributes. This is useful when you want to add your own custom elements and their attributes to the JSX type definitions, which allows you to use them in your JSX code.",
      "ruleFile": "## Override JSX Type Definitions in Hono\n\nIn Hono, you can override the JSX type definitions to include your own custom elements and attributes. This is useful when you want to use your own custom elements in your JSX code.\n\nHere is an example of how to do this:\n\n```ts\ndeclare module 'hono/jsx' {\n  namespace JSX {\n    interface IntrinsicElements {\n      'my-custom-element': HTMLAttributes & {\n        'x-event'?: 'click' | 'scroll'\n      }\n    }\n  }\n}\n```\n\nIn this code snippet, a new custom element called 'my-custom-element' is added to the JSX type definitions. This custom element has an attribute 'x-event' which can take the values 'click' or 'scroll'.\n\n### How it works\n\nThe 'declare module' statement is used to extend the module 'hono/jsx'. Inside this, a new namespace 'JSX' is declared. Inside this namespace, the 'IntrinsicElements' interface is extended to include the new custom element and its attributes.\n\n### Important notes\n\n- The custom element name should be a string.\n- The custom attribute names should be strings and their possible values should be specified.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/guides/jsx)\n\n### Common use cases\n\n- When you want to use your own custom elements in your JSX code.\n- When you want to add new attributes to existing elements.",
      "ruleTitle": "Overriding JSX Type Definitions in Hono",
      "sourcePath": "docs/guides/jsx.md",
      "category": "guides"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to configure the default router in Hono using the SmartRouter. The SmartRouter is a special type of router that selects the best router from the registered routers based on routing speed. This configuration is crucial for optimizing the performance of your Hono application.",
      "ruleFile": "## Configuring the Default Router in Hono\n\nIn Hono, you can configure the default router using the SmartRouter. The SmartRouter is a special type of router that selects the best router from the registered routers based on routing speed.\n\nHere is a code snippet demonstrating this:\n\n```ts\n// Inside the core of Hono.\nreadonly defaultRouter: Router = new SmartRouter({\n  routers: [new RegExpRouter(), new TrieRouter()],\n})\n```\n\nIn this code snippet, the default router is set to a new instance of SmartRouter. The SmartRouter is initialized with an array of routers - RegExpRouter and TrieRouter.\n\nWhen the application starts, the SmartRouter selects the fastest router from the registered routers and continues to use it for routing.\n\n### Important Notes\n\n- The SmartRouter automatically selects the fastest router based on routing speed. This helps in optimizing the performance of your Hono application.\n\n### References\n\n- [Hono Documentation](https://hono.bosch.io/docs/)\n\n### Common Use Cases\n\n- Use this configuration when you want to optimize the performance of your Hono application by automatically selecting the fastest router.",
      "ruleTitle": "Configuring the Default Router in Hono",
      "sourcePath": "docs/concepts/routers.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates the performance comparison of different routers in Hono. It shows that the LinearRouter is significantly faster than other routers, which can be crucial for applications where performance is a key factor.",
      "ruleFile": "## Performance Comparison of Hono Routers\n\nThis code snippet demonstrates a performance comparison of different routers in Hono. The routers compared are LinearRouter, MedleyRouter, FindMyWay, KoaTreeRouter, and TrekRouter.\n\n```console\nâ€¢ GET /user/lookup/username/hey\n----------------------------------------------------- -----------------------------\nLinearRouter     1.82 Âµs/iter      (1.7 Âµs â€¦ 2.04 Âµs)   1.84 Âµs   2.04 Âµs   2.04 Âµs\nMedleyRouter     4.44 Âµs/iter     (4.34 Âµs â€¦ 4.54 Âµs)   4.48 Âµs   4.54 Âµs   4.54 Âµs\nFindMyWay       60.36 Âµs/iter      (45.5 Âµs â€¦ 1.9 ms)  59.88 Âµs  78.13 Âµs  82.92 Âµs\nKoaTreeRouter    3.81 Âµs/iter     (3.73 Âµs â€¦ 3.87 Âµs)   3.84 Âµs   3.87 Âµs   3.87 Âµs\nTrekRouter       5.84 Âµs/iter     (5.75 Âµs â€¦ 6.04 Âµs)   5.86 Âµs   6.04 Âµs   6.04 Âµs\n\nsummary for GET /user/lookup/username/hey\n  LinearRouter\n   2.1x faster than KoaTreeRouter\n   2.45x faster than MedleyRouter\n   3.21x faster than TrekRouter\n   33.24x faster than FindMyWay\n```\n\n### How it works\n\nThe benchmarking results show the time taken for each iteration by the different routers. The LinearRouter is the fastest, followed by KoaTreeRouter, MedleyRouter, TrekRouter, and FindMyWay.\n\n### Important notes\n\nFor situations like Fastly Compute, it's better to use LinearRouter with the `hono/quick` preset as it provides the best performance.\n\n### References\n\n- Hono Documentation\n\n### Common use cases\n\n- When performance is a key factor in your application, consider using the LinearRouter.",
      "ruleTitle": "Performance Comparison of Hono Routers",
      "sourcePath": "docs/concepts/routers.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to deploy a minified version of a Hono application using the PatternRouter. Minifying the application can be crucial in environments with limited resources, as it reduces the size of the application.",
      "ruleFile": "## Deploying a Minified Hono Application Using PatternRouter\n\nThis code snippet demonstrates how to deploy a minified version of a Hono application using the PatternRouter. The PatternRouter is a feature of Hono that allows for a smaller application size, which can be beneficial in environments with limited resources.\n\n```console\n$ npx wrangler deploy --minify ./src/index.ts\n â›…ï¸ wrangler 3.20.0\n-------------------\nTotal Upload: 14.68 KiB / gzip: 5.38 KiB\n```\n\n### How it works\n\nThe `npx wrangler deploy --minify ./src/index.ts` command deploys a minified version of the application located at `./src/index.ts`. The `--minify` flag instructs wrangler to minify the application, reducing its size.\n\n### Important notes\n\n- The size of the minified application is displayed after the deployment process. In this case, the total upload size is 14.68 KiB.\n\n### References\n\n- [Hono PatternRouter Documentation](https://hono.bouzuya.net/)\n\n### Common use cases\n\n- Deploying a Hono application in an environment with limited resources.",
      "ruleTitle": "Deploying a Minified Hono Application Using PatternRouter",
      "sourcePath": "docs/concepts/routers.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes in Hono. It shows the standard way of defining HTTP methods and paths for different endpoints in an application. Understanding this rule is crucial for setting up the application's routing system, which is responsible for directing incoming requests to the appropriate handlers.",
      "ruleFile": "## Defining Routes in Hono\n\nThis code snippet demonstrates how to define routes in Hono. Each route is an object with a `method` and a `path` property. The `method` property specifies the HTTP method (e.g., GET, POST, PUT, DELETE), and the `path` property specifies the URL path for the route.\n\n```ts\ninterface Route {\n  method: string\n  path: string\n}\n// ---cut---\nconst routes: (Route & { name: string })[] = [\n  {\n    name: 'short static',\n    method: 'GET',\n    path: '/user',\n  },\n```\n\n### How it Works\n\nWhen a request is made to the application, Hono matches the request's method and URL with the defined routes. If a match is found, the request is directed to the corresponding handler.\n\n### Important Notes\n\n- Routes are matched in the order they are defined. Therefore, if two routes could match the same URL, the first one defined will be used.\n\n- The `*` character in a path (e.g., '/static/*') is a wildcard that matches any sequence of characters.\n\n### References\n\n- [Hono Documentation](https://hono.bosch.io/docs/)\n\n### Common Use Cases\n\n- Defining routes for different functionalities in a web application.\n- Setting up a RESTful API with different endpoints.",
      "ruleTitle": "Defining Routes in Hono",
      "sourcePath": "docs/concepts/benchmarks.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates the performance comparison of Hono with other routers for Cloudflare Workers. It shows that Hono is the fastest among the compared routers. This information is crucial for developers when choosing a router for their Cloudflare Workers, as performance can greatly impact the efficiency and user experience of their applications.",
      "ruleFile": "## Performance Comparison of Hono with Other Routers for Cloudflare Workers\n\nThis code demonstrates the performance comparison of Hono with other routers for Cloudflare Workers. The results are presented in the form of screenshots.\n\n```text\nLet's see the results.\n\n### On Node.js\n\nThe following screenshots show the results on Node.js.\n\n![bench](/images/bench01.png)\n\n![bench](/images/bench02.png)\n\n![bench](/images/bench03.png)\n\n![bench](/images/bench04.png)\n\n![bench](/images/bench05.png)\n\n![bench](/images/bench06.png)\n\n![bench](/images/bench07.png)\n\n![bench](/images/bench08.png)\n\n### On Bun\n\nThe following screenshots show the results on Bun.\n\n![bench](/images/bench09.png)\n\n![bench](/images/bench10.png)\n\n![bench](/images/bench11.png)\n\n![bench](/images/bench12.png)\n\n![bench](/images/bench13.png)\n\n![bench](/images/bench14.png)\n\n![bench](/images/bench15.png)\n\n![bench](/images/bench16.png)\n\n## Cloudflare Workers\n\n**Hono is the fastest**, compared to other routers for Cloudflare Workers.\n\n- Machine: Apple MacBook Pro, 32 GiB, M1 Pro\n- Scripts: [benchmarks/handle-event](https://github.com/honojs/hono/tree/main/benchmarks/handle-event)\n```\n\n### How it Works\n\nThe performance of different routers is tested on different platforms (Node.js, Bun, and Cloudflare Workers). The results are then compared to determine the fastest router.\n\n### Important Notes\n\n- Performance can greatly impact the efficiency and user experience of applications.\n- Developers should consider the performance of routers when choosing one for their applications.\n\n### References\n\n- [Hono GitHub](https://github.com/honojs/hono/tree/main/benchmarks/handle-event)\n\n### Common Use Cases\n\n- Choosing a router for Cloudflare Workers.\n- Comparing the performance of different routers.",
      "ruleTitle": "Performance Comparison of Hono with Other Routers for Cloudflare Workers",
      "sourcePath": "docs/concepts/benchmarks.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a GET endpoint in Hono that returns a JSON response. It also shows how to validate query parameters using Zod, which is crucial for ensuring the integrity and security of the data received in the request.",
      "ruleFile": "## Creating a GET Endpoint and Validating Query Parameters in Hono\n\nThis code snippet demonstrates how to create a GET endpoint in Hono that returns a JSON response. It also shows how to validate query parameters using Zod.\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/hello', (c) => {\n  return c.json({\n    message: `Hello!`,\n  })\n})\n```\n\nTo validate the query parameters, you can use Zod. Here's how you can do it:\n\n```ts\nimport { zValidator } from '@hono/zod-validator'\nimport { z } from 'zod'\n\napp.get(\n  '/hello',\n  zValidator(\n    'query',\n    z.object({\n      name: z.string(),\n    })\n  ),\n  (c) => {\n    const { name } = c.query\n    // ... rest of the code\n  }\n)\n```\n\nThis works by defining a schema for the query parameters using Zod and then using the `zValidator` middleware from Hono to validate the query parameters against this schema.\n\n### Important Notes\n\n- Always validate the input data to prevent security vulnerabilities and ensure the integrity of the data.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n- [Zod Documentation](https://github.com/colinhacks/zod)\n\n### Common Use Cases\n\n- Creating API endpoints that return JSON responses.\n- Validating query parameters in API requests.",
      "ruleTitle": "Creating a GET Endpoint and Validating Query Parameters in Hono",
      "sourcePath": "docs/concepts/stacks.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define and validate query parameters in Hono using zod. It also shows how to extract the validated parameters and use them in the route handler. This is crucial for ensuring that the incoming requests meet the expected format and for preventing potential errors due to invalid data.",
      "ruleFile": "## Rule: Defining and Validating Query Parameters in Hono\n\nIn Hono, you can define and validate query parameters using zod. This is done using the `zValidator` function, which takes two arguments: the type of the parameter ('query' in this case) and a zod schema defining the expected format of the parameter. The validated parameters can then be extracted using the `valid` method on the request object.\n\nHere is an example:\n\n```ts\napp.get(\n  '/hello',\n  zValidator(\n    'query',\n    z.object({\n      name: z.string(),\n    })\n  ),\n  (c) => {\n    const { name } = c.req.valid('query')\n    return c.json({\n      message: `Hello! ${name}`,\n    })\n  }\n)\n```\n\nIn this example, the 'name' query parameter is expected to be a string. If the incoming request does not meet this expectation, Hono will automatically respond with an error.\n\nThis approach is beneficial because it ensures that the incoming requests meet the expected format and prevents potential errors due to invalid data.",
      "ruleTitle": "Defining and Validating Query Parameters in Hono",
      "sourcePath": "docs/concepts/stacks.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a client object in Hono by passing the `AppType` type to `hc` as generics. This enables the endpoint path and request type to be suggested, improving code completion and reducing the likelihood of errors.",
      "ruleFile": "## Creating a Client Object in Hono\n\nThis code snippet demonstrates how to create a client object in Hono by passing the `AppType` type to `hc` as generics. This enables the endpoint path and request type to be suggested, improving code completion and reducing the likelihood of errors.\n\n```ts\nimport { AppType } from './server'\nimport { hc } from 'hono/client'\n\nconst client = hc<AppType>('/api')\nconst res = await client.hello.$get({\n  query: {\n    name: 'Hono',\n  },\n})\n```\n\n### How it works\n\n1. Import the `AppType` from the server file and `hc` from 'hono/client'.\n2. Create a client object by passing the `AppType` type to `hc` as generics.\n3. The endpoint path and request type are suggested, improving code completion.\n\n### Important notes\n\n- The `AppType` type should be defined in the server file and should match the structure of the server.\n\n### References\n\n- Hono documentation: https://hono.bayrell.org/\n\n### Common use cases\n\n- Creating a client object in a Hono application.",
      "ruleTitle": "Creating a Client Object in Hono",
      "sourcePath": "docs/concepts/stacks.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the Hono client to make a GET request to a server and retrieve data. It also shows how to parse the response using the json() method, which is compatible with the fetch API. This is crucial for developers to understand as it forms the basis of how data is retrieved from servers using Hono.",
      "ruleFile": "## Hono Client GET Request and Response Parsing\n\nThis code snippet demonstrates how to use the Hono client to make a GET request to a server and retrieve data. It also shows how to parse the response using the json() method.\n\n```ts\nimport { AppType } from './server'\nimport { hc } from 'hono/client'\n\nconst client = hc<AppType>('/api')\nconst res = await client.hello.$get({\n  query: {\n    name: 'Hono',\n  },\n})\n\nconst data = await res.json()\nconsole.log(`${data.message}`)\n```\n\n### How it works\n\n1. The Hono client is imported and initialized with the API endpoint.\n2. A GET request is made to the 'hello' endpoint with a query parameter.\n3. The response is parsed using the json() method, which is compatible with the fetch API.\n\n### Important notes\n\n- The json() method returns a Promise that resolves with the result of parsing the body text as JSON.\n\n### References\n\n- [Hono Client Documentation](https://hono.bayrell.org/en/latest/docs/client/)\n\n### Common use cases\n\n- Retrieving data from a server using a GET request.\n- Parsing the response data to JSON.",
      "ruleTitle": "Using Hono Client for GET Requests and Response Parsing",
      "sourcePath": "docs/concepts/stacks.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use Hono with React on Cloudflare Pages. It shows how to create applications and handle server-side changes. Understanding this rule is crucial for developers to effectively use Hono in a React environment and handle API responses.",
      "ruleFile": "## Hono with React on Cloudflare Pages\n\nThis code snippet demonstrates how to use Hono with React on Cloudflare Pages. It also shows how to handle server-side changes.\n\n```ts\n// functions/api/[[route]].ts\nimport { Hono } from 'hono'\nimport { handle } from 'hono/cloudflare-pages'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\n\nconst app = new Ho\n```\n\n### How it works\n\n1. Import the necessary modules from Hono, zod, and hono/zod-validator.\n2. Initialize a new Hono application.\n\n### Important notes\n\n- Hono is compatible with the fetch API, but the data that can be retrieved with `json()` has a type.\n- Sharing API specifications allows you to be aware of server-side changes.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common use cases\n\n- Creating applications on Cloudflare Pages using React.\n- Handling server-side changes in a Hono application.",
      "ruleTitle": "Using Hono with React on Cloudflare Pages",
      "sourcePath": "docs/concepts/stacks.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes and handle requests in Hono, a web framework. It also shows how to use React Query for data fetching in a React application. Understanding this rule is crucial for building scalable and maintainable web applications with Hono and React.",
      "ruleFile": "## Defining Routes and Handling Requests in Hono and Using React Query for Data Fetching\n\nThis code snippet demonstrates how to define routes and handle requests in Hono, and how to use React Query for data fetching in a React application.\n\n```tsx\nreturn c.json({\n  message: 'created!',\n})\n})\n.get((c) => {\n  return c.json({\n    todos,\n  })\n})\n\nexport type AppType = typeof route\n\nexport const onRequest = handle(app, '/api')\n```\n\nIn the Hono part, `.get` and `.post` methods are used to define GET and POST routes respectively. The `c.json` method is used to send a JSON response.\n\nIn the React part, `useQuery` and `useMutation` hooks from React Query are used for data fetching and mutations respectively.\n\n### How it Works\n\nWhen a GET or POST request is made to the '/api' endpoint, the corresponding function is executed and a JSON response is sent.\n\nIn the React application, `useQuery` and `useMutation` hooks are used to fetch data and perform mutations respectively.\n\n### Important Notes\n\n- Make sure to correctly define the type of the route using `typeof`.\n- Use the `handle` function to handle requests to a specific route.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n- [React Query Documentation](https://react-query.tanstack.com/)\n\n### Common Use Cases\n\n- Building RESTful APIs with Hono\n- Fetching data in a React application using React Query",
      "ruleTitle": "Defining Routes and Handling Requests in Hono and Using React Query for Data Fetching",
      "sourcePath": "docs/concepts/stacks.md",
      "category": "concepts"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle multiple methods and paths, and how to extract path parameters in Hono. Understanding this rule allows developers to create more flexible and dynamic routes in their web applications.",
      "ruleFile": "## Multiple Methods, Paths and Path Parameters in Hono\n\nIn Hono, you can define routes that respond to multiple methods or paths. This is useful when you want to perform the same action for different HTTP methods or paths.\n\n```ts\n// Multiple Method\napp.on(['PUT', 'DELETE'], '/post', (c) =>\n  c.text('PUT or DELETE /post')\n)\n\n// Multiple Paths\napp.on('GET', ['/hello', '/ja/hello', '/en/hello'], (c) =>\n  c.text('Hello')\n)\n```\n\nAdditionally, Hono allows you to define path parameters. These are dynamic parts of the URL that can be captured and used in your route handler.\n\n```ts\n// Path Parameter\napp.get('/user/:name', async (c) => {\n  const name = c.req.param('name')\n  // ...\n})\n```\n\nIn the above example, `:name` is a path parameter. You can access its value using `c.req.param('name')`.\n\n### Important Notes\n\n- When defining multiple methods or paths, make sure they are in an array.\n- Path parameters are prefixed with a colon (`:`) and can be accessed using `c.req.param()`.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases\n\n- Creating CRUD (Create, Read, Update, Delete) operations where the same route is used with different HTTP methods.\n- Creating localized routes (e.g., `/en/hello`, `/ja/hello`).\n- Capturing user IDs or other data from the URL.",
      "ruleTitle": "Handling Multiple Methods, Paths and Path Parameters in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use path parameters in Hono. Path parameters are a crucial part of building RESTful APIs, allowing developers to create more dynamic routes. Understanding how to extract these parameters from the request is key to handling different types of requests and responses.",
      "ruleFile": "## Using Path Parameters in Hono\n\nIn Hono, you can define path parameters in your routes. These parameters can then be accessed in your route handlers.\n\nHere's an example of a route with a single path parameter:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.get('/user/:name', async (c) => {\n  const name = c.req.param('name')\n})\n```\n\nAnd here's an example of a route with multiple path parameters:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.get('/posts/:id/comment/:comment_id', async (c) => {\n  const { id, comment_id } = c.req.param()\n})\n```\n\nIn both examples, the parameters are defined in the route using the `:` prefix. They can then be accessed in the route handler using the `param` method on the request object (`c.req`).\n\n### Important Notes\n\n- Path parameters are a powerful tool for creating dynamic routes, but they should be used judiciously to avoid creating overly complex routes.\n- Always validate path parameters to ensure they are of the expected format and type.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common Use Cases\n\n- Retrieving a specific resource by its ID\n- Navigating nested resources (e.g., comments on a post)",
      "ruleTitle": "Using Path Parameters in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important because it demonstrates how to define routes with optional and dynamic parameters in Hono. Understanding this rule allows developers to create flexible and dynamic routes in their web applications.",
      "ruleFile": "## Dynamic and Optional Parameters in Hono Routes\n\nIn Hono, you can define routes with dynamic parameters and optional parameters. Dynamic parameters are defined by prefixing the parameter name with a colon `:`. Optional parameters are defined by appending a question mark `?` to the parameter name.\n\nHere is an example of a route with dynamic parameters:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.get('/posts/:id/comment/:comment_id', async (c) => {\n  const { id, comment_id } = c.req.param()\n  // ...\n})\n```\n\nIn this example, `:id` and `:comment_id` are dynamic parameters. The actual values for these parameters are provided in the URL when the route is accessed.\n\nHere is an example of a route with an optional parameter:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.get('/api/animal/:type?', (c) => c.text('Animal!'))\n```\n\nIn this example, `:type?` is an optional parameter. The route will match both `/api/animal` and `/api/animal/:type`.\n\n### Important Notes\n\n- Dynamic and optional parameters can be accessed via the `req.param()` method in the route handler.\n- Optional parameters make the route more flexible, but can also make it more ambiguous. Use them judiciously.\n\n### References\n\n- [Hono Documentation](https://hono.beyondnlp.com/)\n\n### Common Use Cases\n\n- Creating RESTful APIs with dynamic resource identifiers.\n- Creating routes that can handle different levels of specificity.",
      "ruleTitle": "Defining Routes with Dynamic and Optional Parameters in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define dynamic routes with parameters and regular expressions in Hono. It shows how to extract parameters from the request and how to define routes that include slashes or are chained.",
      "ruleFile": "## Hono Dynamic Routing\n\nIn Hono, you can define dynamic routes with parameters and regular expressions. This allows you to create more flexible and powerful routing patterns.\n\nHere are some examples:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\n// Define a route with parameters and regular expressions\napp.get('/post/:date{[0-9]+}/:title{[a-z]+}', async (c) => {\n  const { date, title } = c.req.param()\n  // ...\n})\n\n// Define a route that includes slashes\napp.get('/posts/:filename{.+\\.png}', async (c) => {\n  //...\n})\n```\n\nIn the first example, the route includes two parameters, `date` and `title`, which are constrained by regular expressions. The `date` parameter must be a number, and the `title` parameter must be a lowercase string.\n\nIn the second example, the route includes a parameter `filename` that can include slashes, as indicated by the regular expression `.+\\.png`.\n\nTo extract the parameters from the request, you can use `c.req.param()`.\n\n### Important Notes\n\n- The regular expressions in the route definitions are used to validate the parameters. If a parameter does not match the regular expression, the route will not match.\n\n### References\n\n- [Hono Documentation](https://hono.bryntum.com/docs)\n\n### Common Use Cases\n\n- Creating blog post URLs that include the post date and title\n- Serving static files with dynamic paths",
      "ruleTitle": "Defining Dynamic Routes in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes in Hono framework using chained methods and how to include slashes in the route parameters. It also shows how to handle different HTTP methods for the same endpoint.",
      "ruleFile": "## Hono Routing: Chained Methods and Including Slashes\n\nIn Hono, you can chain methods to define routes for different HTTP methods on the same endpoint. You can also include slashes in the route parameters.\n\nHere's an example:\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/posts/:filename{.+\\.png}', async (c) => {\n  //...\n})\n```\n\nIn the above code, `app.get('/posts/:filename{.+\\.png}', async (c) => {...})` defines a GET route where the `:filename` parameter can include slashes.\n\nHere's another example:\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp\n  .get('/endpoint', (c) => {\n    return c.text('GET /endpoint')\n  })\n  .post((c) => {\n    return c.text('POST /endpoint')\n  })\n```\n\nIn the above code, `app.get('/endpoint', (c) => {...})` and `app.post((c) => {...})` define GET and POST routes for the same endpoint.\n\n### Important Notes\n\n- The `{.+\\.png}` in the route parameter is a regular expression that matches any string that includes a `.png` extension.\n- The `c` parameter in the route handler function is the context object, which provides methods and properties related to the HTTP request and response.\n\n### References\n\n- [Hono API Documentation](https://hono.beyondco.de/docs/routing)\n\n### Common Use Cases\n\n- Defining routes for different HTTP methods on the same endpoint.\n- Including slashes in route parameters when necessary.",
      "ruleTitle": "Defining Routes with Chained Methods and Including Slashes in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to group routes using the Hono instance and add them to the main application using the route method. This is a common practice in web development to organize routes in a clean and maintainable way.",
      "ruleFile": "## Grouping Routes in Hono\n\nIn Hono, you can group the routes with the Hono instance and add them to the main app with the route method. This helps in organizing your routes in a clean and maintainable way.\n\nHere is a code snippet demonstrating this:\n\n```ts\nimport { Hono } from 'hono'\n\nconst book = new Hono()\n\nbook.get('/', (c) => c.text('List Books')) // GET /book\nbook.get('/:id', (c) => {\n  // GET /book/:id\n  const id = c.req.pa\n```\n\nIn this snippet, we are creating a new Hono instance and grouping the routes for 'book'. We then add these routes to the main app using the route method.\n\n### How it works\n\n1. Import the Hono module.\n2. Create a new Hono instance.\n3. Define your routes using the get method on the Hono instance.\n4. Add these routes to the main app using the route method.\n\n### Important notes\n\n- Grouping routes helps in maintaining a clean codebase and improves readability.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common use cases\n\n- When you have multiple routes related to a specific resource (like 'book' in this case), you can group them using a Hono instance.",
      "ruleTitle": "Grouping Routes in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to group multiple instances in Hono without changing the base. It shows how to define different HTTP methods (GET and POST) for the same route ('/book') and how to use the 'route' method to add these routes to the Hono application. Understanding this pattern is crucial for organizing routes in a Hono application.",
      "ruleFile": "## Grouping Routes Without Changing Base in Hono\n\nThis code demonstrates how to group multiple instances in Hono without changing the base. It shows how to define different HTTP methods (GET and POST) for the same route ('/book') and how to use the 'route' method to add these routes to the Hono application.\n\n```ts\nimport { Hono } from 'hono'\n\nconst book = new Hono()\nbook.get('/book', (c) => c.text('List Books'))\nbook.post('/book', (c) => c.text('Create Book'))\n\nconst app = new Hono()\napp.route('/book', book)\n```\n\n### How it works\n\n1. A new Hono instance 'book' is created.\n2. The 'get' and 'post' methods are used to define GET and POST routes for '/book'.\n3. A new Hono application 'app' is created.\n4. The 'route' method is used to add the 'book' routes to the 'app'.\n\n### Important notes\n\n- The 'route' method is used to add a group of routes to a Hono application.\n- The base of the routes remains unchanged when they are added to the application.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common use cases\n\n- Grouping related routes in a Hono application.\n- Defining different HTTP methods for the same route.",
      "ruleTitle": "Grouping Routes Without Changing Base in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes and specify base paths in Hono. It shows how to handle different HTTP methods (GET, POST) for different routes and how to set a base path for all routes. Understanding this is crucial for building applications with Hono as it forms the basis of how requests are handled and responses are served.",
      "ruleFile": "## Defining Routes and Base Paths in Hono\n\nIn Hono, you can define routes and specify the base path for all routes. This is crucial for handling different HTTP methods for different routes and serving responses.\n\nHere is a code snippet demonstrating this:\n\n```ts\nimport { Hono } from 'hono'\n\nconst user = new Hono()\nuser.get('/', (c) => c.text('List Users')) // GET /user\nuser.post('/', (c) => c.text('Create User')) // POST /user\n\nconst app = new Hono()\napp.route('/', book) // Handle /book\napp.route('/', user) // Handle /user\n\nconst api = new Hono().basePath('/api')\napi.get('/book', (c) => c.text('List Books')) // GET /api/book\n```\n\nIn this snippet:\n\n- `user.get('/', (c) => c.text('List Users'))` defines a GET route at `/user` that responds with 'List Users'.\n- `user.post('/', (c) => c.text('Create User'))` defines a POST route at `/user` that responds with 'Create User'.\n- `app.route('/', book)` and `app.route('/', user)` attach the `book` and `user` routes to the main `app`.\n- `const api = new Hono().basePath('/api')` sets the base path for all routes to `/api`.\n\n### Important Notes\n\n- The base path is prefixed to all routes. So, `api.get('/book', (c) => c.text('List Books'))` will handle GET requests at `/api/book`.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common Use Cases\n\n- Building APIs with different routes and methods.\n- Grouping routes under a common base path.",
      "ruleTitle": "Defining Routes and Base Paths in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define the base path and routing with hostname in Hono. It shows how to use the basePath method to set a base path for all routes and how to use the get method to define a route. It also shows how to use the getPath option to customize the path extraction from the request.",
      "ruleFile": "## Defining Base Path and Routing with Hostname in Hono\n\nThis code demonstrates how to define the base path and routing with hostname in Hono.\n\n```ts twoslash\nimport { Hono } from 'hono'\n// ---cut---\nconst api = new Hono().basePath('/api')\napi.get('/book', (c) => c.text('List Books')) // GET /api/book\n```\n\nIn the above code, the basePath method is used to set '/api' as the base path for all routes. The get method is then used to define a route '/book' which responds with 'List Books' when accessed.\n\n```ts twoslash\nimport { Hono } from 'hono'\n// ---cut---\nconst app = new Hono({\n  getPath: (req) => req.url.replace(/^https?:\\/\\/([^?]+).*$/, '$1'),\n})\n\napp.get('/www1.example.com/hello', (c) => c.text('hello'))\n```\n\nIn the above code, the getPath option is used to customize the path extraction from the request. The get method is then used to define a route '/www1.example.com/hello' which responds with 'hello' when accessed.\n\n### Important Notes\n\n- The basePath method sets the base path for all routes.\n- The get method is used to define a route.\n- The getPath option can be used to customize the path extraction from the request.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common Use Cases\n\n- Defining a base path for all routes in an application.\n- Defining routes in an application.\n- Customizing path extraction from the request.",
      "ruleTitle": "Defining Base Path and Routing with Hostname in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle the 'host' header value in Hono by setting the 'getPath()' function in the Hono constructor. This allows for dynamic routing based on the host header value, which can be useful in multi-tenant applications or when serving different content based on the domain.",
      "ruleFile": "## Routing with `host` Header value in Hono\n\nIn Hono, you can handle the `host` header value by setting the `getPath()` function in the Hono constructor. This allows for dynamic routing based on the host header value.\n\nHere is an example:\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono({\n  getPath: (req) =>\n    '/' +\n    req.headers.get('host') +\n    req.url.replace(/^https?:\\/\\/[^/]+(\\/[^?]*).*/, '$1'),\n})\n```\n\nIn this example, the `getPath()` function is used to construct a path that includes the host header value and the original URL path. This can be useful in multi-tenant applications or when serving different content based on the domain.\n\n### Important notes\n\n- The `getPath()` function is called for every request, so it should be as efficient as possible.\n\n### References\n\n- [Hono documentation](https://hono.bike/)\n\n### Common use cases\n\n- Multi-tenant applications\n- Serving different content based on the domain",
      "ruleTitle": "Handling the 'host' Header Value in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how routing works in Hono and how the order of registration affects the routing priority. It shows that the first matching route is selected, and subsequent routes are ignored. This is crucial for developers to understand to avoid unexpected behavior in their applications.",
      "ruleFile": "## Routing in Hono and Routing Priority\n\nIn Hono, routes are matched in the order they are registered. This means that if a request matches multiple routes, the first one registered will be used.\n\nHere's an example:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.get('/book/a', (c) => c.text('a'))\napp.get('/book/:slug', (c) => c.text('common'))\n```\n\nIn this example, a GET request to '/book/a' will match the first route and return 'a', even though it could also match the second route.\n\nThis behavior is important to keep in mind when designing your application's routing. If you have overlapping routes, make sure to register the more specific ones first.\n\nAlso, you can change the routing by `User-Agent` header which can be useful for serving different content or layouts to different types of devices or browsers.",
      "ruleTitle": "Understanding Routing and Routing Priority in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates the routing mechanism in Hono and how the order of route handlers matters. It shows that once a handler is executed, the process will be stopped, and no further handlers will be executed. This is crucial to understand to avoid unexpected behavior in the application.",
      "ruleFile": "## Hono Routing and Handler Execution Order\n\nThis code snippet demonstrates the routing mechanism in Hono and the importance of the order of route handlers.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/book/a', (c) => c.text('a')) // a\napp.get('/book/:slug', (c) => c.text('common')) // common\n```\n\nIn this example, if a GET request is made to `/book/a`, the response will be `a`. If a GET request is made to `/book/b`, the response will be `common`.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('*', (c) => c.text('common')) // common\napp.get('/foo', (c) => c.text('foo')) // foo\n```\n\nIn this example, regardless of the specific route, the response will be `common` because the wildcard handler is executed first.\n\n### How it works\n\nHono executes the handlers in the order they are defined. Once a handler is executed, the process will be stopped, and no further handlers will be executed.\n\n### Important notes\n\nThe order of defining route handlers in Hono is crucial. If a wildcard handler is defined before a specific route handler, the specific route handler will never be executed.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common use cases\n\n- Defining specific route handlers before wildcard handlers to handle specific routes differently.\n- Using wildcard handlers to provide a default response for unspecified routes.",
      "ruleTitle": "Understanding Hono Routing and Handler Execution Order",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates the order of middleware and route handlers in Hono. Middleware functions are functions that have access to the request object, the response object, and the next function in the applicationâ€™s request-response cycle. The next function is a function in the Hono application, when invoked, executes the middleware succeeding the current middleware. Middleware functions can perform the following tasks: execute any code, make changes to the request and the response objects, end the request-response cycle, call the next middleware in the stack. If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging. The order in which middleware and route handlers are declared matters, as they will be executed in that order.",
      "ruleFile": "## Middleware and Route Handlers Order in Hono\n\nIn Hono, the order in which middleware and route handlers are declared matters, as they will be executed in that order.\n\nHere is an example:\n\n```ts\nimport { Hono } from 'hono'\nimport { logger } from 'hono/logger'\nconst app = new Hono()\n// ---cut---\napp.use(logger())\napp.get('/foo', (c) => c.text('foo'))\n```\n\nIn this example, the `logger()` middleware is declared before the route handler for '/foo'. This means that the logger middleware will be executed before the route handler whenever a GET request is made to '/foo'.\n\n### How it works\n\nWhen a request is made to the Hono application, it goes through the middleware and route handlers in the order they were declared. If a middleware does not call the `next()` function, the request-response cycle will end there and the following middleware or route handlers will not be executed.\n\n### Important notes\n\n- Always declare middleware that you want to execute before route handlers above the route handlers.\n\n### References\n\n- [Hono Middleware](https://hono.bevry.me/docs/middleware)\n\n### Common use cases\n\n- Logging requests before they reach the route handlers.\n- Authenticating requests before they reach the route handlers.",
      "ruleTitle": "Order of Middleware and Route Handlers in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up a fallback route in Hono. A fallback route is a route that will be used when no other routes match the incoming request. This is useful for handling unknown routes or displaying a 404 page.",
      "ruleFile": "## Fallback Route in Hono\n\nIn Hono, you can create a fallback route that will be used when no other routes match the incoming request. This is done by defining a route with a wildcard '*' as the path.\n\nHere is an example:\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/bar', (c) => c.text('bar')) // bar\napp.get('*', (c) => c.text('fallback')) // fallback\n```\n\nIn this example, if a GET request is made to '/bar', the response will be 'bar'. If a GET request is made to any other path, the response will be 'fallback'.\n\n### How it works\n\nWhen a request is made, Hono will try to match the request's path with the paths of the routes that have been defined. It starts from the top and goes down. If it finds a match, it will use that route. If it doesn't find a match, it will use the fallback route.\n\n### Important notes\n\n- The order of the routes is important. The fallback route should be defined last.\n\n### References\n\n- [Hono documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Displaying a 404 page when the requested route does not exist.",
      "ruleTitle": "Setting Up a Fallback Route in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates the correct ordering and grouping of routes in Hono. It shows how the `route()` function works by taking the stored routing from the second argument and adding it to its own routing. This is crucial for the correct functioning of the application, as incorrect ordering or grouping of routes can lead to unexpected behavior or errors.",
      "ruleFile": "## Grouping and Ordering of Routes in Hono\n\nThis code snippet demonstrates the correct way to group and order routes in Hono.\n\n```ts\nthree.get('/hi', (c) => c.text('hi'))\ntwo.route('/three', three)\napp.route('/two', two)\n\nexport default app\n```\n\nIn this example, the `route()` function takes the stored routing from the second argument (such as `three` or `two`) and adds it to its own (`two` or `app`) routing. This results in the following route: `GET /two/three/hi ---> 'hi'`.\n\nIt's important to note that mistakes in grouping or ordering of routes can be hard to notice but can lead to unexpected behavior or errors. Therefore, it's crucial to pay attention to the order in which routes are defined and grouped.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases\n\n- Defining nested routes in a web application\n- Grouping related routes under a common path",
      "ruleTitle": "Correct Grouping and Ordering of Routes in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how routing works in Hono. It shows that the order in which routes are defined matters and can affect the response of the application. If routes are not properly nested, it can lead to 404 errors.",
      "ruleFile": "## Rule: Correct Order of Nested Routes in Hono\n\nThis code snippet demonstrates the correct order of defining nested routes in Hono.\n\n```ts\nthree.get('/hi', (c) => c.text('hi'))\ntwo.route('/three', three)\napp.route('/two', two)\n\nexport default app\n```\n\nIn this example, the route '/two/three/hi' will return a 200 response with the text 'hi'. However, if the routes are defined in the wrong order, it will return a 404 error.\n\n### How it works\n\nIn Hono, routes are defined using the `.route()` method. This method takes a path as its first argument and a Hono instance as its second. The second Hono instance will handle any requests that match the given path.\n\n### Important notes\n\n- The order in which routes are defined matters. If routes are not properly nested, it can lead to 404 errors.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common use cases\n\n- Defining nested routes in a Hono application.",
      "ruleTitle": "Correct Order of Nested Routes in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important because it demonstrates the significance of the order in which routes are defined in Hono. The order of route definition determines the order in which the routes are matched and handled. If routes are defined in the wrong order, it could lead to unexpected 404 errors.",
      "ruleFile": "## Route Definition Order in Hono\n\nIn Hono, the order in which routes are defined is crucial. The order of route definition determines the order in which the routes are matched and handled. If routes are defined in the wrong order, it could lead to unexpected 404 errors.\n\nHere is an example:\n\n```ts\nthree.get('/hi', (c) => c.text('hi'))\ntwo.route('/three', three)\napp.route('/two', two)\n\nexport default app\n```\n\nIn this example, the route '/two/three/hi' will return a 200 response. However, if the routes are defined in the wrong order, it will return a 404.\n\n```ts\nthree.get('/hi', (c) => c.text('hi'))\napp.route('/two', two) // `two` does not have '/three' route defined yet\n```\n\n### How it works\n\nWhen a request is made, Hono matches the routes in the order they were defined. If a matching route is found, the corresponding handler is invoked. If no matching route is found, a 404 error is returned.\n\n### Important notes\n\n- Always define routes in the order they should be matched.\n- Be careful when defining nested routes. The parent route should be defined before the child route.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common use cases\n\n- Defining nested routes\n- Handling 404 errors",
      "ruleTitle": "Importance of Route Definition Order in Hono",
      "sourcePath": "docs/api/routing.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle HTTP requests and send responses using Hono. It shows how to extract headers from the request, and how to send a text response. Understanding this is crucial for building web applications with Hono.",
      "ruleFile": "## Handling HTTP Requests and Sending Responses in Hono\n\nThis code snippet demonstrates how to handle HTTP GET requests and send responses using Hono. It shows how to extract headers from the request, and how to send a text response.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.get('/hello', (c) => {\n  const userAgent = c.req.header('User-Agent')\n  return c.text(`Hello, ${userAgent}`)\n})\n```\n\nIn this example, a GET request is made to the '/hello' endpoint. The `c.req.header('User-Agent')` is used to extract the 'User-Agent' header from the request. The `c.text()` method is then used to send a text response to the client.\n\nWhen returning Text or HTML, it is recommended to use `c.text()` or `c.html()`. You can also set headers with `c.header()` and set HTTP status code with `c.status`. This can also be set in `c.text()`, `c.json()` and so on.",
      "ruleTitle": "Handling HTTP Requests and Sending Responses in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set HTTP headers, status code, and response body in Hono. Understanding this is crucial for creating HTTP responses in a Hono application.",
      "ruleFile": "## Setting HTTP Headers, Status Code, and Response Body in Hono\n\nThis code snippet demonstrates how to set HTTP headers, status code, and response body in Hono.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\napp.get('/welcome', (c) => {\n  c.header('X-Message', 'Hello!')\n  c.header('Content-Type', 'text/plain')\n\n  // Set HTTP status code\n  c.status(201)\n\n  // Return the response body\n  return c.body('Thank you for coming')\n})\n```\n\nAlternatively, you can also set the status code and headers while returning the response body as follows:\n\n```ts\napp.get('/welcome', (c) => {\n  return c.body('Thank you for coming', 201, {\n    'X-Message': 'Hello!',\n    'Content-Type': 'text/plain'\n  })\n})\n```\n\n### How it Works\n\nIn Hono, you can use the `header` method of the context object `c` to set HTTP headers. The `status` method is used to set the HTTP status code. The `body` method is used to set the response body.\n\n### Important Notes\n\n- The `header` method takes two arguments: the name of the header and its value.\n- The `status` method takes one argument: the HTTP status code.\n- The `body` method can take up to three arguments: the response body, the status code, and an object containing headers.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases\n\n- Sending custom headers in the HTTP response.\n- Setting a specific HTTP status code.\n- Returning a response body.",
      "ruleTitle": "Setting HTTP Headers, Status Code, and Response Body in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define a GET route in Hono and how to return a custom response with a specific status code and headers. It shows the flexibility of Hono in handling HTTP responses, which is crucial for building web applications.",
      "ruleFile": "## Defining a GET Route and Returning Custom Response in Hono\n\nThis code snippet demonstrates how to define a GET route in Hono and how to return a custom response with a specific status code and headers.\n\n```javascript\nconst { Hono } = require('hono')\nconst app = new Hono()\n\napp.get('/welcome', (c) => {\n  return c.body('Thank you for coming', 201, {\n    'X-Message': 'Hello!',\n    'Content-Type': 'text/plain',\n  })\n})\n```\n\nIn this example, a GET route '/welcome' is defined. When this route is hit, it returns a response with the body 'Thank you for coming', a status code of 201, and custom headers 'X-Message' and 'Content-Type'.\n\nThis shows the flexibility of Hono in handling HTTP responses, which is crucial for building web applications.\n\n### Important Notes\n\n- The `c.body()` function is used to set the response body, status code, and headers.\n- The status code and headers are optional. If not provided, Hono will use default values.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases\n\n- Returning custom responses in web applications.\n- Setting custom headers for responses.",
      "ruleTitle": "Defining a GET Route and Returning Custom Response in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle different types of responses in Hono. It shows how to send a custom response, render text as 'Content-Type:text/plain', and render JSON as 'Content-Type:application/json'. Understanding these response types is crucial for building APIs that can handle different types of data and respond appropriately to client requests.",
      "ruleFile": "## Hono Response Handling\n\nThis code demonstrates how to handle different types of responses in Hono.\n\n### Custom Response\n\nYou can send a custom response by creating a new instance of the `Response` class and passing in the response message, status, and headers.\n\n```ts\new Response('Thank you for coming', {\n  status: 201,\n  headers: {\n    'X-Message': 'Hello!',\n    'Content-Type': 'text/plain',\n  },\n})\n```\n\n### Text Response\n\nYou can render text as 'Content-Type:text/plain' by using the `text()` method.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/say', (c) => {\n  return c.text('Hello!')\n})\n```\n\n### JSON Response\n\nYou can render JSON as 'Content-Type:application/json' by using the `json()` method.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/json', (c) => {\n  return c.json({ message: 'Hello!' })\n})\n```\n\nThese methods are part of Hono's context object, which is passed to every route handler. They provide a convenient way to send different types of responses to the client.",
      "ruleTitle": "Handling Different Types of Responses in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "These code snippets demonstrate how to use Hono's built-in methods for handling different types of HTTP responses. Understanding these methods is crucial for building web applications with Hono, as they allow developers to easily send HTML content, handle not found errors, and perform redirects.",
      "ruleFile": "## Hono HTTP Response Methods\n\nThis rule demonstrates how to use Hono's built-in methods for handling different types of HTTP responses.\n\n### html()\n\nRender HTML as `Content-Type:text/html`.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.get('/', (c) => {\n  return c.html('<h1>Hello! Hono!</h1>')\n})\n```\n\n### notFound()\n\nReturn the `Not Found` Response.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.get('/notfound', (c) => {\n  return c.notFound()\n})\n```\n\n### redirect()\n\nRedirect, default status code is `302`.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.get('/redirect', (c) => {\n  return c.redirect('/new-location')\n})\n```\n\nThese methods are part of Hono's context object, which is passed to each route handler. They provide a simple and intuitive way to handle common HTTP responses.",
      "ruleTitle": "Handling HTTP Responses in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle not found and redirection responses in Hono. Understanding these methods is crucial for managing routing and user navigation within a Hono application.",
      "ruleFile": "## Handling Not Found and Redirection Responses in Hono\n\nThis code snippet demonstrates how to handle not found and redirection responses in Hono.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\napp.get('/notfound', (c) => {\n  return c.notFound()\n})\n\napp.get('/redirect', (c) => {\n  return c.redirect('/')\n})\n```\n\nIn the above code:\n\n1. The `notFound()` method is used to return a 'Not Found' response when the '/notfound' route is accessed.\n2. The `redirect()` method is used to redirect the user to the root route ('/') when the '/redirect' route is accessed. By default, the status code for this redirection is `302`.\n\n### Important Notes\n\n- The `notFound()` and `redirect()` methods are part of the context (`c`) object provided by Hono.\n- The `redirect()` method can also accept a second argument specifying a different status code.\n\n### References\n\n- [Hono Documentation](https://hono.bryntum.com/docs)\n\n### Common Use Cases\n\n- Use the `notFound()` method to handle routes that do not exist in your application.\n- Use the `redirect()` method to redirect users after certain actions, such as successful form submission or login.",
      "ruleTitle": "Handling Not Found and Redirection Responses in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use middleware in Hono to set and append headers to the response object. It shows how to use the 'set' function to add arbitrary key-value pairs to the context object, which can be used to pass specific values between middleware or from middleware to route handlers.",
      "ruleFile": "## set() / get() in Hono Middleware\n\nThis code snippet demonstrates how to use middleware in Hono to set and append headers to the response object. It also shows how to use the 'set' function to add arbitrary key-value pairs to the context object.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\n// Response object\napp.use('/', async (c, next) => {\n  await next()\n  c.res.headers.append('X-Debug', 'Debug message')\n})\n```\n\nIn this code snippet, the middleware function is used to append a 'X-Debug' header with the value 'Debug message' to the response object. The 'set' function is used to add a 'message' key with the value 'Hono is cool!!' to the context object.\n\nThis allows passing specific values between middleware or from middleware to route handlers. It is a common practice in Hono to use middleware for such purposes.\n\n### Important notes\n\n- The 'set' function can be used to add arbitrary key-value pairs to the context object.\n- The 'get' function can be used to retrieve the value of a key from the context object.\n- The lifetime of these key-value pairs is the current request.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Passing specific values between middleware or from middleware to route handlers.\n- Adding custom headers to the response object.",
      "ruleTitle": "Using set() / get() and Response Headers in Hono Middleware",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use generics in Hono to make the code type-safe. It shows how to pass variables to the constructor of Hono, which ensures that the values of 'c.set' and 'c.get' are retained and correctly typed. This is a best practice in Hono framework usage as it reduces the risk of runtime errors due to incorrect types.",
      "ruleFile": "## Using Generics in Hono for Type Safety\n\nThis code snippet demonstrates how to use generics in Hono to make the code type-safe. By passing the `Variables` to the constructor of `Hono`, we can ensure that the values of 'c.set' and 'c.get' are retained and correctly typed.\n\n```ts\nimport { Hono } from 'hono'\n\ntype Variables = {\n  message: string\n}\n\nconst app = new Hono<{ Variables: Variables }>()\n```\n\n### How it works\n\nIn this code, we define a type `Variables` with a property `message` of type `string`. We then pass this type as a generic to the constructor of `Hono`. This means that when we use 'c.set' and 'c.get', the values are correctly typed as `string`.\n\n### Important notes\n\n- Using generics in this way is a best practice in Hono framework usage as it reduces the risk of runtime errors due to incorrect types.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common use cases\n\n- Storing and retrieving variables in a Hono application\n- Ensuring type safety in a Hono application",
      "ruleTitle": "Using Generics in Hono for Type Safety",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the Hono framework to create type-safe applications and how to manage and access variables within the same request. It also highlights the limitation of `c.set` / `c.get` in that they cannot be shared or persisted across different requests.",
      "ruleFile": "## Hono Framework: Type-Safety and Variable Management\n\nThis code demonstrates how to use the Hono framework to create type-safe applications and how to manage and access variables within the same request.\n\n```ts twoslash\nimport { Hono } from 'hono'\n// ---cut---\ntype Variables = {\n  message: string\n}\n\nconst app = new Hono<{ Variables: Variables }>()\n```\n\nIn the above code, a type `Variables` is defined and passed to the constructor of `Hono` to make it type-safe.\n\nThe value of `c.set` / `c.get` are retained only within the same request. They cannot be shared or persisted across different requests.\n\nYou can also access the value of a variable with `c.var`.\n\n```ts twoslash\nimport type { Context } from 'hono'\ndeclare const c: Context\n// ---cut---\nconst result = c.var.client.oneMethod()\n```\n\nIn the above code, `c.var` is used to access the value of a variable.\n\n### Important Notes\n\n- The value of `c.set` / `c.get` are retained only within the same request. They cannot be shared or persisted across different requests.\n- You can access the value of a variable with `c.var`.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common Use Cases\n\n- Creating type-safe applications with Hono\n- Managing and accessing variables within the same request",
      "ruleTitle": "Type-Safety and Variable Management in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to access the value of a variable using 'c.var' in Hono and how to create a middleware that provides a custom method. Understanding this rule allows developers to effectively utilize Hono's capabilities to manage variables and create custom methods in middleware.",
      "ruleFile": "## Accessing Variable Values and Creating Custom Middleware Methods in Hono\n\nThis code demonstrates how to access the value of a variable using 'c.var' and how to create a middleware that provides a custom method in Hono.\n\n```ts twoslash\nimport type { Context } from 'hono'\ndeclare const c: Context\n// ---cut---\nconst result = c.var.client.oneMethod()\n```\n\nTo create a middleware that provides a custom method, you can follow the example below:\n\n```ts twoslash\nimport { Hono } from 'hono'\nimport { createMiddleware } from 'hono/factory'\n// ---cut---\ntype Env = {\n  Variables: {\n    echo: (str: string) => string\n  }\n}\n\nconst app = new Hono()\n```\n\n### How it works\n\nIn the first snippet, 'c.var' is used to access the value of a variable. In the second snippet, a custom method is created in the middleware by defining a new type 'Env' and initializing a new Hono application.\n\n### Important notes\n\n- 'c.var' is a powerful feature in Hono that allows for efficient variable management.\n- Custom methods in middleware can be created to extend the functionality of your Hono application.\n\n### References\n\n- [Hono Documentation](https://hono.bryntum.com/docs/)\n\n### Common use cases\n\n- Accessing variable values in Hono applications\n- Extending middleware functionality by creating custom methods",
      "ruleTitle": "Accessing Variable Values and Creating Custom Middleware Methods in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use middleware in multiple handlers using Hono web framework. It also shows how to make the middleware type-safe by passing the 'Env' as Generics to the constructor of 'Hono'. This is a common pattern in Hono framework usage and is a best practice for ensuring type safety and reusability of middleware.",
      "ruleFile": "## Using Middleware in Multiple Handlers and Ensuring Type Safety in Hono\n\nThis code snippet demonstrates how to use a middleware in multiple handlers using the Hono web framework. It also shows how to ensure type safety by passing the 'Env' as Generics to the constructor of 'Hono'.\n\n```ts\nconst echoMiddleware = createMiddleware<Env>(async (c, next) => {\n  c.set('echo', (str) => str)\n  await next()\n})\n\napp.get('/echo', echoMiddleware, (c) => {\n  return c.text(c.var.echo('Hello!'))\n})\n```\n\nIf you want to use the middleware in multiple handlers, you can use `app.use()`. Then, you have to pass the `Env` as Generics to the constructor of `Hono` to make it type-safe.\n\n### How it works\n\n1. The `echoMiddleware` is created using `createMiddleware` function of Hono. It sets a function 'echo' in the context 'c' that returns the input string.\n2. The middleware is then used in a GET handler for the route '/echo'. The handler uses the 'echo' function set in the context by the middleware to return a text response.\n3. If you want to use the middleware in multiple handlers, you can use `app.use(echoMiddleware)`.\n4. To ensure type safety, you can pass the `Env` as Generics to the constructor of `Hono`.\n\n### Important notes\n\n- Middleware in Hono can be used in multiple handlers, which promotes reusability.\n- Type safety can be ensured by passing the 'Env' as Generics to the constructor of 'Hono'.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common use cases\n\n- Using middleware for common functionality across multiple routes.\n- Ensuring type safety in middleware.",
      "ruleTitle": "Using Middleware in Multiple Handlers and Ensuring Type Safety in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the Hono framework to create a simple server with a custom middleware and an endpoint. It shows how to use the 'use' method to add middleware to the application and the 'get' method to define a GET request handler. The rule also demonstrates how to access environment variables in Hono using 'c.var'.",
      "ruleFile": "## Using Middleware and Environment Variables in Hono\n\nIn Hono, you can use the 'use' method to add middleware to your application. Middleware are functions that have access to the request object, the response object, and the next function in the applicationâ€™s request-response cycle. The next function is a function in the Hono stack that, when invoked, executes the middleware succeeding the current middleware.\n\nYou can also define a GET request handler using the 'get' method. The handler takes a callback function which receives a context object 'c'. This object contains the request and response objects, among other things.\n\nEnvironment variables can be accessed in Hono using 'c.var'.\n\nHere is an example:\n\n```javascript\nconst app = new Hono<Env>()\n\napp.use(echoMiddleware)\n\napp.get('/echo', (c) => {\n  return c.text(c.var.echo('Hello!'))\n})\n```\n\nIn this code, 'echoMiddleware' is a middleware function that is added to the application. The '/echo' endpoint returns the result of the 'echo' function defined in the environment variables with 'Hello!' as the argument.",
      "ruleTitle": "Using Middleware and Environment Variables in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `setRenderer` and `render` methods in Hono to create a custom HTML layout for responses. This is a common use case when building web applications with Hono, as it allows developers to easily customize the structure and appearance of their responses.",
      "ruleFile": "## Custom HTML Layouts in Hono\n\nThe following code snippet demonstrates how to use the `setRenderer` and `render` methods in Hono to create a custom HTML layout for responses.\n\n```javascript\napp.use(async (c, next) => {\n  c.setRenderer((content) => {\n    return c.html(\n      <html>\n        <body>\n          <p>{content}</p>\n        </body>\n      </html>\n    )\n  })\n  await next()\n})\n```\n\nThen, you can utilize `c.render()` to create responses within this layout.\n\n```javascript\napp.get('/', (c) => {\n  return c.render('Hello!')\n})\n```\nThe output of which will be:\n\n```html\n<html>\n  <body>\n    <p>Hello!</p>\n  </body>\n</html>\n```\n\n### How it Works\n\nThe `setRenderer` method is used to define a custom renderer for responses. This renderer is a function that takes a content parameter and returns an HTML string. The `render` method is then used to create responses using this custom layout.\n\n### Important Notes\n\n- The `setRenderer` method should be called in a middleware function to ensure that it is set before any routes are processed.\n- The `render` method should be used in route handlers to create responses using the custom layout.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common Use Cases\n\n- Creating custom HTML layouts for responses in a web application.",
      "ruleTitle": "Creating Custom HTML Layouts in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `c.render()` function in Hono to create responses within a layout. It also shows how to ensure type safety by defining types. This is a fundamental aspect of building applications with the Hono framework, as it allows developers to create dynamic responses and maintain type safety.",
      "ruleFile": "## Using `c.render()` to Create Responses in Hono\n\nIn Hono, you can use the `c.render()` function to create responses within a layout. Here is an example:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\napp.get('/', (c) => {\n  return c.render('Hello!')\n})\n```\n\nThe output of this code will be:\n\n```html\n<html>\n  <body>\n    <p>Hello!</p>\n  </body>\n</html>\n```\n\nAdditionally, this feature offers the flexibility to customize arguments. To ensure type safety, types can be defined as follows:\n\n```ts\ndeclare m\n```\n\n### How it Works\n\nThe `c.render()` function takes a string argument and wraps it in a basic HTML layout. This is useful for creating dynamic responses in your Hono application.\n\n### Important Notes\n\n- The `c.render()` function only supports string arguments.\n- To ensure type safety, you can define types using the `declare` keyword.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common Use Cases\n\n- Creating dynamic responses in a Hono application.\n- Ensuring type safety by defining types.",
      "ruleTitle": "Creating Responses with `c.render()` and Ensuring Type Safety in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define a route in Hono and render a response. It also shows how to ensure type safety by defining types for the arguments in the ContextRenderer interface. This is crucial in maintaining the integrity of the code and avoiding potential runtime errors.",
      "ruleFile": "## Defining Routes and Rendering Responses in Hono\n\nThis code snippet demonstrates how to define a route in Hono and render a response. It also shows how to ensure type safety by defining types for the arguments in the ContextRenderer interface.\n\n```javascript\nconst app = new Hono()\napp.get('/', (c) => {\n  return c.render('Hello!')\n})\n```\n\nIn the above code, a new Hono application is created and a GET route for the root URL ('/') is defined. The callback function takes a context object 'c' and uses its 'render' method to send a response.\n\nTo ensure type safety, types can be defined for the arguments in the ContextRenderer interface as shown below:\n\n```typescript\ndeclare module 'hono' {\n  interface ContextRenderer {\n    (\n      content: string | Promise<string>,\n      head: { title: string }\n    ): Response | Promise<Response>\n  }\n}\n```\n\nThis ensures that the 'content' argument can be a string or a Promise that resolves to a string, and the 'head' argument is an object with a 'title' property of type string. The function can return a Response object or a Promise that resolves to a Response object.\n\n### Important Notes\n\n- The 'render' method of the context object is used to send a response to the client.\n- Type definitions help in maintaining the integrity of the code and avoiding potential runtime errors.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common Use Cases\n\n- Defining routes and rendering responses in a Hono application.\n- Ensuring type safety in a TypeScript project.",
      "ruleTitle": "Defining Routes and Rendering Responses in Hono with Type Safety",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define and use a custom context renderer in Hono. Context renderers are used to render the response of a route handler in a custom way. This is useful when you want to modify the response of a route handler without changing the handler itself.",
      "ruleFile": "## Custom Context Renderer in Hono\n\nIn Hono, you can define a custom context renderer to render the response of a route handler in a custom way. This is useful when you want to modify the response of a route handler without changing the handler itself.\n\nHere is how you can define a custom context renderer:\n\n```ts\ndeclare module 'hono' {\n  interface ContextRenderer {\n    (\n      content: string | Promise<string>,\n      head: { title: string }\n    ): Response | Promise<Response>\n  }\n}\n```\n\nAnd here is how you can use it in a route handler:\n\n```ts\napp.use('/pages/*', async (c, next) => {\n  c.setRenderer((content, head) => {\n    return c.html(\n      <html>\n        <head>\n          <title>{head.title}</title>\n        </head>\n        <body>\n```\n\n## How it works\n\nThe `setRenderer` method sets the context renderer for the current route handler. The context renderer is a function that takes the content and head as arguments and returns a response.\n\n## Important notes\n\n- The context renderer is only used for the current route handler. If you want to use it for all route handlers, you need to set it in a middleware.\n\n## References\n\n- [Hono documentation](https://hono.bouzuya.net/)\n\n## Common use cases\n\n- Customizing the response of a route handler\n- Adding common headers or footers to the response",
      "ruleTitle": "Defining and Using a Custom Context Renderer in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'render' method in Hono to return HTML content with a specific title. This is a common use case when building web applications with Hono, as it allows developers to dynamically generate and serve HTML content.",
      "ruleFile": "## Rendering HTML Content with a Title in Hono\n\nThis code snippet demonstrates how to use the 'render' method in Hono to return HTML content with a specific title. This is a common use case when building web applications with Hono, as it allows developers to dynamically generate and serve HTML content.\n\n```javascript\napp.get('/pages/my-favorite', (c) => {\n  return c.render(<p>Ramen and Sushi</p>, {\n    title: 'My favorite',\n  })\n})\n\napp.get('/pages/my-hobbies', (c) => {\n  return c.render(<p>Watching baseball</p>, {\n    title: 'My hobbies',\n  })\n})\n```\n\nIn this example, two routes are defined: '/pages/my-favorite' and '/pages/my-hobbies'. When these routes are accessed, the 'render' method is called with two arguments: the HTML content to be displayed and an object with a 'title' property. The 'title' property is used to set the title of the HTML page.\n\nIt's important to note that the 'render' method expects the HTML content to be a valid JSX element. This means that you need to have a JSX transpiler (like Babel) in your project.\n\nCommon use cases for this pattern include serving dynamic HTML content based on user input or server-side data.",
      "ruleTitle": "Rendering HTML Content with a Title in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use bindings in Hono. Bindings are a way to access environment variables, secrets, KV namespaces, databases, and buckets that are bound to a worker. This is crucial for managing and accessing resources in a Cloudflare Workers environment.",
      "ruleFile": "## Using Bindings in Hono\n\nIn Hono, bindings are a way to access environment variables, secrets, KV namespaces, databases, and buckets that are bound to a worker. Regardless of type, bindings are always available as global variables and can be accessed via the context `c.env.BINDING_KEY`.\n\nHere is an example of how to use bindings in Hono:\n\n```ts\nimport { Hono } from 'hono'\ntype KVNamespace = any\n\n// Type definition to make type inference\ntype Bindings = {\n  MY_KV: KVNamespace\n}\n\nconst app = new Hono<{ Bindings: Bindings }>()\n\n// FetchEvent object (only set when using Service Worker syntax)\napp.get('/foo', async (c) => {\n  c.event.waitUntil(c.env.MY_KV.put(key, data))\n  // ...\n})\n```\n\nIn this code snippet, `MY_KV` is a binding of type `KVNamespace`. It is accessed via `c.env.MY_KV` in the handler for the GET request to '/foo'.\n\nThis pattern is important for managing and accessing resources in a Cloudflare Workers environment.",
      "ruleTitle": "Using Bindings in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle errors in Hono middleware. It shows that if a handler throws an error, the error object is placed in `c.error` and can be accessed in your middleware. This is crucial for error handling and debugging in your Hono application.",
      "ruleFile": "## Error Handling in Hono Middleware\n\nIn Hono, if a handler throws an error, the error object is placed in `c.error`. This can be accessed in your middleware for error handling and debugging.\n\nHere is a code snippet demonstrating this:\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.use(async (c, next) => {\n  await next()\n  if (c.error) {\n    // do something...\n  }\n})\n```\n\n### How it works\n\n1. Import the Hono framework and initialize a new Hono application.\n2. Use the `app.use` method to add a middleware to the application.\n3. In the middleware, call `await next()` to wait for the next middleware or route handler to finish.\n4. If there is an error in the handler, it will be placed in `c.error`. You can then handle the error as needed.\n\n### Important notes\n\n- Always check for `c.error` in your middleware to handle any errors that may occur in your handlers.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common use cases\n\n- Error logging: You can log the error to a logging service or to the console for debugging purposes.\n- Error response: You can send a response to the client with an error message and status code.",
      "ruleTitle": "Error Handling in Hono Middleware",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use middleware in Hono and how to extend the ContextVariableMap to add type definitions to variables when a specific middleware is used. This is crucial for enhancing the functionality of your application and for ensuring type safety within your middleware.",
      "ruleFile": "## Using Middleware and Extending ContextVariableMap in Hono\n\nThis code demonstrates how to use middleware in Hono and how to extend the `ContextVariableMap` to add type definitions to variables when a specific middleware is used.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.use(async (c, next) => {\n  await next()\n  if (c.error) {\n    // do something...\n  }\n})\n```\n\nTo extend `ContextVariableMap`, you can do the following:\n\n```ts\ndeclare module 'hono' {\n  interface ContextVariableMap {\n    result: string\n  }\n}\n```\n\nThis can then be utilized in your middleware:\n\n```ts\nimport { createMiddleware } from 'hono/factory'\n```\n\n### How it works\n\nIn the first snippet, a middleware is created that waits for the next middleware to finish before checking if there was an error. If there was an error, it performs a certain action.\n\nIn the second snippet, the `ContextVariableMap` is extended to include a new variable `result` of type string. This allows you to add type definitions to variables when a specific middleware is used.\n\n### Important notes\n\n- Middleware in Hono is used to handle requests and responses. It's a way to add functionality to your application.\n- Extending `ContextVariableMap` allows you to ensure type safety within your middleware.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs)\n\n### Common use cases\n\n- Error handling in middleware\n- Adding type definitions to variables in middleware",
      "ruleTitle": "Using Middleware and Extending ContextVariableMap in Hono",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to extend the 'ContextVariableMap' interface in Hono to add custom variables, and how to use these custom variables in middleware. This is a common pattern in Hono and allows for greater flexibility and customization in middleware functions.",
      "ruleFile": "## Extending ContextVariableMap in Hono and Using Custom Variables in Middleware\n\nThis code demonstrates how to extend the 'ContextVariableMap' interface in Hono to add custom variables, and how to use these custom variables in middleware.\n\n```ts\ndeclare module 'hono' {\n  interface ContextVariableMap {\n    result: string\n  }\n}\n```\n\nYou can then utilize this in your middleware:\n\n```ts twoslash\nimport { createMiddleware } from 'hono/factory'\n// ---cut---\nconst mw = createMiddleware(async (c, next) => {\n  c.set('result', 'some values') // result is a string\n  await next()\n})\n```\n\n### How it works\n\n1. The 'ContextVariableMap' interface is extended to include a new variable 'result'.\n2. This new variable is then used in a middleware function created using 'createMiddleware'.\n\n### Important notes\n\n- The new variable can be of any type, not just string.\n\n### References\n\n- Hono documentation: [Extending ContextVariableMap](https://hono.bryntum.com/docs/classes/contextvariablemap.html)\n\n### Common use cases\n\n- Adding custom data to the context that can be used across multiple middleware functions.",
      "ruleTitle": "Extending ContextVariableMap and Using Custom Variables in Middleware",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use middleware in Hono to set and retrieve variables. It shows how Hono's type inference works when setting and retrieving variables in the context object, ensuring type safety.",
      "ruleFile": "# Using Middleware to Set and Retrieve Variables in Hono\n\nThis code demonstrates how to use middleware in Hono to set and retrieve variables. It also shows how Hono's type inference works when setting and retrieving variables in the context object.\n\n```ts\nimport { createMiddleware } from 'hono/factory'\n\nconst mw = createMiddleware(async (c, next) => {\n  c.set('result', 'some values')\n  await next()\n})\n```\n\nIn a handler, the variable is inferred as the proper type:\n\n```ts\nimport { Hono } from 'hono'\n\nconst app = new Hono<{ Variables: { result: string } }>()\n\napp.get('/', (c) => {\n  const val = c.get('result')\n  return\n})\n```\n\n## How it Works\n\nThe `createMiddleware` function is used to create a middleware that sets a variable in the context object. The `c.set` function is used to set the variable. The `next` function is called to pass control to the next middleware.\n\nIn the handler, the `c.get` function is used to retrieve the variable. The type of the variable is inferred from the type of the `Variables` property in the `Hono` instance.\n\n## Important Notes\n\n- The `c.set` and `c.get` functions are used to set and retrieve variables in the context object.\n- The type of the variable is inferred from the type of the `Variables` property in the `Hono` instance.\n\n## References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n## Common Use Cases\n\n- Storing and retrieving data in middleware that needs to be accessed in handlers.",
      "ruleTitle": "Setting and Retrieving Variables in Hono Middleware",
      "sourcePath": "docs/api/context.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle authentication and throw custom HTTP exceptions in Hono. It shows how to use the HTTPException class to throw an error with a custom message and status code when authentication fails. This is a common pattern in web development to provide meaningful error messages to the client.",
      "ruleFile": "## Handling Authentication and Throwing Custom HTTP Exceptions in Hono\n\nThis code snippet demonstrates how to handle authentication and throw custom HTTP exceptions in Hono.\n\n```javascript\napp.post('/auth', async (c, next) => {\n  // authentication\n  if (authorized === false) {\n    throw new HTTPException(401, { message: 'Custom error message' })\n  }\n  await next()\n})\n```\n\nIn this code:\n\n1. An asynchronous function is defined for the '/auth' route.\n2. If the user is not authorized, an HTTPException is thrown with a status code of 401 and a custom error message.\n3. If the user is authorized, the next middleware function in the stack is called.\n\n### Important Notes\n\n- The HTTPException class is part of the 'hono/http-exception' module.\n- The status code and error message can be customized to fit the specific needs of your application.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/)\n\n### Common Use Cases\n\n- This pattern is commonly used in routes that require authentication.",
      "ruleTitle": "Handling Authentication and Throwing Custom HTTP Exceptions in Hono",
      "sourcePath": "docs/api/exception.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle HTTP exceptions in the Hono framework. Proper exception handling is crucial in any application to ensure that it can recover gracefully from errors and provide useful feedback to the user.",
      "ruleFile": "## Handling HTTPException in Hono\n\nIn Hono, you can handle the thrown HTTPException with `app.onError`.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\nimport { HTTPException } from 'hono/http-exception'\n\n// ...\n\napp.onError((err, c) => {\n  if (err instanceof HTTPException) {\n    // handle the exception\n  }\n})\n```\n\n### How it works\n\nThe `app.onError` method is used to register a function that will be called whenever an error is thrown in your application. This function takes two arguments: the error that was thrown and the current context.\n\nIn this case, we're checking if the error is an instance of `HTTPException`. If it is, we can handle it in a specific way.\n\n### Important notes\n\n- Make sure to import the `HTTPException` class from 'hono/http-exception'.\n- The `app.onError` method should be called after all your routes and middleware have been registered.\n\n### References\n\n- [Hono documentation](https://hono.bayfront.cloud/)\n\n### Common use cases\n\n- Returning a custom error response to the user.\n- Logging the error for debugging purposes.",
      "ruleTitle": "Handling HTTP Exceptions in Hono",
      "sourcePath": "docs/api/exception.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to extract parameters from the request URL in Hono. Understanding this rule is crucial for handling dynamic routes where the URL parameters can change based on the request.",
      "ruleFile": "## Extracting Parameters from Request URL\n\nIn Hono, you can extract parameters from the request URL using the `param()` method. This is useful when dealing with dynamic routes where the URL parameters can change based on the request.\n\nHere's a code snippet demonstrating this:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\n// Extracting a single parameter\napp.get('/entry/:id', async (c) => {\n  const id = c.req.param('id')\n})\n\n// Extracting multiple parameters at once\napp.get('/entry/:id/comment/:commentId', async (c) => {\n  const { id, commentId } = c.req.param()\n})\n```\n\nIn the first route, we're extracting a single parameter 'id' from the request URL. In the second route, we're extracting multiple parameters 'id' and 'commentId' at once using destructuring.\n\n### Important Notes\n\n- The `param()` method returns the value of the named route parameter.\n- When called without any arguments, it returns an object containing all the route parameters.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases\n\n- Retrieving blog post based on post ID\n- Fetching user profile based on user ID",
      "ruleTitle": "Extracting Parameters from Request URL in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle multiple query parameters in Hono. It shows how to extract multiple query parameters from a request using the queries() method. This is crucial in building APIs where endpoints often need to handle multiple query parameters.",
      "ruleFile": "## Handling Multiple Query Parameters in Hono\n\nIn Hono, you can handle multiple query parameters using the `queries()` method. This method returns an array of values for a given query parameter. Here's how you can use it:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\napp.get('/search', async (c) => {\n  // tags will be string[]\n  const tags = c.req.queries('tags')\n  // ...\n})\n```\n\nIn the above code, `tags` will be an array of strings containing the values of the 'tags' query parameter.\n\n### Important Notes\n\n- The `queries()` method returns an array of strings. If the query parameter is not present in the request, it returns an empty array.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common Use Cases\n\n- Filtering results based on multiple tags in a search API endpoint.",
      "ruleTitle": "Handling Multiple Query Parameters in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to extract query parameters from a request in Hono. Understanding how to retrieve query parameters is crucial for handling client requests and manipulating data based on these parameters.",
      "ruleFile": "## Extracting Query Parameters in Hono\n\nThis code snippet demonstrates how to extract query parameters from a request in Hono.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/search', async (c) => {\n  // tags will be string[]\n  const tags = c.req.queries('tags')\n  // ...\n})\n```\n\nIn this example, the `queries` method is used to retrieve the 'tags' query parameter from the request. The returned value will be an array of strings.\n\n### How it works\n\nThe `queries` method is a part of the request (`req`) object in Hono. It is used to retrieve the value of a specified query parameter. The parameter name is passed as an argument to the `queries` method.\n\n### Important notes\n\n- The `queries` method returns an array of strings. If the query parameter is not present in the request, it will return an empty array.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/)\n\n### Common use cases\n\n- Filtering data based on query parameters\n- Manipulating data based on query parameters",
      "ruleTitle": "Extracting Query Parameters in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important because it demonstrates how to correctly retrieve header values from a request in Hono. It shows that when calling the header() method with no arguments, all keys in the returned record are lowercase. Therefore, to get the value of a header with an uppercase name, it is necessary to call the header() method with the specific header name as an argument.",
      "ruleFile": "## Retrieving Header Values in Hono\n\nIn Hono, when you call the `header()` method with no arguments, all keys in the returned record are lowercase. Therefore, if you want to get the value of a header with an uppercase name, you need to call the `header()` method with the specific header name as an argument.\n\nHere is an example of how to do it correctly:\n\n```ts\n// âœ… Will work\nconst foo = c.req.header('X-Foo')\n```\n\nAnd here is an example of what will not work:\n\n```ts\n// âŒ Will not work\nconst headerRecord = c.req.header()\nconst foo = headerRecord['X-Foo']\n```\n\n### Important Notes\n\n- Always remember to use the specific header name as an argument when calling the `header()` method if the header name contains uppercase letters.\n\n### References\n\n- Hono Documentation\n\n### Common Use Cases\n\n- Retrieving specific header values from a request in Hono.",
      "ruleTitle": "Retrieving Header Values in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates the correct way to access headers and parse request bodies in Hono. It shows that headers should be accessed directly using the header name as a parameter in the `c.req.header()` function, rather than trying to access it as a property of the returned object. It also shows how to parse request bodies of type `multipart/form-data` or `application/x-www-form-urlencoded` using the `parseBody()` function.",
      "ruleFile": "## Accessing Headers and Parsing Request Bodies in Hono\n\nIn Hono, headers should be accessed directly using the header name as a parameter in the `c.req.header()` function. Trying to access it as a property of the returned object will not work.\n\n```ts\n// âŒ Will not work\nconst headerRecord = c.req.header()\nconst foo = headerRecord['X-Foo']\n\n// âœ… Will work\nconst foo = c.req.header('X-Foo')\n```\n\nTo parse request bodies of type `multipart/form-data` or `application/x-www-form-urlencoded`, use the `parseBody()` function.\n\n```ts\nc.req.parseBody()\n```\n\nThis function supports the following types of request bodies: `multipart/form-data` and `application/x-www-form-urlencoded`.\n\n### Important Notes\n\n- Always use the header name as a parameter when accessing headers.\n- Use `parseBody()` to parse request bodies of the supported types.\n\n### References\n\n- Hono Documentation\n\n### Common Use Cases\n\n- Accessing request headers\n- Parsing request bodies",
      "ruleTitle": "Accessing Headers and Parsing Request Bodies in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important because it demonstrates how to use the `parseBody()` function in Hono to handle POST requests. This is a common task in web development, and understanding how to do it properly in Hono is crucial for building robust applications.",
      "ruleFile": "## Using `parseBody()` in Hono to Handle POST Requests\n\nIn Hono, you can use the `parseBody()` function to parse the body of a POST request. This function supports various behaviors, including handling single file uploads.\n\nHere's an example of how to use it:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.post('/entry', async (c) => {\n  const body = await c.req.parseBody()\n  // ...\n})\n```\n\nIn this code snippet, `parseBody()` is used to parse the body of the request. The parsed body is then stored in the `body` variable.\n\nYou can access the parsed data like this:\n\n```ts\nimport { Context } from 'hono'\ndeclare const c: Context\nconst body = await c.req.parseBody()\nconst data = body['foo']\n```\n\nIn this case, `body['foo']` will be of type `(string | File)`, depending on whether the uploaded file was a string or a file.\n\n### Important Notes\n\n- `parseBody()` is an asynchronous function, so you need to use `await` when calling it.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common Use Cases\n\n- Parsing the body of a POST request to handle form submissions or file uploads.",
      "ruleTitle": "Handling POST Requests with `parseBody()` in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle multiple file uploads in Hono. It shows how to parse the request body to access the uploaded files and the importance of using the '[]' postfix for multiple files and the 'all' option for files with the same name.",
      "ruleFile": "## Handling Multiple File Uploads in Hono\n\nThis code snippet demonstrates how to handle multiple file uploads in Hono.\n\n```ts twoslash\nimport { Context } from 'hono'\ndeclare const c: Context\n// ---cut---\nconst body = await c.req.parseBody()\nbody['foo[]']\n```\n\nIn this example, `body['foo[]']` is always `(string | File)[]`. The '[]' postfix is required when dealing with multiple files.\n\nFor handling multiple files with the same name, the 'all' option is used.\n\n```ts twoslash\nimport { Context } from 'hono'\ndeclare const c: Context\n// ---cut---\nconst body = await c.req.parseBody({ all: true })\nbody['foo']\n```\n\nThe 'all' option is disabled by default. When enabled, it allows for handling multiple files with the same name.\n\n### Important Notes\n\n- The '[]' postfix is required for handling multiple files.\n- The 'all' option is disabled by default and needs to be enabled for handling multiple files with the same name.\n\n### References\n\n- Hono Documentation\n\n### Common Use Cases\n\n- Uploading multiple files in a single request\n- Handling files with the same name in a single request",
      "ruleTitle": "Handling Multiple File Uploads in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle multiple files with the same name and how to structure the return value based on the dot notation in Hono. Understanding these features allows developers to effectively parse and structure data in their applications.",
      "ruleFile": "## Handling Multiple Files and Structuring Return Values in Hono\n\nThis code demonstrates how to handle multiple files with the same name and how to structure the return value based on the dot notation in Hono.\n\n```ts\nimport { Context } from 'hono'\ndeclare const c: Context\n// ---cut---\nconst body = await c.req.parseBody({ all: true })\nbody['foo']\n```\n\nBy default, the `all` option is disabled. If `body['foo']` is multiple files, it will be parsed to `(string | File)[]`. If `body['foo']` is a single file, it will be parsed to `(string | File)`.\n\nIf you set the `dot` option `true`, the return value is structured based on the dot notation. For example, if you receive the following data:\n\n```ts\ndata.append('obj.key1', 'value1')\ndata.append('obj.key2', 'value2')\n```\n\nYou can get the structured value by setting the `dot` option `true`.\n\n### Important Notes\n\n- The `all` option allows you to parse all files, not just the first one with a specific name.\n- The `dot` option allows you to structure the return value based on the dot notation, which can be useful for handling complex data structures.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common Use Cases\n\n- Parsing form data with multiple files of the same name.\n- Structuring return values based on the dot notation for complex data structures.",
      "ruleTitle": "Handling Multiple Files and Structuring Return Values in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important because it demonstrates how to parse structured data from a FormData object in Hono. By setting the 'dot' option to true, the structured data can be extracted in a nested object format, which can be easier to work with in many scenarios.",
      "ruleFile": "## Parsing Structured FormData in Hono\n\nThis code snippet demonstrates how to parse structured data from a FormData object in Hono.\n\n```ts twoslash\nconst data = new FormData()\ndata.append('obj.key1', 'value1')\ndata.append('obj.key2', 'value2')\n```\n\nYou can get the structured value by setting the `dot` option `true`:\n\n```ts twoslash\nimport { Context } from 'hono'\ndeclare const c: Context\n// ---cut---\nconst body = await c.req.parseBody({ dot: true })\n// body is `{ obj: { key1: 'value1', key2: 'value2' } }`\n```\n\n### How it works\n\nThe `parseBody` method of the `req` object in Hono's Context is used to parse the FormData. By setting the `dot` option to true, the keys in the FormData object that are structured based on the dot notation are parsed into a nested object.\n\n### Important notes\n\n- The 'dot' option should be set to true if you want to parse structured data from FormData.\n\n### References\n\n- Hono Documentation\n\n### Common use cases\n\n- Parsing structured data from FormData in web applications.",
      "ruleTitle": "Parsing Structured FormData in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to parse the request body in Hono. Parsing the request body is a common task in web development, especially when dealing with POST requests. The rule shows how to parse the body as JSON, which is a common data format for APIs.",
      "ruleFile": "## Parsing Request Body in Hono\n\nThis code snippet demonstrates how to parse the request body in Hono. This is commonly done when handling POST requests, where the body often contains the data that the client wants to send to the server.\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.post('/entry', async (c) => {\n  const body = await c.req.json()\n  // ...\n})\n```\n\nIn this example, the `json()` method is used to parse the body as JSON. This is a common data format for APIs.\n\n### How it Works\n\nThe `json()` method is called on the `req` object, which represents the request. This method returns a promise that resolves with the parsed body.\n\n### Important Notes\n\n- The `json()` method can only parse JSON-formatted data. If the data is not in this format, an error will be thrown.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)\n\n### Common Use Cases\n\n- Parsing the body of a POST request to get the data sent by the client.",
      "ruleTitle": "Parsing Request Body in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to parse different types of request bodies in Hono. It shows how to parse JSON, text, and arrayBuffer types of request bodies. Understanding how to correctly parse request bodies is crucial for handling client requests and processing data in server-side applications.",
      "ruleFile": "## Parsing Request Bodies in Hono\n\nThis rule demonstrates how to parse different types of request bodies in Hono. The code snippets show how to parse JSON, text, and arrayBuffer types of request bodies.\n\n### Code Snippets\n\n#### JSON\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.post('/entry', async (c) => {\n  const body = await c.req.json()\n  // ...\n})\n```\n\n#### Text\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.post('/entry', async (c) => {\n  const body = await c.req.text()\n  // ...\n})\n```\n\n### How It Works\n\nIn each of the code snippets, a POST request is being made to the '/entry' endpoint. The request body is then parsed using the appropriate method depending on the content type of the request body.\n\n### Important Notes\n\nIt's crucial to use the correct parsing method for the content type of the request body. Using the wrong method could lead to errors or incorrect data processing.\n\n### References\n\n- Hono Documentation: [Request Parsing](https://hono.bike/docs/request-parsing/)\n\n### Common Use Cases\n\nParsing request bodies is a common task in server-side programming. It's typically done when a client sends data to the server via a POST or PUT request.",
      "ruleTitle": "Parsing Request Bodies in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to parse the request body as an `ArrayBuffer` in Hono. Understanding how to correctly parse the request body is crucial for handling client requests and processing data in the server.",
      "ruleFile": "## Parsing Request Body as ArrayBuffer in Hono\n\nThis code snippet demonstrates how to parse the request body as an `ArrayBuffer` in Hono.\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.post('/entry', async (c) => {\n  const body = await c.req.arrayBuffer()\n  // ...\n})\n```\n\n### How it works\n\nIn the given code, `app.post` is used to handle POST requests to the '/entry' endpoint. Inside the callback function, `c.req.arrayBuffer()` is used to parse the request body as an `ArrayBuffer`.\n\n### Important notes\n\n- The `arrayBuffer()` method returns a promise that resolves with an `ArrayBuffer` representing the request's body.\n- This method is useful when you need to handle binary data.\n\n### References\n\n- [Hono Documentation](https://hono.bryntum.com/docs/)\n\n### Common use cases\n\n- Receiving binary data like images or files from the client.",
      "ruleTitle": "Parsing Request Body as ArrayBuffer in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle and validate different types of incoming data in Hono. It shows how to use the 'valid' method to validate incoming data from different sources such as form, json, query, header, cookie, and param. This is crucial in ensuring that the data being processed by the application is as expected and helps prevent potential issues related to data integrity and security.",
      "ruleFile": "## Handling and Validating Incoming Data in Hono\n\nIn Hono, you can handle and validate incoming data from different sources using the 'valid' method. This method takes a string argument that specifies the source of the data.\n\nHere is a code snippet that demonstrates this:\n\n```ts\nc.app.post('/posts', async (c) => {\n  const { title, body } = c.req.valid('form')\n  // ...\n})\n```\n\nIn this example, the 'valid' method is used to validate data coming from a form. The validated data is then destructured into 'title' and 'body'.\n\nThe 'valid' method can handle data from the following sources:\n\n- `form`\n- `json`\n- `query`\n- `header`\n- `cookie`\n- `param`\n\nIt's important to validate incoming data to ensure that it is as expected and to prevent potential issues related to data integrity and security.\n\nReferences:\n\n- Hono documentation: [link]\n\nCommon use cases:\n\n- Validating form data before processing it\n- Checking the validity of incoming JSON data\n- Ensuring that query parameters meet certain criteria",
      "ruleTitle": "Handling and Validating Incoming Data in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'valid' method and 'routePath' method in Hono. The 'valid' method is used to get validated data from different targets such as form, json, query, header, cookie, and param. The 'routePath' method is used to retrieve the registered path within the handler.",
      "ruleFile": "## Using 'valid' and 'routePath' methods in Hono\n\nThis code demonstrates how to use the 'valid' method to get validated data from different targets and the 'routePath' method to retrieve the registered path within the handler.\n\n```ts\napp.post('/posts', async (c) => {\n  const { title, body } = c.req.valid('form')\n  // ...\n})\n```\n\n```ts\napp.get('/posts/:id', (c) => {\n  return c.json({ path: c.req.routePath })\n})\n```\n\n### How it works\n\nThe 'valid' method is used to get validated data from the specified target. The available targets are form, json, query, header, cookie, and param.\n\nThe 'routePath' method is used to retrieve the registered path within the handler.\n\n### Important notes\n\n- Make sure to use the correct target with the 'valid' method.\n- The 'routePath' method returns the path as registered in the app, not the actual URL.\n\n### References\n\n- [Validation section](/docs/guides/validation)\n\n### Common use cases\n\n- Use the 'valid' method to get validated data when handling form submissions or API requests.\n- Use the 'routePath' method to get the registered path for logging or debugging purposes.",
      "ruleTitle": "Using 'valid' and 'routePath' methods in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define a route with a parameter in Hono and how to access that parameter within the route handler. It also shows how to return the registered path within the handler. This is a fundamental concept in building web applications with Hono, as it allows developers to create dynamic routes that can handle a variety of requests.",
      "ruleFile": "## Defining and Accessing Route Parameters in Hono\n\nIn Hono, you can define a route with a parameter by using a colon (`:`) followed by the parameter name in the route string. You can then access this parameter within the route handler using the `req.routePath` property.\n\nHere is an example:\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/posts/:id', (c) => {\n  return c.json({ path: c.req.routePath })\n})\n```\n\nIf you access `/posts/123`, it will return `/posts/:id`:\n\n```json\n{ \"path\": \"/posts/:id\" }\n```\n\n### How it works\n\nWhen you define a route with a parameter in Hono, the framework automatically extracts the parameter from the incoming request URL and makes it available within the route handler through the `req.routePath` property.\n\n### Important notes\n\n- Route parameters are a powerful feature that allows you to create dynamic routes. However, they should be used judiciously to avoid creating overly complex routes that are difficult to maintain.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/routing)\n\n### Common use cases\n\n- Creating a blog post detail page where the post ID is dynamic.\n- Building a user profile page where the user ID is dynamic.",
      "ruleTitle": "Defining and Accessing Route Parameters in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle route parameters in Hono. It shows how to define a route with a parameter and how to access this parameter in the route handler. This is a common requirement in many web applications where the URL contains some dynamic part.",
      "ruleFile": "## Route Parameters Handling in Hono\n\nIn Hono, you can define routes with parameters and access these parameters in the route handler. Here is an example:\n\n```javascript\nconst app = new Hono()\napp.get('/posts/:id', (c) => {\n  return c.json({ path: c.req.routePath })\n})\n```\n\nIn this example, `:id` is a route parameter. When you access `/posts/123`, it will return `/posts/:id`:\n\n```json\n{ \"path\": \"/posts/:id\" }\n```\n\nThis is useful when you want to handle requests to different URLs in a similar way, but the exact URL is not known in advance. For example, you might want to display a specific post based on its ID, and the ID is part of the URL.\n\n### Important Notes\n\n- The route parameters are accessible through the `c.req.routePath` object.\n- The route parameters are always strings.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common Use Cases\n\n- Retrieving a specific resource based on its ID from the URL.\n- Handling requests to different URLs in a similar way.",
      "ruleTitle": "Handling Route Parameters in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to access the request pathname in Hono. Understanding how to retrieve the request pathname is crucial for routing and handling requests in a web application.",
      "ruleFile": "## Accessing the Request Pathname in Hono\n\nThis code demonstrates how to access the request pathname in Hono.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/about/me', async (c) => {\n  const pathname = c.req.path // `/about/me`\n  // ...\n})\n```\n\nIn this snippet, a GET request handler is set up for the path '/about/me'. Inside the handler, the request pathname is accessed using `c.req.path`. This will return the path of the request, in this case, '/about/me'.\n\n### Important Notes\n\n- The request object (`c.req`) contains information about the HTTP request that triggered the event. It includes properties such as `path` (the request pathname), `method` (the HTTP method), and `headers` (the HTTP headers).\n\n### References\n\n- [Hono Documentation](https://hono.bj/hono)\n\n### Common Use Cases\n\n- Use the request pathname to handle different routes in your application.\n- Use the request pathname to perform different actions based on the specific route.",
      "ruleTitle": "Accessing the Request Pathname in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to access the request pathname and URL in the Hono web framework. Understanding how to retrieve these values is crucial for handling requests and routing in web applications.",
      "ruleFile": "## Accessing Request Pathname and URL in Hono\n\nThis code demonstrates how to access the request pathname and URL in the Hono web framework.\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/about/me', async (c) => {\n  const pathname = c.req.path // `/about/me`\n  // ...\n})\n```\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/about/me', async (c) => {\n  const url = c.req.url // `http://localhost:8787/about/me`\n  // ...\n})\n```\n\nIn these snippets, `c.req.path` and `c.req.url` are used to access the request pathname and URL respectively. The `c` object is the context object passed to the route handler, which contains the request (`req`) and response (`res`) objects among other things.\n\n### Important Notes\n\n- The request pathname does not include the protocol or domain.\n- The request URL includes the protocol and domain.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common Use Cases\n\n- Checking the request pathname or URL to perform specific actions based on the route.\n- Logging the request pathname or URL for debugging or analytics purposes.",
      "ruleTitle": "Accessing Request Pathname and URL in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle HTTP GET requests in the Hono framework. It shows how to extract the URL and the method of the request, which are fundamental aspects of handling HTTP requests in any web framework.",
      "ruleFile": "## Handling HTTP GET Requests in Hono\n\nThis code snippet demonstrates how to handle HTTP GET requests in the Hono framework. It shows how to extract the URL and the method of the request.\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.get('/about/me', async (c) => {\n  const url = c.req.url // `http://localhost:8787/about/me`\n  // ...\n})\n```\n\nIn the above code, `app.get` is used to handle GET requests to the '/about/me' endpoint. The callback function takes a context object `c` as an argument, which contains the request and response objects. The URL of the request can be accessed with `c.req.url`, and the method of the request with `c.req.method`.\n\n### Important Notes\n\n- The context object `c` contains other useful properties and methods for handling the request and response.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common Use Cases\n\n- Retrieving the URL or method of the request is useful in many situations, such as logging, routing, or conditional processing based on the request details.",
      "ruleTitle": "Handling HTTP GET Requests in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to access the method name of the request and the raw request object in Hono. Understanding how to access these properties is crucial for handling different types of HTTP requests and for accessing raw request data when necessary.",
      "ruleFile": "## Accessing Request Method and Raw Request in Hono\n\nThe following code snippets demonstrate how to access the method name of the request and the raw request object in Hono.\n\nTo access the method name of the request:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\napp.get('/about/me', async (c) => {\n  const method = c.req.method // `GET`\n  // ...\n})\n```\n\nTo access the raw request object:\n\n```ts\n// For Cloudflare Workers\napp.post('/', async (c) => {\n  const metadata = c.req.raw.cf?.hostMetadata?\n  // ...\n})\n```\n\nIn the first snippet, `c.req.method` is used to access the method name of the request. In the second snippet, `c.req.raw` is used to access the raw request object.\n\nThese properties can be useful for handling different types of HTTP requests and for accessing raw request data when necessary.\n\nReferences:\n- [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n\nCommon use cases:\n- Checking the HTTP method of a request to perform different actions based on the method\n- Accessing raw request data for advanced use cases",
      "ruleTitle": "Accessing Request Method and Raw Request in Hono",
      "sourcePath": "docs/api/request.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle errors in the Hono framework. It shows how to use the `app.onError` method to handle any errors that occur during the execution of the application and return a customized response. This is crucial for robust error handling and providing meaningful feedback to the user.",
      "ruleFile": "## Custom Error Handling in Hono\n\nIn Hono, the `app.onError` method is used to handle any errors that occur during the execution of the application. This method takes a callback function as an argument, which is called when an error occurs. The callback function receives the error object and a context object as arguments.\n\nHere is a code snippet demonstrating this:\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\napp.onError((err, c) => {\n  console.error(`${err}`)\n  return c.text('Custom Error Message', 500)\n})\n```\n\nIn this example, when an error occurs, the error message is logged to the console and a custom error message is returned with a status code of 500.\n\n### Important Notes\n\n- The `app.onError` method should be used for error handling in Hono applications.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common Use Cases\n\n- Customizing error responses in a Hono application.",
      "ruleTitle": "Custom Error Handling in Hono",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle errors in Hono framework and how to use the `fire()` method to add a global `fetch` event listener. Understanding this rule is crucial for developers to ensure their applications can handle errors gracefully and respond to fetch events correctly.",
      "ruleFile": "## Handling Errors and Adding Fetch Event Listener in Hono\n\nThis code demonstrates how to handle errors and add a fetch event listener in Hono framework.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n\napp.onError((err, c) => {\n  console.error(`${err}`)\n  return c.text('Custom Error Message', 500)\n})\n```\n\nIn the above code, `app.onError()` is used to handle any errors that occur in the application. The error and the context are passed to the callback function, which logs the error and returns a custom error message with a status code of 500.\n\nThe `fire()` method is used to automatically add a global `fetch` event listener. This is useful in environments that adhere to the Service Worker API, such as non-ES module Cloudflare Workers.\n\n```ts\napp.fire()\n```\n\nThe `fire()` method executes the following for you:\n\n```ts\naddEventListener('fetch', (event: FetchEventLike): void => {\n  event.respondWith(this.dispatch(...))\n})\n```\n\nThis means that whenever a fetch event occurs, the application will automatically respond with the result of the `dispatch()` method.\n\n### References\n\n- [Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)\n- [Cloudflare Workers](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/)\n\n### Common Use Cases\n\n- Handling errors in a Hono application\n- Adding a fetch event listener to a Hono application",
      "ruleTitle": "Handling Errors and Adding Fetch Event Listener in Hono",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set up the entry point of an application using the Hono web framework. The entry point is crucial as it is the first point of contact for incoming requests to the application. Understanding how to correctly set this up is key to ensuring the application functions as expected.",
      "ruleFile": "## Setting up the Entry Point in Hono\n\nThe `app.fetch` function is used to set up the entry point of your application in the Hono web framework. This is the first point of contact for incoming requests to your application.\n\nHere is an example of how to set this up for Cloudflare Workers:\n\n```ts twoslash\nimport { Hono } from 'hono'\nconst app = new Hono()\ntype Env = any\ntype ExecutionContext = any\n// ---cut---\nexport default {\n  fetch(request: Request, env: Env, ctx: ExecutionContext) {\n```\n\n### How it Works\n\nThe `app.fetch` function is called when a request is made to your application. The `fetch` function takes in a `request` object, an `env` object representing the environment, and a `ctx` object representing the execution context.\n\n### Important Notes\n\n- The `app.fetch` function is specific to the Hono web framework and may not be available in other frameworks.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases\n\n- Setting up the entry point for a new Hono application.\n- Modifying the entry point for an existing Hono application.",
      "ruleTitle": "Setting up the Entry Point in Hono",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates two different ways of exporting a Hono instance in a module. The first method is more verbose and allows for additional logic to be added in the fetch function if needed. The second method is more concise and is suitable when no additional logic is needed in the fetch function.",
      "ruleFile": "# Exporting a Hono Instance\n\nThis guide demonstrates two different ways of exporting a Hono instance in a module.\n\n## Code Snippet 1:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\nexport default {\n  fetch(request: Request, env: Env, ctx: ExecutionContext) {\n    return app.fetch(request, env, ctx)\n  },\n}\n```\n\nIn this method, we are explicitly defining a fetch function that calls the fetch function of the Hono instance. This method is more verbose and allows for additional logic to be added in the fetch function if needed.\n\n## Code Snippet 2:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\nexport default app\n```\n\nIn this method, we are directly exporting the Hono instance. This method is more concise and is suitable when no additional logic is needed in the fetch function.\n\n## Important Notes:\n\n- Choose the method that best suits your needs. If you need to add additional logic in the fetch function, use the first method. If you don't need to add additional logic, use the second method for conciseness.\n\n## References:\n\n- [Hono Documentation](https://hono.readthedocs.io/en/latest/)\n\n## Common Use Cases:\n\n- When creating a module that uses Hono for fetching data.",
      "ruleTitle": "Exporting a Hono Instance",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to properly initialize and export a Hono application. It also shows how to override the default settings of the application by exporting an object with custom properties.",
      "ruleFile": "## Initializing and Exporting a Hono Application\n\nThis code snippet demonstrates how to initialize a new Hono application and export it for use in other modules. It also shows how to override the default settings of the application by exporting an object with custom properties.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\n// ---cut---\nexport default app\n```\n\nOr you can do:\n\n```ts\nexport default app // [!code --]\nexport default {  // [!code ++]\n  port: 3000, // [!code ++]\n  fetch: app.fetch, // [!code ++]\n} // [!code ++]\n```\n\n### How it works\n\n1. The `Hono` class is imported from the 'hono' module.\n2. A new instance of `Hono` is created and assigned to the `app` constant.\n3. The `app` constant is then exported as the default export of the module.\n4. Alternatively, you can export an object with custom properties. This object includes the `port` property set to 3000 and the `fetch` method of the `app` instance.\n\n### Important notes\n\n- The `fetch` method is a useful method for making HTTP requests.\n\n### References\n\n- Hono documentation: https://hono.bryntum.com/docs/\n\n### Common use cases\n\n- Initializing a Hono application for use in a server-side JavaScript environment.",
      "ruleTitle": "Initializing and Exporting a Hono Application",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to correctly export an application in Hono. It also shows how to use the `request` method for testing, which is a common use case in Hono framework.",
      "ruleFile": "## Exporting an Application and Using request Method in Hono\n\nIn Hono, you can export your application with additional configurations. This is demonstrated in the following code snippet:\n\n```ts\nexport default app // [!code --]\nexport default {  // [!code ++]\n  port: 3000, // [!code ++]\n  fetch: app.fetch, // [!code ++]\n} // [!code ++]\n```\n\nThis allows you to specify the port and fetch method for your application.\n\nThe `request` method is a useful tool for testing in Hono. You can pass a URL or pathname to send a GET request, and `app` will return a `Response` object. This is demonstrated in the following code snippet:\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\ndeclare const test: (name: string, fn: () => void) => void\ndeclare const expect: (value: any) => any\n// ---cut---\ntest('GET /hello is ok'\n```\n\nThis is a common use case when testing your application's endpoints.\n\n### Important Notes\n\n- When exporting your application, ensure to include all necessary configurations.\n- The `request` method is a powerful tool for testing, use it to ensure your endpoints are working as expected.\n\n### References\n\n- Hono Documentation\n\n### Common Use Cases\n\n- Exporting an application with specific configurations\n- Testing endpoints with the `request` method",
      "ruleTitle": "Exporting an Application and Using request Method in Hono",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to test routes in the Hono framework. It shows how to send a request to a specific route and how to check the status of the response. This is a fundamental part of developing and testing web applications, ensuring that the routes are working as expected.",
      "ruleFile": "## Testing Routes in Hono\n\nThis code snippet demonstrates how to test routes in the Hono framework.\n\n```ts\nimport { Hono } from 'hono'\nconst app = new Hono()\ndeclare const test: (name: string, fn: () => void) => void\ndeclare const expect: (value: any) => any\n\ntest('GET /hello is ok', async () => {\n  const res = await app.request('/hello')\n  expect(res.status).toBe(200)\n})\n```\n\n### How it works\n\n1. We first import the `Hono` class and create an instance of it.\n2. We declare the `test` and `expect` functions. These are usually provided by a testing library like Jest.\n3. We define a test for the `GET /hello` route. We send a request to this route using the `request` method of the `app` instance.\n4. We check the status of the response. We expect it to be `200`, which means the request was successful.\n\n### Important notes\n\n- The `request` method returns a `Promise` that resolves to the response. We need to use the `await` keyword to wait for the promise to resolve.\n\n### References\n\n- [Hono documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Testing the functionality of routes in a web application.",
      "ruleTitle": "Testing Routes in Hono",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to test a POST request in Hono. It shows how to create a request, send it to the Hono application, and then check the response status. This is a fundamental aspect of ensuring that the application behaves as expected when it receives a POST request.",
      "ruleFile": "## Testing POST requests in Hono\n\nThis code snippet demonstrates how to test a POST request in Hono. It creates a request, sends it to the Hono application, and then checks the response status.\n\n```ts\ntest('POST /message is ok', async () => {\n  const req = new Request('Hello!', {\n    method: 'POST',\n  })\n  const res = await app.request(req)\n  expect(res.status).toBe(201)\n})\n```\n\n### How it works\n\n1. A test is defined with the description 'POST /message is ok'.\n2. A new Request is created with the message 'Hello!' and the method set to 'POST'.\n3. The request is sent to the Hono application using the `app.request()` method.\n4. The response status is checked to be 201, indicating that the request was successful and a new resource was created.\n\n### Important notes\n\n- The `app.request()` method is used to send the request to the Hono application.\n- The `expect()` function is used to check the response status.\n\n### References\n\n- [Hono documentation](https://hono.bike/)\n\n### Common use cases\n\n- Testing how your Hono application responds to different types of requests.\n- Checking that your application behaves as expected when it receives a POST request.",
      "ruleTitle": "Testing POST Requests in Hono",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to manage route matching in Hono framework using the strict mode. It shows how the strict mode can be used to distinguish between similar routes and how to make the route matching less strict by setting the strict mode to false.",
      "ruleFile": "## Hono Route Matching in Strict Mode\n\nIn Hono, the strict mode is used to manage route matching. By default, the strict mode is set to `true` and it distinguishes between similar routes. For example, `/hello` and `/hello/` are treated as different routes.\n\n```text\nStrict mode defaults to `true` and distinguishes the following routes.\n\n- `/hello`\n- `/hello/`\n\n`app.get('/hello')` will not match `GET /hello/`.\n```\n\nHowever, you can make the route matching less strict by setting the strict mode to `false`. In this case, both `/hello` and `/hello/` will be treated as the same route.\n\n```text\nBy setting strict mode to `false`, both paths will be treated equally.\n```\n\n### How it works\n\nWhen you create a new Hono application, you can set the strict mode in the options. If you set it to `false`, the trailing slashes in the routes will be ignored.\n\n### Important notes\n\n- The strict mode only affects the trailing slashes in the routes.\n\n### References\n\n- [Hono Documentation](https://hono.bouzuya.net/)\n\n### Common use cases\n\n- When you want to treat `/hello` and `/hello/` as the same route, you can set the strict mode to `false`.",
      "ruleTitle": "Managing Route Matching in Hono Using Strict Mode",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to specify a different router in Hono. By default, Hono uses the 'SmartRouter'. However, if a user wants to use a different router, like 'RegExpRouter', they can do so by passing it to a new Hono instance. This flexibility allows developers to choose the routing mechanism that best suits their application's needs.",
      "ruleFile": "## Specifying a Different Router in Hono\n\nIn Hono, the default router is 'SmartRouter'. If you want to use a different router, like 'RegExpRouter', you can do so by passing it to a new Hono instance. Here is a code snippet demonstrating this:\n\n```ts twoslash\nimport { Hono } from 'hono'\nimport { RegExpRouter } from 'hono/router/reg-exp-router'\n\nconst app = new Hono({ router: new RegExpRouter() })\n```\n\n### How it Works\n\nIn this code snippet, we first import the 'Hono' and 'RegExpRouter' modules. Then, we create a new instance of 'Hono', passing an object with a 'router' property set to a new instance of 'RegExpRouter'. This tells Hono to use 'RegExpRouter' for routing instead of the default 'SmartRouter'.\n\n### Important Notes\n\n- You can use any router that is compatible with Hono by following this pattern.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common Use Cases\n\n- When you need to use a different routing mechanism in your Hono application.",
      "ruleTitle": "Specifying a Different Router in Hono",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use Generics in Hono to specify the types of Cloudflare Workers Bindings and variables used in `c.set`/`c.get`. This is crucial for type safety and ensuring the correct usage of variables and bindings.",
      "ruleFile": "## Using Generics in Hono\n\nIn Hono, you can use Generics to specify the types of Cloudflare Workers Bindings and variables used in `c.set`/`c.get`. This is useful for maintaining type safety and ensuring the correct usage of variables and bindings.\n\nHere is a code snippet demonstrating this:\n\n```ts twoslash\nimport { Hono } from 'hono'\ntype User = any\ndeclare const user: User\n// ---cut---\ntype Bindings = {\n  TOKEN: string\n}\n\ntype Variables = {\n  user: User\n}\n\nconst app = new Hono<{\n  Bindings:\n```\n\nIn this code snippet, a generic is used to specify the types of the `TOKEN` binding and the `user` variable. This ensures that these elements are used correctly in the code, and any misuse will be caught by the TypeScript compiler.\n\n### Important Notes\n\n- Generics in Hono are a powerful tool for maintaining type safety and ensuring correct usage of variables and bindings.\n\n- Misuse of variables and bindings can lead to runtime errors, so it's important to use generics to catch these errors at compile time.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases\n\n- Defining the types of Cloudflare Workers Bindings and variables used in `c.set`/`c.get`.",
      "ruleTitle": "Using Generics in Hono to Specify Types of Cloudflare Workers Bindings and Variables",
      "sourcePath": "docs/api/hono.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use different versions of Hono, and how to instantiate routers in each version. Understanding this rule allows developers to utilize the appropriate version of Hono based on their specific needs and constraints.",
      "ruleFile": "## Importing and Using Different Versions of Hono\n\nThis code snippet demonstrates how to import and use different versions of Hono, and how to instantiate routers in each version.\n\n```ts\n// Importing Hono\nimport { Hono } from 'hono'\n\n// Instantiating routers in Hono\nthis.router = new SmartRouter({\n  routers: [new RegExpRouter(), new TrieRouter()],\n})\n\n// Importing Hono Quick\nimport { Hono } from 'hono/quick'\n\n// Instantiating routers in Hono Quick\nthis.router = new SmartRouter({\n  routers: [new LinearRouter(), new TrieRouter()],\n})\n```\n\n### How it works\n\nIn the first part, we import the main Hono package and instantiate a SmartRouter with a RegExpRouter and a TrieRouter. In the second part, we import the 'quick' version of Hono and instantiate a SmartRouter with a LinearRouter and a TrieRouter.\n\n### Important notes\n\nDifferent versions of Hono may have different performance characteristics and features. Choose the version that best fits your application's needs.\n\n### References\n\n- Hono Documentation\n\n### Common use cases\n\n- When you need to use different routing strategies in your application.\n- When you need to switch between different versions of Hono based on performance requirements or feature availability.",
      "ruleTitle": "Importing and Using Different Versions of Hono",
      "sourcePath": "docs/api/presets.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use different presets in Hono framework. It shows how to import and use different routers in Hono, specifically the 'hono/quick' and 'hono/tiny' presets. Understanding this rule helps in choosing the right preset based on the specific needs of the application.",
      "ruleFile": "## Hono Presets Usage\n\nThis rule demonstrates how to use different presets in Hono framework. The presets 'hono/quick' and 'hono/tiny' are used in this example.\n\n### Code Snippet:\n\nFor 'hono/quick':\n\n```ts twoslash\nimport { Hono } from 'hono/quick'\n\nthis.router = new SmartRouter({\n  routers: [new LinearRouter(), new TrieRouter()],\n})\n```\n\nFor 'hono/tiny':\n\n```ts twoslash\nimport { Hono } from 'hono/tiny'\n\nthis.router = new PatternRouter()\n```\n\n### How it works:\n\nThe 'hono/quick' preset uses a SmartRouter with LinearRouter and TrieRouter. The 'hono/tiny' preset uses a PatternRouter.\n\n### Important notes:\n\nChoose the preset based on the specific needs of your application. The 'hono/quick' preset is suitable for more complex routing needs, while the 'hono/tiny' preset is suitable for simpler routing needs.\n\n### References:\n\n- Hono Documentation\n\n### Common use cases:\n\n- Creating a web application with different routing needs.",
      "ruleTitle": "Using Different Presets in Hono Framework",
      "sourcePath": "docs/api/presets.md",
      "category": "api"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes in a Hono application and how to use the 'toSSG' function to generate static site content. It also shows how to use middleware to set a custom renderer for a specific route.",
      "ruleFile": "## Defining Routes and Generating Static Site Content in Hono\n\nThis code snippet demonstrates how to define routes in a Hono application and how to use the 'toSSG' function to generate static site content.\n\n```tsx\n// index.tsx\nconst app = new Hono()\n\napp.get('/', (c) => c.html('Hello, World!'))\napp.use('/about', async (c, next) => {\n  c.setRenderer((content, head) => {\n    return c.html(\n      <html>\n        <head>\n          <title>{head.title ?? ''}</title>\n        </head>\n        <body>\n          <p>{content}</p>\n        </body>\n      </html>\n    )\n  })\n  await next()\n})\napp.get('/about', (c) => {\n  return c.render('Hello!', { title: 'Hono SSG Page' })\n})\n\nexport default app\n```\n\n### How it works\n\n1. A new Hono application is created.\n2. The root route ('/') is defined to return a simple HTML string.\n3. A middleware is added to the '/about' route that sets a custom renderer. This renderer wraps the content in a basic HTML structure and uses the 'head.title' property for the page title.\n4. The '/about' route is defined to render a string with a title.\n5. The application is then exported for use in other modules.\n\n### Important notes\n\n- The 'toSSG' function is used to generate static site content. It takes the Hono application and a file system module as arguments.\n\n### References\n\n- [Hono documentation](https://hono.bayfront.cloud/)\n\n### Common use cases\n\n- Building static websites or blogs with Hono.\n- Defining custom renderers for specific routes.",
      "ruleTitle": "Defining Routes and Generating Static Site Content in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use Hono's static site generation (SSG) feature to pre-render pages at build time. This is particularly useful for improving performance and SEO of Hono applications.",
      "ruleFile": "## Hono Static Site Generation (SSG) Usage\n\nThis code snippet demonstrates how to use Hono's static site generation (SSG) feature to pre-render pages at build time.\n\n```ts\n// build.ts\nimport app from './index'\nimport { toSSG } from 'hono/ssg'\nimport fs from 'fs/promises'\n\ntoSSG(app, fs)\n```\n\n### How it works\n\n1. Import the application from the index file.\n2. Import the `toSSG` function from 'hono/ssg'.\n3. Import 'fs/promises' for file system operations.\n4. Call the `toSSG` function with the application and the file system module as arguments.\n\n### Important notes\n\n- The `toSSG` function pre-renders the pages at build time, improving performance and SEO.\n- The output files will be HTML files corresponding to the routes defined in the application.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs)\n\n### Common use cases\n\n- Pre-rendering pages for static site generation in Hono applications.",
      "ruleTitle": "Using Hono's Static Site Generation (SSG) Feature",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'toSSG' function from the Hono framework to generate static site files. It shows the process of importing the function, applying it to an app, and using the file system module to write the static files. The rule also highlights the output of the process, which is the creation of HTML files in the static directory.",
      "ruleFile": "## Using the 'toSSG' function in Hono\n\nThe 'toSSG' function in Hono is used to generate static site files. Here is a code snippet demonstrating its usage:\n\n```ts\n// build.ts\nimport app from './index'\nimport { toSSG } from 'hono/ssg'\nimport fs from 'fs/promises'\n\ntoSSG(app, fs)\n```\n\nWhen this script is executed, it outputs the files as follows:\n\n```bash\nls ./static\nabout.html  index.html\n```\n\n### How it works\n\n1. The 'toSSG' function is imported from the 'hono/ssg' module.\n2. The function is then applied to an app, along with the file system module.\n3. The function generates static site files from the app and writes them to the file system.\n\n### Important notes\n\n- The 'toSSG' function is part of the Hono framework, which is designed for building server-rendered JavaScript apps.\n- The function generates static site files, which can be served by any static file server.\n\n### References\n\n- [Hono GitHub](https://github.com/honojs/hono)\n\n### Common use cases\n\n- Generating static site files for a server-rendered JavaScript app.",
      "ruleTitle": "Generating Static Site Files with Hono's 'toSSG' Function",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define an interface for the toSSG function in Hono, which is used for generating static sites. It shows the correct way to define the function parameters and their types, which is crucial for TypeScript's static type checking and for ensuring the function is used correctly.",
      "ruleFile": "## Defining the toSSG Function Interface in Hono\n\nThe `toSSG` function in Hono is used for generating static sites. It takes an application, a filesystem module, and an optional options object as arguments. The correct way to define this function in TypeScript is by using an interface, as shown in the following code snippet:\n\n```ts\nexport interface ToSSGInterface {\n  (\n    app: Hono,\n    fsModule: FileSystemModule,\n    options?: ToSSGOptions\n  ): Promise<ToSSGResult>\n}\n```\n\nIn this interface:\n\n- `app` specifies `new Hono()` with registered routes.\n- `fsModule` is an object that represents the filesystem module, assuming `node:fs/promise`.\n- `options` is an optional object that can be used to specify additional options for the function.\n\nThe function returns a promise that resolves with a `ToSSGResult` object.\n\n### Important Notes\n\n- Defining the function in this way allows TypeScript's static type checking to ensure the function is used correctly.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common Use Cases\n\n- Generating static sites with Hono.",
      "ruleTitle": "Defining the toSSG Function Interface in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define and use the FileSystemModule interface in Hono. It shows the methods that need to be implemented for file operations, which are writeFile and mkdir. This is crucial for any operations that involve reading from or writing to the file system.",
      "ruleFile": "## FileSystemModule Interface in Hono\n\nIn Hono, the FileSystemModule interface is used to define methods for file operations. It includes methods for writing data to a file and creating a directory.\n\nHere is a code snippet demonstrating this:\n\n```ts\nexport interface FileSystemModule {\n  writeFile(path: string, data: string | Uint8Array): Promise<void>\n  mkdir(\n    path: string,\n    options: { recursive: boolean }\n  ): Promise<void | string>\n}\n```\n\n### How it works\n\n1. The `writeFile` method takes a path and data (either a string or Uint8Array) as arguments and returns a Promise that resolves to void. This method is used to write data to a file at the specified path.\n\n2. The `mkdir` method takes a path and an options object as arguments and returns a Promise that resolves to either void or a string. This method is used to create a directory at the specified path. The options object has a `recursive` property which, when set to true, allows for the creation of directories recursively.\n\n### Important notes\n\n- These methods return Promises, so they are asynchronous and should be handled accordingly.\n\n### References\n\n- [Hono Documentation](https://hono.bun.js.org/)\n\n### Common use cases\n\n- Writing data to a file\n- Creating a directory",
      "ruleTitle": "Defining and Using the FileSystemModule Interface in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'toSSG' function provided by Hono for different file systems like Deno and Bun. It shows the correct way to import and use the function, and highlights that the second argument is an option typed 'ToSSGOptions'. Understanding this rule is crucial for developers who want to use SSG on Deno or Bun with Hono.",
      "ruleFile": "## Using 'toSSG' function in Hono for Deno and Bun\n\nThis code snippet demonstrates how to use the 'toSSG' function provided by Hono for different file systems like Deno and Bun.\n\n```ts\nimport { toSSG } from 'hono/deno'\n\ntoSSG(app) // The second argument is an option typed 'ToSSGOptions'.\n```\n\n### How it works\n\n1. The 'toSSG' function is imported from 'hono/deno' for Deno and 'hono/bun' for Bun.\n2. The function is then called with the 'app' argument. The second argument is an option typed 'ToSSGOptions'.\n\n### Important notes\n\n- The 'toSSG' function is specific to the file system being used. Make sure to import it from the correct module.\n- The second argument to the 'toSSG' function is optional and should be of type 'ToSSGOptions'.\n\n### References\n\n- Hono documentation: [link]\n\n### Common use cases\n\n- When you want to use SSG on Deno or Bun with Hono, you can use the 'toSSG' function as demonstrated in the code snippet.",
      "ruleTitle": "Using 'toSSG' function in Hono for Deno and Bun",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `toSSG` function in Hono framework for both Deno and Bun. The `toSSG` function is used to convert an application into a static site generator. Understanding how to use this function is crucial for developers who want to leverage the benefits of static site generation in their Hono applications.",
      "ruleFile": "## Using the `toSSG` function in Hono\n\nIn Hono, a `toSSG` function is provided for each file system. This function is used to convert an application into a static site generator.\n\nFor Deno:\n\n```ts\nimport { toSSG } from 'hono/deno'\n\ntoSSG(app) // The second argument is an option typed `ToSSGOptions`.\n```\n\nFor Bun:\n\n```ts\nimport { toSSG } from 'hono/bun'\n\ntoSSG(app) // The second argument is an option typed `ToSSGOptions`.\n```\n\nThe `ToSSGOptions` interface specifies the options for the `toSSG` function. These options include `dir`, `concurrency`, `beforeRequestHook`, and `afterResponse`.\n\n### How it works\n\nThe `toSSG` function takes two arguments: the application and an options object. The options object is typed `ToSSGOptions` and can include various properties to customize the behavior of the static site generator.\n\n### Important notes\n\n- The `toSSG` function is specific to the Hono framework and may not work in other frameworks.\n\n### References\n\n- [Hono Documentation](https://hono.io/docs)\n\n### Common use cases\n\n- Converting a dynamic Hono application into a static site for improved performance and security.",
      "ruleTitle": "Using the `toSSG` function in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'toSSG' function in Hono framework, specifically how to configure the options for the 'ToSSGOptions' interface. Understanding these options allows developers to customize the static site generation process according to their specific needs.",
      "ruleFile": "## Using the 'toSSG' function in Hono\n\nThe 'toSSG' function is used to generate static sites. It accepts an application instance and an optional 'ToSSGOptions' object as arguments. The 'ToSSGOptions' interface allows developers to customize the static site generation process.\n\nHere is the 'ToSSGOptions' interface:\n\n```ts\nexport interface ToSSGOptions {\n  dir?: string\n  concurrency?: number\n  beforeRequestHook?: BeforeRequestHook\n  afterResponseHook?: AfterResponseHook\n  afterGenerateHook?: AfterGenerateHook\n  extensionMap?: Record<string, string>\n}\n```\n\n- `dir`: Specifies the output destination for static files. Default is `./static`.\n- `concurrency`: Specifies the concurrent number of files to be generated at the same time. Default is `2`.\n- `beforeRequestHook`, `afterResponseHook`, `afterGenerateHook`: These are optional hooks that can be used to perform actions before a request is made, after a response is received, and after a file is generated, respectively.\n- `extensionMap`: An optional object that maps file extensions to their MIME types.\n\n### Usage\n\n```ts\nimport { toSSG } from 'hono/bun'\n\ntoSSG(app, {\n  dir: './public',\n  concurrency: 5,\n  beforeRequestHook: () => console.log('Before request'),\n  afterResponseHook: () => console.log('After response'),\n  afterGenerateHook: () => console.log('After generate'),\n  extensionMap: { '.html': 'text/html' }\n})\n```\n\nIn this example, the static site will be generated in the './public' directory, with a concurrency of 5. The specified hooks will log messages at different stages of the generation process, and '.html' files will be served with the 'text/html' MIME type.",
      "ruleTitle": "Configuring the 'toSSG' function in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define an interface in TypeScript for the result of the 'toSSG' function in Hono. The interface 'ToSSGResult' includes a boolean 'success' field, a 'files' field which is an array of strings, and an optional 'error' field of type Error. This pattern is crucial in TypeScript for type checking and ensuring the correct data structure is returned by functions.",
      "ruleFile": "## Defining TypeScript Interface for Function Results in Hono\n\nIn Hono, it's common to define TypeScript interfaces for the results of functions. This helps with type checking and ensures that the function returns the correct data structure. Here's an example of how to define an interface for the result of the 'toSSG' function.\n\n```ts\nexport interface ToSSGResult {\n  success: boolean\n  files: string[]\n  error?: Error\n}\n```\n\nIn this code snippet:\n\n- `success` is a boolean indicating whether the operation was successful.\n- `files` is an array of strings, representing the files processed.\n- `error` is an optional field of type Error, which will be defined if there was an error during the operation.\n\n### Important Notes\n\n- The `error` field is optional (`error?`). This means it does not have to be included in the objects that implement this interface.\n\n### References\n\n- [TypeScript Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)\n\n### Common Use Cases\n\n- Defining the expected return type of a function in TypeScript.",
      "ruleTitle": "Defining TypeScript Interface for Function Results in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define and use hooks in Hono. Hooks are a powerful feature that allow developers to customize the process of `toSSG` by specifying custom functions that get called at different stages of the request-response lifecycle. This can be used to modify requests and responses, or to perform actions after the generation of static site files.",
      "ruleFile": "## Defining and Using Hooks in Hono\n\nIn Hono, you can customize the process of `toSSG` by specifying custom hooks in options. These hooks are functions that get called at different stages of the request-response lifecycle.\n\nHere is how you can define these hooks:\n\n```ts\nexport type BeforeRequestHook = (req: Request) => Request | false\nexport type AfterResponseHook = (res: Response) => Response | false\nexport type AfterGenerateHook = (\n  result: ToSSGResult\n) => void | Promise<void>\n```\n\nThe `BeforeRequestHook` is called before a request is made. It receives the request object as a parameter and should return the modified request object or `false` to cancel the request.\n\nThe `AfterResponseHook` is called after a response is received. It receives the response object as a parameter and should return the modified response object or `false` to cancel the response.\n\nThe `AfterGenerateHook` is called after the static site files have been generated. It receives the `ToSSGResult` object as a parameter and should return `void` or a `Promise` that resolves to `void`.\n\n### Important Notes\n\n- Hooks are a powerful feature that allow you to customize the behavior of Hono. However, they should be used with care as they can also introduce complexity and potential issues.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/docs/hooks)\n\n### Common Use Cases\n\n- Modifying requests or responses\n- Performing actions after the generation of static site files",
      "ruleTitle": "Defining and Using Hooks in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to filter requests in the Hono framework using hooks. In this case, the 'beforeRequestHook' is used to filter out all non-GET requests, which can be useful in scenarios where only GET requests need to be processed or logged.",
      "ruleFile": "## Filtering Requests Using Hooks in Hono\n\nThis code snippet demonstrates how to use hooks in Hono to filter requests. Specifically, it uses the 'beforeRequestHook' to filter out all non-GET requests.\n\n```ts\ntoSSG(app, fs, {\n  beforeRequestHook: (req) => {\n    if (req.method === 'GET') {\n      return req\n    }\n    return false\n  },\n})\n```\n\n### How it Works\n\nThe 'beforeRequestHook' is a function that is called before each request is processed. If the function returns false, the request is not processed.\n\nIn this case, the function checks if the request method is 'GET'. If it is, the request is processed. If it's not, the request is not processed.\n\n### Important Notes\n\n- The 'beforeRequestHook' can be used to filter requests based on any criteria, not just the request method.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/hooks/)\n\n### Common Use Cases\n\n- Logging only GET requests\n- Preventing certain types of requests from being processed",
      "ruleTitle": "Filtering Requests Using Hooks in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'afterResponseHook' in Hono's 'toSSG' function to filter responses based on their status codes. This can be useful in scenarios where only certain responses are needed for static site generation, such as only successful responses (status code 200) or server error responses (status code 500).",
      "ruleFile": "## Using afterResponseHook to Filter Responses by Status Code in Hono\n\nThis code snippet demonstrates how to use the 'afterResponseHook' in Hono's 'toSSG' function to filter responses based on their status codes.\n\n```ts\ntoSSG(app, fs, {\n  afterResponseHook: (res) => {\n    if (res.status === 200 || res.status === 500) {\n      return res\n    }\n    return false\n  },\n})\n```\n\nIn this example, the 'afterResponseHook' function is used to check the status code of each response. If the status code is either 200 or 500, the response is returned and processed further. If the status code is anything else, the function returns 'false', effectively filtering out the response.\n\nThis can be useful in scenarios where only certain responses are needed for static site generation, such as only successful responses (status code 200) or server error responses (status code 500).\n\n### Important Notes\n\n- The 'afterResponseHook' function is called after each response is received, but before it is processed by 'toSSG'.\n- The 'afterResponseHook' function should return the response if it should be processed further, or 'false' if it should be filtered out.\n\n### References\n\n- [Hono Documentation](https://hono.bjacobel.com/docs)\n\n### Common Use Cases\n\n- Filtering responses by status code for static site generation\n- Logging or handling specific types of responses separately",
      "ruleTitle": "Filtering Responses by Status Code Using afterResponseHook in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'afterGenerateHook' in Hono. This hook allows developers to execute additional logic after the 'toSSG' function has run, which is useful for logging, debugging, or other post-processing tasks.",
      "ruleFile": "## Using afterGenerateHook in Hono\n\nThe `afterGenerateHook` is a feature in Hono that allows you to execute additional logic after the `toSSG` function has run. This can be useful for logging, debugging, or other post-processing tasks.\n\nHere is an example of how to use it:\n\n```ts\ntoSSG(app, fs, {\n  afterGenerateHook: (result) => {\n    if (result.files) {\n      result.files.forEach((file) => console.log(file))\n    }\n  }\n})\n```\n\nIn this example, if the `result` object contains a `files` array, it logs each file to the console.\n\n### Important Notes\n\n- The `afterGenerateHook` function is called after the `toSSG` function has completed.\n- The `result` object passed to the `afterGenerateHook` function contains the result of the `toSSG` function.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common Use Cases\n\n- Logging the result of the `toSSG` function for debugging purposes.\n- Performing additional post-processing on the `result` object.",
      "ruleTitle": "Using afterGenerateHook in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to customize file extensions in Hono's static site generator (SSG) based on the `Content-Type` returned by each route. This is crucial for serving different types of content correctly in a static website.",
      "ruleFile": "## Customizing File Extensions in Hono's Static Site Generator (SSG)\n\nThis code snippet demonstrates how to customize the file extensions in Hono's SSG based on the `Content-Type` returned by each route.\n\n```ts\nimport { toSSG, defaultExtensionMap } from 'hono/ssg'\n\n// Save `application/x-html` content with `.html`\ntoSSG(app, fs, {\n  extensionMap: {\n    'application/x-html': 'html',\n    ...defaultExtensionMap,\n  },\n})\n```\n\n### How it Works\n\nThe `toSSG` function is used to configure the SSG. The `extensionMap` option is set to map the `Content-Type` 'application/x-html' to the '.html' extension. The `defaultExtensionMap` is spread into the `extensionMap` to include the default mappings.\n\n### Important Notes\n\nPaths ending with a slash are saved as index.ext regardless of the extension.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/docs/ssg)\n\n### Common Use Cases\n\n- Serving different types of content in a static website\n- Customizing file extensions for specific content types",
      "ruleTitle": "Customizing File Extensions in Hono's Static Site Generator",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes in Hono that return HTML and text responses. It also shows how to use the 'get' method to handle HTTP GET requests to specific paths ('/html/' and '/text/') and how to use the 'html' and 'text' methods to send responses of different types. Understanding this rule is crucial for creating dynamic web applications with Hono.",
      "ruleFile": "## Rule: Defining Routes in Hono to Return HTML and Text Responses\n\nThis rule demonstrates how to define routes in Hono that return HTML and text responses. The 'get' method is used to handle HTTP GET requests to specific paths ('/html/' and '/text/'), and the 'html' and 'text' methods are used to send responses of different types.\n\n### Code Snippet:\n\n```ts\n// save to ./static/html/index.html\napp.get('/html/', (c) => c.html('html'))\n\n// save to ./static/text/index.txt\napp.get('/text/', (c) => c.text('text'))\n```\n\n### How it Works:\n\n1. The 'get' method is used to define a route that handles HTTP GET requests. The first argument is the path, and the second argument is a callback function that is executed when the route is matched.\n\n2. The callback function takes a context object 'c' as an argument. This object contains information about the HTTP request and has methods for sending a response.\n\n3. The 'html' and 'text' methods of the context object are used to send HTML and text responses, respectively.\n\n### Important Notes:\n\n- The paths in the 'get' method calls end with a slash. This means that the routes will match requests to '/html/' and '/text/', but not to '/html' and '/text'.\n\n- The 'html' and 'text' methods automatically set the correct 'Content-Type' HTTP header in the response ('text/html' and 'text/plain', respectively).\n\n### References:\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common Use Cases:\n\n- Use the 'html' method to send an HTML response when you want to render a web page.\n\n- Use the 'text' method to send a text response when you want to send plain text data, for example, as a response to an API request.",
      "ruleTitle": "Defining Routes in Hono to Return HTML and Text Responses",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the built-in middleware in Hono for static site generation (SSG). It shows how to use the `ssgParams` middleware to generate static parameters for a route, similar to the `generateStaticParams` API in Next.js. It also shows how to handle routes with dynamic parameters and how to render a response based on the fetched data.",
      "ruleFile": "## Using Built-in Middleware for Static Site Generation (SSG) in Hono\n\nIn Hono, you can use built-in middleware for static site generation (SSG). This is particularly useful when you want to pre-render pages at build time for performance benefits.\n\nHere's an example of how to use the `ssgParams` middleware to generate static parameters for a route:\n\n```ts\napp.get(\n  '/shops/:id',\n  ssgParams(async () => {\n    const shops = await getShops()\n    return shops.map((shop) => ({ id: shop.id }))\n  }),\n  async (c) => {\n    const shop = await getShop(c.req.param('id'))\n    if (!shop) {\n      return c.notFound()\n    }\n    return c.render(\n      <div>\n        <h1>{shop.name}</h1>\n      </div>\n    )\n  }\n)\n```\n\nIn this code snippet:\n\n1. The `ssgParams` middleware is used to generate static parameters for the route '/shops/:id'. It fetches a list of shops and returns an array of objects, each containing an `id` property.\n\n2. In the route handler, it fetches the shop with the requested `id` and renders a response. If the shop is not found, it returns a 404 response.\n\nThis approach allows you to generate static pages for each shop at build time, improving the performance of your application.\n\n**Important notes:**\n\n- The `ssgParams` middleware is similar to the `generateStaticParams` API in Next.js.\n- Routes with the `disableSSG` middleware set are excluded from static file generation.\n\n**Common use cases:**\n\n- Pre-rendering pages at build time for performance benefits.\n- Handling routes with dynamic parameters.\n\n**References:**\n\n- [Hono documentation](https://hono.dev/docs)\n- [Next.js documentation](https://nextjs.org/docs)",
      "ruleTitle": "Using Built-in Middleware for Static Site Generation in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `disableSSG` middleware in Hono to exclude certain routes from static file generation by `toSSG`. This is useful when you have routes that should not be statically generated, such as API endpoints.",
      "ruleFile": "## Using disableSSG Middleware in Hono\n\nIn Hono, the `disableSSG` middleware is used to exclude certain routes from static file generation by `toSSG`. This is particularly useful for routes that should not be statically generated, such as API endpoints.\n\nHere is an example of how to use it:\n\n```ts\napp.get('/api', disableSSG(), (c) => c.text('an-api'))\n```\n\nIn this code snippet, the route '/api' is set to be excluded from static file generation. This means that when `toSSG` is executed, this route will not be included in the generated static files.\n\n### Important Notes\n\n- The `disableSSG` middleware should be used sparingly, as it can lead to performance issues if used excessively.\n\n### References\n\n- [Hono Documentation](https://hono.boutique/docs)\n\n### Common Use Cases\n\n- Excluding API endpoints from static file generation\n- Excluding routes that require dynamic content from static file generation",
      "ruleTitle": "Using disableSSG Middleware to Exclude Routes from Static File Generation in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'onlySSG' middleware in Hono to serve static pages. It shows how to define a route that will only be available during the static site generation process and will return a 'not found' error at other times. This is useful for pages that should only be statically generated and not served dynamically.",
      "ruleFile": "## Using onlySSG Middleware in Hono\n\nThis code snippet demonstrates how to use the 'onlySSG' middleware in Hono to serve static pages.\n\n```ts\napp.get('/static-page', onlySSG(), (c) => c.html(<h1>Welcome to my site</h1>))\n```\n\nIn this example, the '/static-page' route is defined with the 'onlySSG' middleware. This means that this route will only be available during the static site generation process. If a request is made to this route outside of this process, the 'c.notFound()' method will be called, returning a 'not found' error.\n\n### Important Notes\n\n- The 'onlySSG' middleware is useful for pages that should only be statically generated and not served dynamically.\n\n### References\n\n- [Hono Documentation](https://hono.bayfront.cloud/)\n\n### Common Use Cases\n\n- Serving static pages that should not be available dynamically.",
      "ruleTitle": "Using onlySSG Middleware to Serve Static Pages in Hono",
      "sourcePath": "docs/helpers/ssg.md",
      "category": "helpers"
    },
    {
      "reasoning": "The Accepts Helper in Hono is important as it allows the handling of Accept headers in requests. This is crucial in web development as it helps the server understand what type of content the client can handle. This rule demonstrates how to import and use the Accepts Helper in Hono.",
      "ruleFile": "## Accepts Helper in Hono\n\nThe Accepts Helper in Hono is used to handle Accept headers in requests. This is crucial in web development as it helps the server understand what type of content the client can handle.\n\n### Code Snippet\n\n```ts\nimport { Hono } from 'hono'\nimport { accepts } from 'hono/accepts'\n```\n\n### How it works\n\nThe `accepts()` function looks at the Accept header, such as Accept-Encoding and Accept-Language, and returns the proper value.\n\n### Important notes\n\n- The Accepts Helper is a part of the Hono framework and must be imported from 'hono/accepts'.\n- The Accepts Helper is typically used in the context of a GET request.\n\n### References\n\n- Hono Documentation\n\n### Common use cases\n\n- When the server needs to understand what type of content the client can handle, the Accepts Helper can be used.",
      "ruleTitle": "Handling Accept Headers with Hono's Accepts Helper",
      "sourcePath": "docs/helpers/accepts.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'accepts' function from Hono to handle different Accept headers in a request. It shows how to specify the header, the supported values, and a default value. This is crucial for handling internationalization and different content types in a web application.",
      "ruleFile": "## Using the 'accepts' function in Hono\n\nThe 'accepts' function in Hono is used to handle different Accept headers in a request. It looks at the specified Accept header and returns the proper value based on the supported values and a default value.\n\nHere is a code snippet demonstrating its usage:\n\n```ts\nimport { accepts } from 'hono/accepts'\n\napp.get('/', (c) => {\n  const accept = accepts(c, {\n    header: 'Accept-Language',\n    supports: ['en', 'ja', 'zh'],\n    default: 'en',\n  })\n  return c.json({ lang: accept })\n})\n```\n\nIn this example, the 'accepts' function is used to handle the 'Accept-Language' header. It supports 'en', 'ja', and 'zh' languages, with 'en' as the default language.\n\nThis function is crucial for handling internationalization and different content types in a web application. It allows the application to respond appropriately based on the client's preferences.\n\n### Important notes\n\n- The 'accepts' function should be used in the route handler, as it needs the context 'c' which contains the request and response objects.\n\n### References\n\n- [Hono documentation](https://hono.beyondco.de/docs/helpers/accepts)\n\n### Common use cases\n\n- Handling different languages in a web application\n- Handling different content types in a web application",
      "ruleTitle": "Handling Accept Headers with Hono's 'accepts' Function",
      "sourcePath": "docs/helpers/accepts.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define an AcceptHeader type in Hono. Accept headers are used in HTTP requests to tell the server what content types the client can handle. By defining the AcceptHeader type, we ensure that only valid accept headers are used in our application, reducing the chance of errors.",
      "ruleFile": "## AcceptHeader Type Definition in Hono\n\nIn Hono, you can define an `AcceptHeader` type to specify the types of accept headers your application can handle. This is done using TypeScript's union type (`|`), which allows you to define a type that can be one of several types.\n\nHere is an example of how to define an `AcceptHeader` type:\n\n```ts\nexport type AcceptHeader =\n  | 'Accept'\n  | 'Accept-Charset'\n  | 'Accept-Encoding'\n  | 'Accept-Language'\n  | 'Accept-Patch'\n  | 'Accept-Post'\n  | 'Accept-Ranges'\n```\n\n### How it works\n\nWhen you define a variable of type `AcceptHeader`, it can only be assigned one of the specified values. If you try to assign a value that is not in the list, TypeScript will throw a compile-time error.\n\n### Important notes\n\n- The `AcceptHeader` type definition is not limited to the values shown in the example. You can add or remove values as needed for your application.\n\n### References\n\n- [TypeScript Union Type](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#union-types)\n\n### Common use cases\n\n- Use the `AcceptHeader` type when you need to work with accept headers in your application, to ensure that only valid headers are used.",
      "ruleTitle": "Defining AcceptHeader Type in Hono",
      "sourcePath": "docs/helpers/accepts.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the 'css' module from the 'hono' library in TypeScript. The 'css' module allows developers to write CSS in a template literal, which can then be used as a class name in the application. This is a key feature of the Hono framework, enabling developers to manage styles in a more JavaScript-centric way.",
      "ruleFile": "## Importing and Using the 'css' Module from Hono\n\nThis code snippet demonstrates how to import and use the 'css' module from the 'hono' library in TypeScript.\n\n```ts\nimport { Hono } from 'hono'\nimport { css, cx, keyframes, Style } from 'hono/css'\n```\n\n### How it Works\n\nThe 'css' module allows developers to write CSS in a template literal. The return value of 'css' will be the class name, which can then be set to the value of the class attribute in your components. The '<Style />' component will then contain the value of the CSS.\n\n### Important Notes\n\n- The 'css' module is marked as 'Experimental'. This means that it is still under development and may change in future versions of Hono.\n\n### References\n\n- [Hono Documentation](https://hono.brontosaurusrex.com/)\n\n### Common Use Cases\n\n- Styling components in a more JavaScript-centric way.\n- Managing styles in a single place, making it easier to maintain and update the styles of your application.",
      "ruleTitle": "Importing and Using the 'css' Module from Hono",
      "sourcePath": "docs/helpers/css.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to style pseudo-classes like `:hover` in Hono using the nesting selector `&`. This is a common practice in CSS-in-JS libraries, and it's crucial for developers to understand how to use it to create interactive styles in their applications.",
      "ruleFile": "## Styling Pseudo-classes in Hono\n\nIn Hono, you can style pseudo-classes like `:hover` by using the nesting selector, `&`.\n\nHere is an example:\n\n```ts\nconst buttonClass = css`\n  background-color: #fff;\n  &:hover {\n    background-color: red;\n  }\n`\n```\n\nIn this code snippet, the `&` symbol represents the current selector. So, `&:hover` is equivalent to `.buttonClass:hover` in regular CSS. When the user hovers over an element with the `buttonClass` class, the background color changes to red.\n\n### Important Notes\n\n- The `&` symbol can be used to reference the current selector in other contexts as well, not just pseudo-classes.\n\n### References\n\n- [Nesting selector - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Nesting_selector)\n\n### Common Use Cases\n\n- Changing the color of a button when the user hovers over it\n- Displaying a dropdown menu when the user hovers over a navigation item",
      "ruleTitle": "Styling Pseudo-classes in Hono",
      "sourcePath": "docs/helpers/css.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the nesting selector and how to extend CSS definitions in Hono. This is a common practice in CSS-in-JS libraries to keep your code DRY (Don't Repeat Yourself) and to maintain a consistent style across your application.",
      "ruleFile": "## CSS Nesting and Extending in Hono\n\nIn Hono, you can use the nesting selector, `&`, to define styles that should apply under certain conditions. For example, you can define a hover style for a button like this:\n\n```ts\nconst buttonClass = css`\n  background-color: #fff;\n  &:hover {\n    background-color: red;\n  }\n`\n```\n\nIn this snippet, the `&:hover` means 'when this element is hovered over'. The `&` refers to the parent selector, in this case the button.\n\nYou can also extend the CSS definition by embedding the class name. This is useful when you want to apply a base style to multiple elements, but with some variations. For example:\n\n```tsx\nconst baseClass = css`\n  color: white;\n  background-color: blue;\n`\n\nconst header1Class = css`\n  ${baseClass}\n  font-size: 3rem;\n`\n\nconst header2Class = css`\n  ${baseClass}\n  font-size: 2rem;\n`\n```\n\nIn this snippet, both `header1Class` and `header2Class` will have the styles defined in `baseClass`, but with different font sizes.\n\n### Important notes\n\n- The `&` symbol refers to the parent selector.\n- You can embed a class name to extend its styles.\n\n### References\n\n- [Nesting selector](https://developer.mozilla.org/en-US/docs/Web/CSS/Nesting_selector)\n\n### Common use cases\n\n- Defining hover, active, focus, etc. styles for an element.\n- Creating base styles that can be extended and customized for different elements.",
      "ruleTitle": "Using Nesting Selectors and Extending CSS in Hono",
      "sourcePath": "docs/helpers/css.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to reuse and nest CSS classes in Hono. This promotes code reusability and maintainability, as changes to the base class will propagate to all classes that use it. It also shows how to structure CSS in a hierarchical manner, which can make the code easier to understand and manage.",
      "ruleFile": "## Reusing and Nesting CSS Classes in Hono\n\nThis code snippet demonstrates how to reuse and nest CSS classes in Hono. This is done by defining a base class and then using it in other classes. The syntax `${baseClass} {}` is used to nest classes.\n\n```tsx\nconst baseClass = css`\n  color: white;\n  background-color: blue;\n`\n\nconst header1Class = css`\n  ${baseClass}\n  font-size: 3rem;\n`\n\nconst header2Class = css`\n  ${baseClass}\n  font-size: 2rem;\n`\n\nconst headerClass = css`\n  color: white;\n  background-color: blue;\n`\n\nconst containerClass = css`\n  ${headerClass} {\n    h1 {\n      font-size: 3rem;\n    }\n  }\n`\n```\n\n### How it works\n\nThe base class is defined with the `css` function. This class is then used in other classes with the `${baseClass}` syntax. This allows the properties of the base class to be reused in other classes. The `${baseClass} {}` syntax is used to nest classes, allowing for hierarchical structuring of CSS.\n\n### Important notes\n\n- Changes to the base class will propagate to all classes that use it, promoting code maintainability.\n- Nesting classes can make the code easier to understand and manage.\n\n### References\n\n- [Hono Documentation](https://hono.bokuweb.me/)\n\n### Common use cases\n\n- When you want to reuse CSS properties across multiple classes.\n- When you want to structure your CSS in a hierarchical manner.",
      "ruleTitle": "Reusing and Nesting CSS Classes in Hono",
      "sourcePath": "docs/helpers/css.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define global styles in Hono using the `:-hono-global` pseudo-selector. This is useful when you want to apply a certain style to all elements of a particular type, regardless of their location in the document tree.",
      "ruleFile": "## Defining Global Styles in Hono\n\nIn Hono, you can define global styles using the `:-hono-global` pseudo-selector. This is useful when you want to apply a certain style to all elements of a particular type, regardless of their location in the document tree.\n\nHere is a code snippet demonstrating this:\n\n```tsx\nconst globalClass = css`\n  :-hono-global {\n    html {\n      font-family: Arial, Helvetica, sans-serif;\n    }\n  }\n`\n\nreturn c.render(\n  <div class={globalClass}>\n    <h1>Hello!</h1>\n    <p>Today is\n```\n\nIn this snippet, the `:-hono-global` pseudo-selector is used to define a global style that sets the font-family of all html elements to Arial, Helvetica, sans-serif.\n\n### Important Notes\n\n- The `:-hono-global` pseudo-selector can only be used within the `css` tagged template literal.\n- The styles defined within the `:-hono-global` block will be applied globally, affecting all matching elements in the document.\n\n### References\n\n- [Hono Documentation](https://hono.io/docs)\n\n### Common Use Cases\n\n- Setting a global font-family or font-size.\n- Applying a global background color or text color.",
      "ruleTitle": "Defining Global Styles in Hono",
      "sourcePath": "docs/helpers/css.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use `keyframes` in Hono to create animations. Animations can greatly enhance the user experience by providing visual feedback, guiding tasks, and offering a smooth transition.",
      "ruleFile": "## Using `keyframes` in Hono for Animations\n\nIn Hono, you can use `keyframes` to write the contents of `@keyframes`. This is useful for creating animations. In the given code snippet, `fadeInAnimation` is the name of the animation.\n\n```tsx\nconst fadeInAnimation = keyframes`\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n`\nconst headerClass = css`\n  animation-name: ${fadeInAnimation};\n  animation-duration: 2s;\n`\n```\n\n### How it works\n\n1. Define the `keyframes` with the desired animation. Here, the `fadeInAnimation` changes the opacity from 0 to 1.\n2. Use the defined `keyframes` in your CSS with the `animation-name` property.\n3. Set the `animation-duration` property to determine how long the animation should take.\n\n### Important notes\n\n- The `keyframes` feature in Hono is marked as experimental. It may change in future releases.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common use cases\n\n- Use `keyframes` to create animations for page transitions, loading spinners, and hover effects.",
      "ruleTitle": "Using `keyframes` in Hono for Animations",
      "sourcePath": "docs/helpers/css.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `cx` function in Hono to composite multiple class names. This is useful when you want to apply multiple styles to a single element, and those styles are defined in separate classes.",
      "ruleFile": "## Using `cx` to Composite Class Names in Hono\n\nIn Hono, you can use the `cx` function to composite multiple class names. This is useful when you want to apply multiple styles to a single element, and those styles are defined in separate classes.\n\nHere is a code snippet demonstrating this:\n\n```tsx\nconst buttonClass = css`\n  border-radius: 10px;\n`\nconst primaryClass = css`\n  background: orange;\n`\nconst Button = () => (\n  <a class={cx(buttonClass, primaryClass)}>Click!</a>\n)\n```\n\nIn this example, the `Button` component has two classes applied to it: `buttonClass` and `primaryClass`. The `cx` function composites these two classes, allowing the button to have both a border radius and an orange background.\n\n### Important Notes\n\n- The `cx` function is experimental and may change in future versions of Hono.\n\n### References\n\n- [Hono Documentation](https://hono.brontosaurusrex.com/)\n\n### Common Use Cases\n\n- Applying multiple styles to a single element\n- Compositing classes to create complex styles",
      "ruleTitle": "Compositing Class Names with `cx` in Hono",
      "sourcePath": "docs/helpers/css.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use css in Hono to define and apply styles to components. It shows how to define css classes and how to apply multiple classes to a component using the cx function. It also shows that the cx function can be used to compose simple strings.",
      "ruleFile": "# CSS Class Composition in Hono\n\nThis code snippet demonstrates how to define and apply CSS styles to components in Hono. It also shows how to use the `cx` function to apply multiple classes to a component and to compose simple strings.\n\n```tsx\nconst buttonClass = css`\n  border-radius: 10px;\n`\nconst primaryClass = css`\n  background: orange;\n`\nconst Button = () => (\n  <a class={cx(buttonClass, primaryClass)}>Click!</a>\n)\n```\n\nIn the above code, `buttonClass` and `primaryClass` are CSS classes defined using the `css` function. The `cx` function is then used to apply both classes to the `Button` component.\n\nThe `cx` function can also be used to compose simple strings, as shown below:\n\n```tsx\nconst Header = () => <a class={cx('h1', primaryClass)}>Hi</a>\n```\n\nIn this case, the `cx` function is used to apply the 'h1' string and the `primaryClass` to the `Header` component.\n\n## Important notes\n\n- The `cx` function is a powerful tool for applying multiple classes or composing strings in Hono.\n- The `css` function is used to define CSS classes in Hono.\n\n## References\n\n- [Hono Documentation](https://hono.bike/docs)\n\n## Common use cases\n\n- Styling components in Hono\n- Applying multiple classes to a component\n- Composing simple strings",
      "ruleTitle": "CSS Class Composition in Hono",
      "sourcePath": "docs/helpers/css.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use css helpers in combination with the Secure Headers middleware in Hono. It shows how to add the 'nonce' attribute to the 'Style' component to avoid Content-Security-Policy issues caused by the css helpers. This is crucial for maintaining the security of the application and ensuring that the css helpers function correctly.",
      "ruleFile": "## Using CSS Helpers with Secure Headers Middleware in Hono\n\nThis code snippet demonstrates how to use css helpers in combination with the Secure Headers middleware in Hono. It shows how to add the 'nonce' attribute to the 'Style' component to avoid Content-Security-Policy issues caused by the css helpers.\n\n```tsx\n<Style nonce={c.get('secureHeadersNonce')} />\n```\n\n### How it Works\n\nThe 'nonce' attribute is a security feature that can be used to make a whitelist of trusted sources of content. By adding this attribute to the 'Style' component, you can ensure that the css helpers are trusted and will not cause Content-Security-Policy issues.\n\n### Important Notes\n\n- The 'nonce' attribute should be a base64-encoded random value that changes for each HTTP request.\n\n### References\n\n- [Secure Headers Middleware](/docs/middleware/builtin/secure-headers)\n- [Nonce Attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce)\n\n### Common Use Cases\n\nThis pattern is commonly used when you want to use css helpers in your Hono application and need to ensure that they do not cause security issues.",
      "ruleTitle": "Using CSS Helpers with Secure Headers Middleware in Hono",
      "sourcePath": "docs/helpers/css.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to manage cookies in Hono framework. It shows how to import and use the cookie helper functions such as getCookie, setCookie, and deleteCookie. Understanding this rule is crucial for developers to manage session data and user preferences, which are common use cases for cookies.",
      "ruleFile": "## Cookie Management in Hono\n\nThis code demonstrates how to manage cookies in Hono framework using the cookie helper functions.\n\n```ts\nimport { Hono } from 'hono'\nimport {\n  getCookie,\n  getSignedCookie,\n  setCookie,\n  setSignedCookie,\n  deleteCookie,\n} from 'hono/cookie'\n```\n\n### How it works\n\n1. Import the Hono framework and the cookie helper functions.\n2. Use the `setCookie` function to set a cookie. It takes three arguments: the context, the cookie name, and the cookie value.\n3. Use the `getCookie` function to retrieve a cookie. It takes two arguments: the context and the cookie name.\n4. Use the `deleteCookie` function to delete a cookie. It takes two arguments: the context and the cookie name.\n\n### Important notes\n\n- The `getSignedCookie` and `setSignedCookie` functions are used for signed cookies, which are a type of cookie that have a signature, so they can't be tampered with.\n\n### References\n\n- [Hono documentation](https://hono.bayfrontcloud.com/docs)\n\n### Common use cases\n\n- Managing session data\n- Storing user preferences",
      "ruleTitle": "Managing Cookies in Hono Framework",
      "sourcePath": "docs/helpers/cookie.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle cookies in Hono framework. It covers how to set, get, and delete regular cookies, which are common operations in web development for maintaining user sessions, tracking user behavior, etc.",
      "ruleFile": "## Handling Cookies in Hono\n\nThis rule demonstrates how to handle cookies in Hono framework. The operations include setting, getting, and deleting cookies.\n\n```ts\nimport { Hono } from 'hono'\nimport {\n  getCookie,\n  getSignedCookie,\n  setCookie,\n  setSignedCookie,\n  deleteCookie,\n} from 'hono/cookie'\n\napp.get('/cookie', (c) => {\n  setCookie(c, 'cookie_name', 'cookie_value')\n  const yummyCookie = getCookie(c, 'cookie_name')\n  deleteCookie(c, 'cookie_name')\n  const allCookies = getCookie(c)\n  // ...\n})\n```\n\nIn the above code:\n\n- `setCookie(c, 'cookie_name', 'cookie_value')` sets a cookie with the name 'cookie_name' and value 'cookie_value'.\n- `getCookie(c, 'cookie_name')` retrieves the value of the cookie named 'cookie_name'.\n- `deleteCookie(c, 'cookie_name')` deletes the cookie named 'cookie_name'.\n- `getCookie(c)` retrieves all cookies.\n\nNote: The 'c' parameter represents the context of the request.\n\nCommon use cases include maintaining user sessions, tracking user behavior, etc.",
      "ruleTitle": "Handling Cookies in Hono",
      "sourcePath": "docs/helpers/cookie.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set, retrieve, and delete signed cookies in Hono. Signed cookies are a security measure that ensures the data stored in the cookie has not been tampered with. This is done by appending a signature to the cookie value and verifying it when the cookie is read.",
      "ruleFile": "## Handling Signed Cookies in Hono\n\nThis code snippet demonstrates how to set, retrieve, and delete signed cookies in Hono. Signed cookies are a security measure that ensures the data stored in the cookie has not been tampered with.\n\n```ts\napp.get('/signed-cookie', (c) => {\n  const secret = 'secret'\n\n  await setSignedCookie(c, 'cookie_name0', 'cookie_value', secret)\n  const fortuneCookie = await getSignedCookie(c, secret, 'cookie_name0')\n  deleteCookie(c, 'cookie_name0')\n  const allSignedCookies = await getSignedCookie(c, secret)\n})\n```\n\nIn this snippet:\n\n- A secret key is defined.\n- `setSignedCookie` is used to set a signed cookie.\n- `getSignedCookie` is used to retrieve the value of a signed cookie. It will return `false` if the signature was tampered with or is invalid.\n- `deleteCookie` is used to delete a cookie.\n\n### Important Notes\n\n- The secret key should be a large enough string to be secure.\n- The operations are asynchronous due to the async nature of the WebCrypto API, which is used to create HMAC SHA-256 signatures.\n\n### Common Use Cases\n\n- Storing user session information in a secure manner.\n- Storing temporary data between requests.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)",
      "ruleTitle": "Handling Signed Cookies in Hono",
      "sourcePath": "docs/helpers/cookie.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set and delete cookies in Hono, including regular and signed cookies. Cookies are essential for maintaining session data and other information on the client side. Understanding how to correctly set and delete cookies is crucial for managing user sessions, personalization, and tracking.",
      "ruleFile": "## Setting and Deleting Cookies in Hono\n\nThis code demonstrates how to set and delete cookies in Hono. It includes examples for both regular and signed cookies.\n\n### Code Snippet:\n\n```ts\n// Regular cookies\nsetCookie(c, 'great_cookie', 'banana', {\n  path: '/',\n  secure: true,\n  domain: 'example.com',\n  httpOnly: true,\n  maxAge: 1000,\n  expires: new Date(Date.UTC(2000, 11, 24, 10, 30, 59, 900)),\n  sameSite: 'Strict',\n})\n\n// Signed cookies\nawait setSignedCookie(\n  c,\n  'fortune_cookie',\n  'lots-of-money',\n  'secret ingredient',\n  {\n    path: '/',\n    secure: true,\n    domain: 'example.com',\n    httpOnly: true,\n    maxAge: 1000,\n    expires: new Date(Date.UTC(2000, 11, 24, 10, 30, 59, 900)),\n    sameSite: 'Strict',\n  }\n)\n```\n\n### How it works:\n\nThe `setCookie` function is used to set a regular cookie, while the `setSignedCookie` function is used to set a signed cookie. Both functions take a context object, the cookie name, the cookie value, and an options object as parameters. The options object can include properties like `path`, `secure`, `domain`, `httpOnly`, `maxAge`, `expires`, and `sameSite`.\n\n### Important notes:\n\n- `setSignedCookie` also takes a secret parameter, which is used to sign the cookie.\n- The `deleteCookie` function is used to delete a cookie. It takes a context object, the cookie name, and an options object as parameters. The options object can include properties like `path`, `secure`, and `domain`.\n\n### References:\n\n- [Hono documentation](https://hono.bespoken.io/docs/cookies/)\n\n### Common use cases:\n\n- Storing user session data\n- Tracking user behavior\n- Personalizing user experience",
      "ruleTitle": "Setting and Deleting Cookies in Hono",
      "sourcePath": "docs/helpers/cookie.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to delete a cookie using the Hono web framework. Understanding how to delete cookies is crucial for managing user sessions, tracking, and personalization features.",
      "ruleFile": "## Hono Delete Cookie Helper\n\nThis code snippet demonstrates how to delete a cookie using the Hono web framework.\n\n```ts\ndeleteCookie(c, 'banana', {\n  path: '/',\n  secure: true,\n  domain: 'example.com',\n})\n```\n\n### How it works\n\nThe `deleteCookie` function takes three parameters:\n\n1. `c`: The context object.\n2. `'banana'`: The name of the cookie to be deleted.\n3. An options object that specifies the path, whether the cookie is secure, and the domain.\n\n### Important notes\n\n- The `deleteCookie` function returns the deleted value.\n- The Cookie helper supports `__Secure-` and `__Host-` prefix.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/cookies)\n\n### Common use cases\n\n- Deleting user session cookies when a user logs out.\n- Deleting tracking cookies when a user opts out of tracking.",
      "ruleTitle": "Deleting Cookies in Hono",
      "sourcePath": "docs/helpers/cookie.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to delete a cookie using the Hono framework. It also shows how to handle cookies with `__Secure-` and `__Host-` prefixes, which are security features for cookies. Understanding this rule is crucial for managing user sessions and implementing security measures in web applications.",
      "ruleFile": "# Deleting Cookies in Hono\n\nThis code demonstrates how to delete a cookie in Hono.\n\n```ts\ndeleteCookie(c, 'banana', {\n  path: '/',\n  secure: true,\n  domain: 'example.com',\n})\n```\n\nThe `deleteCookie` function returns the deleted value:\n\n```ts\nconst deletedCookie = deleteCookie(c, 'delicious_cookie')\n```\n\n## `__Secure-` and `__Host-` prefix\n\nThe Cookie helper in Hono supports `__Secure-` and `__Host-` prefixes for cookie names. These prefixes are used to enhance the security of the cookies.\n\nTo verify if the cookie name has a prefix, specify the prefix option:\n\n```ts\nconst deletedCookie = deleteCookie(c, 'delicious_cookie')\n```\n\n## Important Notes\n\n- The `deleteCookie` function requires the cookie name and optionally, the path, secure flag, and domain.\n- The `__Secure-` and `__Host-` prefixes are used to ensure that the cookie is only sent over secure connections and cannot be accessed via JavaScript respectively.\n\n## Common Use Cases\n\n- Deleting user session cookies when the user logs out.\n- Deleting cookies when they are no longer needed to free up space.\n\n## References\n\n- [MDN Web Docs - Secure and HttpOnly cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies)",
      "ruleTitle": "Deleting Cookies and Handling Secure Cookie Prefixes in Hono",
      "sourcePath": "docs/helpers/cookie.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `__Secure-` and `__Host-` prefixes in cookie names using the Hono framework. These prefixes add an extra layer of security to cookies. The `__Secure-` prefix tells the browser to only send the cookie over an encrypted HTTPS connection. The `__Host-` prefix requires the cookie to be secure and its path attribute to be `/`, ensuring that the cookie won't be sent across different sites.",
      "ruleFile": "## Using `__Secure-` and `__Host-` Prefixes in Cookie Names with Hono\n\nIn Hono, you can add `__Secure-` and `__Host-` prefixes to cookie names for added security. Here's how you can do it:\n\n```ts\nconst securePrefixCookie = getCookie(c, 'yummy_cookie', 'secure')\nconst hostPrefixCookie = getCookie(c, 'yummy_cookie', 'host')\n\nconst securePrefixSignedCookie = await getSignedCookie(\n  c,\n  secret,\n  'fortune_cookie',\n  'secure'\n)\nconst hostPrefixSignedCookie = await getSignedCookie(\n  c,\n  secret,\n  'fortune_cookie',\n  'host'\n)\n```\n\nIn this code snippet, `getCookie` and `getSignedCookie` functions are used to retrieve cookies with `__Secure-` and `__Host-` prefixes. The third argument to these functions is the prefix type.\n\nTo set a cookie with a prefix, you can use the `setCookie` function and specify the prefix type in the options object:\n\n```ts\nsetCookie(c, 'delicious_cookie', 'macha', {\n  prefix: 'secure', // or `host`\n})\n```\n\n### Important Notes\n\n- The `__Secure-` prefix tells the browser to only send the cookie over an encrypted HTTPS connection.\n- The `__Host-` prefix requires the cookie to be secure and its path attribute to be `/`, ensuring that the cookie won't be sent across different sites.\n\n### References\n\n- [Cookie Prefixes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Cookie_prefixes)\n\n### Common Use Cases\n\n- Use `__Secure-` and `__Host-` prefixes when you want to ensure that your cookies are only sent over secure connections and are not accessible across different sites.",
      "ruleTitle": "Using `__Secure-` and `__Host-` Prefixes in Cookie Names with Hono",
      "sourcePath": "docs/helpers/cookie.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set cookies and signed cookies in Hono with a prefix. The prefix option is used to specify a prefix when setting the cookie. Following best practices for cookie settings is crucial for secure and efficient web development.",
      "ruleFile": "## Setting Cookies and Signed Cookies with a Prefix in Hono\n\nThis code snippet demonstrates how to set cookies and signed cookies in Hono with a prefix.\n\n```ts\nsetCookie(c, 'delicious_cookie', 'macha', {\n  prefix: 'secure', // or `host`\n})\n\nawait setSignedCookie(\n  c,\n  'delicious_cookie',\n  'macha',\n  'secret choco chips',\n  {\n    prefix: 'secure', // or `host`\n  }\n)\n```\n\n### How it works\n\nThe `setCookie` and `setSignedCookie` functions are used to set a cookie and a signed cookie respectively. The `prefix` option is used to specify a prefix when setting the cookie.\n\n### Important notes\n\nFollowing the best practices for cookie settings is crucial for secure and efficient web development. The New Cookie RFC (a.k.a cookie-bis) and CHIPS include some best practices for Cookie settings that developers should follow.\n\n### References\n\n- [RFC6265bis-13](https://datatracker.i\n\n### Common use cases\n\nThis is commonly used when you want to set a cookie or a signed cookie with a specific prefix in a Hono application.",
      "ruleTitle": "Setting Cookies and Signed Cookies with a Prefix in Hono",
      "sourcePath": "docs/helpers/cookie.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle WebSocket connections in the Hono framework. It shows how to upgrade a connection to a WebSocket and handle incoming messages from the client.",
      "ruleFile": "## Handling WebSocket Connections in Hono\n\nThis code snippet demonstrates how to handle WebSocket connections in the Hono framework using the `upgradeWebSocket()` function.\n\n```ts\nimport type { ServerWebSocket } from 'bun'\n\nconst { upgradeWebSocket, websocket } = createBunWebSocket<ServerWebSocket>()\n\n// ...\n\nexport default {\n  fetch: app.fetch,\n  websocket,\n}\n```\n\nIn the above code, `upgradeWebSocket()` is used to return a handler for handling WebSocket connections. This handler can be used to listen for incoming messages from the client and send responses.\n\n### How it Works\n\n1. Import the necessary modules and types.\n2. Create a new WebSocket using `createBunWebSocket()`.\n3. Use `upgradeWebSocket()` to return a handler for handling WebSocket connections.\n4. Export the handler so it can be used elsewhere in your application.\n\n### Important Notes\n\n- The `upgradeWebSocket()` function is part of the Hono framework and is designed to work with the `ServerWebSocket` type from the 'bun' module.\n\n### References\n\n- [@hono/node-ws](https://github.com/honojs/middleware/tree/main/packages/node-ws)\n\n### Common Use Cases\n\n- Real-time applications that require bi-directional communication between the client and server.\n- Applications that require push notifications from the server to the client.",
      "ruleTitle": "Handling WebSocket Connections in Hono",
      "sourcePath": "docs/helpers/websocket.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates the use of WebSocket Helper in Hono framework and the events it supports. It also highlights the caution required when using middleware that modifies headers on a route that uses WebSocket Helper, as it can lead to errors due to immutable headers.",
      "ruleFile": "## WebSocket Helper in Hono Framework\n\nThe WebSocket Helper in Hono framework supports various events such as `onOpen`, `onMessage`, `onClose`, and `onError`. However, currently, Cloudflare Workers does not support the `onOpen` event.\n\n```text\nAvailable events:\n\n- `onOpen` - Currently, Cloudflare Workers does not support it.\n- `onMessage`\n- `onClose`\n- `onError`\n```\n\nIt's important to note that if you use middleware that modifies headers (e.g., applying CORS) on a route that uses WebSocket Helper, you may encounter an error saying you can't modify immutable headers. This is because `upgradeWebSocket()` also changes headers internally. Therefore, caution is required when using WebSocket Helper and middleware at the same time.\n\nHandlers defined with WebSocket Helper also support RPC mode.\n\n### How it works\n\nWhen a WebSocket connection is established, the events are triggered based on the interaction. For instance, `onMessage` is triggered when a message is received from the client.\n\n### Important notes\n\nBe cautious when using middleware that modifies headers on a route that uses WebSocket Helper, as it can lead to errors due to immutable headers.\n\n### References\n\n- Hono framework documentation\n\n### Common use cases\n\n- Real-time communication between client and server\n- Implementing chat applications, multiplayer games, live updates, etc.",
      "ruleTitle": "Using WebSocket Helper in Hono Framework",
      "sourcePath": "docs/helpers/websocket.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a WebSocket client and server using the Hono framework. It shows how to upgrade an HTTP connection to a WebSocket connection on the server side and how to create a WebSocket client that connects to the server.",
      "ruleFile": "## WebSocket Server and Client Creation in Hono\n\nThis code demonstrates how to create a WebSocket server and client using the Hono framework.\n\n```ts\n// server.ts\nimport { Hono } from 'hono'\nimport { upgradeWebSocket } from 'hono/cloudflare-workers'\n\nconst app = new Hono().get(\n  '/ws',\n  upgradeWebSocket(() => {\n    return {\n      onMessage: (e\n\n// client.ts\nconst client = hc<WebSocketApp>('http://localhost:8787')\nconst socket = client.ws.$ws() // A WebSocket object for a client\n```\n\n### How it works\n\nOn the server side, the `upgradeWebSocket` function is used to upgrade an HTTP connection to a WebSocket connection. On the client side, the `hc` function is used to create a WebSocket client that connects to the server.\n\n### Important notes\n\n- The `upgradeWebSocket` function is specific to the Hono framework and may not work with other frameworks.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- Real-time applications such as chat apps, live updates, etc.",
      "ruleTitle": "Creating WebSocket Server and Client in Hono",
      "sourcePath": "docs/helpers/websocket.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to establish a WebSocket connection using the Hono framework. WebSockets provide a full-duplex communication channel over a single TCP connection, which is essential for real-time data transfer between the client and server.",
      "ruleFile": "## Establishing WebSocket Connection with Hono\n\nThis code snippet demonstrates how to establish a WebSocket connection using the Hono framework.\n\n```javascript\nconst client = hc<typeof app>('http://localhost:8787')\nconst ws = client.ws.$ws(0)\n\nws.addEventListener('open', () => {\n  setInterval(() => {\n    ws.send(new Date().toString())\n  }, 1000)\n})\n```\n\n### How it works\n\n1. A client is created that connects to the server at 'http://localhost:8787'.\n2. A WebSocket (ws) is created using the client's WebSocket method.\n3. An event listener is added to the WebSocket that triggers when the connection is opened.\n4. Inside the event listener, a setInterval function is used to send the current date and time to the server every second.\n\n### Important notes\n\n- The WebSocket connection is established at the start of the application and remains open for real-time data transfer.\n- The server must be set up to handle WebSocket connections and messages.\n\n### References\n\n- [Hono Documentation](https://hono.bouffier.com/docs)\n\n### Common use cases\n\n- Real-time data transfer between client and server\n- Live updates or notifications\n- Collaborative applications where multiple users interact with the same data",
      "ruleTitle": "Establishing WebSocket Connection with Hono",
      "sourcePath": "docs/helpers/websocket.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the JWT functionality from the Hono framework. JWT (JSON Web Tokens) are commonly used for authorization purposes in web applications. Understanding how to import and use these functions is crucial for implementing secure authorization in a web application using Hono.",
      "ruleFile": "## Importing and Using JWT Functionality in Hono\n\nThis code snippet demonstrates how to import and use the JWT functionality from the Hono framework.\n\n```ts\nimport { decode, sign, verify } from 'hono/jwt'\n```\n\n### How it works\n\nThe `decode`, `sign`, and `verify` functions are imported from the `hono/jwt` module. These functions are used to handle JWT tokens in the application.\n\n- `decode`: This function is used to decode a JWT token and retrieve the payload.\n- `sign`: This function is used to generate a JWT token by encoding a payload and signing it.\n- `verify`: This function is used to verify a JWT token and ensure it is valid.\n\n### Important notes\n\nThe JWT Middleware also imports the `jwt` function from the `hono/jwt` module.\n\n### References\n\n- [JWT Middleware](/docs/middleware/builtin/jwt)\n\n### Common use cases\n\n- Implementing user authentication and authorization in a web application.\n- Verifying the integrity of data sent between the client and server.",
      "ruleTitle": "Importing and Using JWT Functionality in Hono",
      "sourcePath": "docs/helpers/jwt.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'sign' function from the 'hono/jwt' module to generate a JWT token. JWT tokens are a common method for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed.",
      "ruleFile": "## JWT Token Generation in Hono\n\nThe `sign` function from the `hono/jwt` module is used to generate a JWT (JSON Web Token) by encoding a payload and signing it using a specified algorithm and secret.\n\nHere is the function signature:\n\n```ts\nsign(\n  payload: unknown,\n  secret: string,\n  alg?: 'HS256';\n): Promise<string>;\n```\n\nAnd here is an example of its usage:\n\n```ts\nimport { sign } from 'hono/jwt'\n\nconst payload = {\n  sub: 'user123',\n  role: 'admin',\n  exp: Math.floor(Date.now() / 1000) + 60 * 5, // Token expires in 5 minutes\n}\n\nconst secret = 'your-secret'\n\nconst token = await sign(payload, secret)\n```\n\nIn this example, a payload is created with a subject (`sub`), a role, and an expiration time (`exp`). The `sign` function is then used to generate a JWT token using this payload and a secret.\n\n### Important Notes\n\n- The `sign` function returns a promise that resolves to a string. This string is the JWT token.\n\n- The `alg` parameter is optional and defaults to 'HS256', which stands for HMAC SHA-256, a commonly used cryptographic algorithm for generating JWT tokens.\n\n### References\n\n- [Hono JWT Documentation](https://hono.bryntum.com/docs/modules/jwt.html)\n\n### Common Use Cases\n\n- Authenticating users in a web application\n- Securely transmitting information between parties",
      "ruleTitle": "Generating JWT Tokens in Hono",
      "sourcePath": "docs/helpers/jwt.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to verify a JWT token using the Hono framework. JWT tokens are used for authentication and secure data transfer. Verifying the token ensures it hasn't been tampered with and is still valid, which is crucial for maintaining security in web applications.",
      "ruleFile": "## JWT Token Verification in Hono\n\nThis code snippet demonstrates how to verify a JWT token using the Hono framework.\n\n```ts\nverify(\n  token: string,\n  secret: string,\n  alg?: 'HS256';\n): Promise<any>;\n```\n\n### How it works\n\nThe `verify` function takes in three parameters: the token to be verified, the secret key used for signing the token, and an optional algorithm parameter (default is 'HS256'). It returns a promise that resolves with the decoded payload if the token is valid.\n\n### Example\n\n```ts\nimport { verify } from 'hono/jwt'\n\nconst tokenToVerify = 'token'\nconst secretKey = 'mySecretKey'\n\nconst decodedPayload = await verify(tokenToVerify, secretKey)\nconsole.log(decodedPayload)\n```\n\n### Important notes\n\n- The `verify` function only checks the validity of the token if you have added Payload Validation.\n- The secret key should be kept secure and not exposed to the client.\n\n### References\n\n- [Hono JWT Documentation](https://hono.bryntum.com/docs/classes/jwt.html)\n\n### Common use cases\n\n- Verifying user authentication tokens in a web application.",
      "ruleTitle": "Verifying JWT Tokens in Hono",
      "sourcePath": "docs/helpers/jwt.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to decode a JWT token using the Hono framework. Decoding a JWT token is a common operation in web development, especially when dealing with authentication and authorization. It allows developers to extract the header and payload from the token, which can contain useful information such as the user's role or other metadata.",
      "ruleFile": "## Decoding a JWT Token in Hono\n\nThis code snippet demonstrates how to decode a JWT token using the Hono framework. The `decode` function extracts and returns the header and payload from the token.\n\n```ts\nimport { decode } from 'hono/jwt'\n\n// Decode the JWT token\nconst tokenToDecode = 'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJzdWIiOiAidXNlcjEyMyIsICJyb2xlIjogImFkbWluIn0.JxUwx6'\n\nconst decodedToken = decode(tokenToDecode);\n```\n\n### How it works\n\nThe `decode` function takes a JWT token as a string and returns an object with the header and payload.\n\n### Important notes\n\nThis function does not perform signature verification. It should be used when you trust the source of the token and don't need to verify it.\n\n### References\n\n- [Hono Documentation](https://hono.bryntum.com/docs/classes/jwt.html#decode)\n\n### Common use cases\n\n- Extracting user information from a JWT token in an authenticated request\n- Debugging JWT tokens during development",
      "ruleTitle": "Decoding a JWT Token in Hono",
      "sourcePath": "docs/helpers/jwt.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to decode a JWT token using Hono framework. Decoding a JWT token is a common requirement in many applications for inspecting the header and payload of the token. This rule can be used as a reference for developers to understand how to use the 'decode' function from 'hono/jwt' to decode a JWT token.",
      "ruleFile": "## Decoding JWT Token in Hono Framework\n\nThis code snippet demonstrates how to decode a JWT token using Hono framework. The 'decode' function from 'hono/jwt' is used to decode the token.\n\n```ts\nimport { decode } from 'hono/jwt'\n\n// Decode the JWT token\nconst tokenToDecode = 'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJzdWIiOiAidXNlcjEyMyIsICJyb2xlIjogImFkbWluIn0.JxUwx6Ua1B0D1B0FtCrj72ok5cm1Pkmr_hL82sd7ELA'\n\nconst { header, payload } = decode(tokenToDecode)\n\nconsole.log('Decoded Header:', header)\nconsole.log('Decoded Payload:', payload)\n```\n\n### How it works\n\nThe 'decode' function takes a JWT token as input and returns an object containing the header and payload of the token.\n\n### Important notes\n\n- The 'decode' function does not perform signature verification. It only decodes the token to extract the header and payload.\n\n### References\n\n- [Hono JWT Documentation](https://hono.bosch.io/docs/api/jwt/)\n\n### Common use cases\n\n- Inspecting the header and payload of a JWT token in applications.",
      "ruleTitle": "Decoding JWT Token in Hono Framework",
      "sourcePath": "docs/helpers/jwt.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the development helper methods provided by the Hono framework. These methods can be useful for debugging and development purposes. The `getRouterName()` function can be used to retrieve the name of the currently used router, and the `showRoutes()` function can be used to display the routes.",
      "ruleFile": "## Using Dev Helper Methods in Hono\n\nIn Hono, you can use the development helper methods for debugging and development purposes. Here's how you can do it:\n\n```ts\nimport { Hono } from 'hono'\nimport { getRouterName, showRoutes } from 'hono/dev'\n```\n\n### `getRouterName()`\n\nYou can get the name of the currently used router with `getRouterName()`.\n\n```ts\nconst app = new Hono()\n\n// ...\n\nconsole.log(getRouterName(app))\n```\n\n### `showRoutes()`\n\nYou can use `showRoutes()` to display the routes.\n\n```ts\nconst app = new Hono()\n\n// ...\n\nshowRoutes(app)\n```\n\n## Important Notes\n\n- These methods are meant to be used in a development environment and not in a production environment.\n\n## References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n## Common Use Cases\n\n- Debugging router issues\n- Visualizing the routes in your application",
      "ruleTitle": "Using Development Helper Methods in Hono",
      "sourcePath": "docs/helpers/dev.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the helper functions `getRouterName()` and `showRoutes()` in the Hono framework. These functions are useful for debugging and understanding the state of your application, as they allow you to retrieve the name of the currently used router and display the registered routes respectively.",
      "ruleFile": "## Using Helper Functions in Hono\n\nIn Hono, there are helper functions that can be used for debugging and understanding the state of your application. Two of these functions are `getRouterName()` and `showRoutes()`.\n\n### `getRouterName()`\n\nYou can get the name of the currently used router with `getRouterName()`. Here is an example of how to use it:\n\n```ts\nimport { Hono } from 'hono'\nimport { getRouterName } from 'hono/dev'\n\nconst app = new Hono()\n\n// ...\n\nconsole.log(getRouterName(app))\n```\n\n### `showRoutes()`\n\n`showRoutes()` function displays the registered routes in your console. Here is an example of how to use it:\n\n```ts\nimport { Hono } from 'hono'\nimport { showRoutes } from 'hono/dev'\n\nconst app = new Hono().basePath('/v1')\n\napp.get('/posts')\n\n// ...\n\nshowRoutes(app)\n```\n\nThese functions are particularly useful during the development phase of your application, as they provide insights into the state of your router and routes.",
      "ruleTitle": "Using Helper Functions in Hono",
      "sourcePath": "docs/helpers/dev.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to display all the registered routes in a Hono application. This can be useful for debugging and understanding the structure of the application.",
      "ruleFile": "## Displaying Registered Routes in Hono\n\nIn Hono, you can display all the registered routes in your application using the `showRoutes()` function. This can be particularly useful for debugging and understanding the structure of your application.\n\nHere is an example of how to use it:\n\n```ts\nconst app = new Hono().basePath('/v1')\n\napp.get('/posts', (c) => {\n  // ...\n})\n\napp.get('/posts/:id', (c) => {\n  // ...\n})\n\napp.post('/posts', (c) => {\n  // ...\n})\n\nshowRoutes(app, {\n  verbose: true,\n})\n```\n\nWhen this application starts running, the routes will be shown in your console as follows:\n\n```txt\nGET   /v1/posts\nGET   /v1/posts/:id\nPOST  /v1/posts\n```\n\n### Notes\n\n- The `showRoutes()` function takes two arguments: the Hono application instance and an options object. In this case, we're passing `{ verbose: true }` to display detailed information about each route.\n- The `basePath()` function sets a base path for all routes. In this case, all routes will be prefixed with `/v1`.\n\n### References\n\n- [Hono Documentation](https://hono.bespokejs.com)\n\n### Common Use Cases\n\n- Debugging: You can use this feature to quickly check all the routes in your application and ensure they are set up correctly.\n- Documentation: This can also be useful for generating documentation for your API, as it provides a clear overview of all the available endpoints.",
      "ruleTitle": "Displaying Registered Routes in Hono",
      "sourcePath": "docs/helpers/dev.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define routes in a Hono application and how to use the 'showRoutes' function to display the routes in the console. It also shows the usage of the 'verbose' option, which when set to true, displays more detailed information about the routes.",
      "ruleFile": "## Defining and Displaying Routes in Hono\n\nIn Hono, routes are defined using the `app.get` or `app.post` methods. The first argument is the route path and the second argument is a callback function that handles the request and response.\n\n```txt\napp.post('/posts', (c) => {\n  // ...\n})\n```\n\nTo display the routes in the console when the application starts, use the 'showRoutes' function. The 'verbose' option can be set to true to display more detailed information.\n\n```txt\nshowRoutes(app, {\n  verbose: true,\n})\n```\n\nWhen the application starts, the routes will be displayed in the console as follows:\n\n```txt\nGET   /v1/posts\nGET   /v1/posts/:id\nPOST  /v1/posts\n```\n\n### Important Notes\n\n- The callback function for a route takes a context object 'c' as an argument. This object contains information about the request and response.\n- The 'verbose' option in 'showRoutes' is optional. If it is not provided, the default value is false.\n\n### References\n\n- [Hono Documentation](https://hono.bike/)\n\n### Common Use Cases\n\n- Defining routes for different HTTP methods (GET, POST, etc.)\n- Displaying the routes in the console for debugging purposes",
      "ruleTitle": "Defining and Displaying Routes in Hono",
      "sourcePath": "docs/helpers/dev.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the 'getConnInfo' helper function from the Hono framework in both Lambda@Edge and Node.js contexts. This function is used to retrieve connection information, such as the remote address of a client, which can be useful in various scenarios like logging, debugging, or security checks.",
      "ruleFile": "## Importing and Using 'getConnInfo' in Hono\n\nThis rule demonstrates how to import and use the 'getConnInfo' helper function from the Hono framework in both Lambda@Edge and Node.js contexts.\n\n### Code Snippet\n\nFor Lambda@Edge:\n\n```ts\nimport { Hono } from 'hono'\nimport { getConnInfo } from 'hono/lambda-edge'\n```\n\nFor Node.js:\n\n```ts\nimport { Hono } from 'hono'\nimport { getConnInfo } from '@hono/node-server/conninfo'\n```\n\nUsage:\n\n```ts\nconst app = new Hono()\n\napp.get('/', (c) => {\n  const info = getConnInfo(c) // info is `ConnInfo`\n  return c.text(`Your remote address is ${info.remote.address}`)\n})\n```\n\n### How it Works\n\nThe 'getConnInfo' function is imported from the appropriate module depending on the context (Lambda@Edge or Node.js). It is then used inside a route handler to retrieve connection information from the context object 'c'. The remote address of the client is then sent back in the response.\n\n### Important Notes\n\n- The 'getConnInfo' function returns an object of type 'ConnInfo', which includes various properties related to the connection.\n- The context object 'c' passed to route handlers in Hono includes the request and response objects, among other things.\n\n### References\n\n- [Hono Documentation](https://hono.beyondnlp.com/)\n\n### Common Use Cases\n\n- Logging client information for debugging or analytics\n- Performing security checks based on client information",
      "ruleTitle": "Importing and Using 'getConnInfo' in Hono",
      "sourcePath": "docs/helpers/conninfo.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'getConnInfo()' helper function in Hono to retrieve connection information. It also shows the type definitions for the values that can be obtained from this function. Understanding this rule is crucial for developers to effectively use Hono's helper functions and handle connection information in their applications.",
      "ruleFile": "## Using 'getConnInfo()' Helper Function in Hono\n\nThis code snippet demonstrates how to use the 'getConnInfo()' helper function in Hono to retrieve connection information.\n\n```ts\nconst app = new Hono()\n\napp.get('/', (c) => {\n  const info = getConnInfo(c) // info is `ConnInfo`\n  return c.text(`Your remote address is ${info.remote.address}`)\n})\n```\n\nThe 'getConnInfo()' function returns an object of type 'ConnInfo'. The type definitions for the values that can be obtained from this function are as follows:\n\n```ts\ntype AddressType = 'IPv6' | 'IPv4' | undefined\n\ntype NetAddrInfo = {\n  /**\n   * Transport protocol type\n   */\n  transport?: 'tcp' | 'udp'\n  /**\n   * Transport port number\n   */\n  port?: number\n}\n```\n\n### How it Works\n\nThe 'getConnInfo()' function retrieves connection information from the context object 'c'. This information includes the remote address, transport protocol type, and transport port number.\n\n### Important Notes\n\n- The 'getConnInfo()' function is a helper function provided by Hono.\n- The returned 'ConnInfo' object contains detailed information about the connection.\n\n### References\n\n- [Hono Documentation](https://hono.beyondco.de/)\n\n### Common Use Cases\n\n- Retrieving connection information for logging or debugging purposes.\n- Displaying connection information to the user.",
      "ruleTitle": "Using 'getConnInfo()' Helper Function to Retrieve Connection Information in Hono",
      "sourcePath": "docs/helpers/conninfo.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the 'testClient' function from the 'hono/testing' module in Hono framework. This function is crucial for testing Hono applications as it simplifies the process by returning an instance of the Hono Client, which can be used to define requests.",
      "ruleFile": "## Importing and Using the testClient function in Hono\n\nThis code snippet demonstrates how to import and use the 'testClient' function from the 'hono/testing' module in Hono framework.\n\n```ts\nimport { Hono } from 'hono'\nimport { testClient } from 'hono/testing'\n```\n\n### How it works\n\nThe 'testClient()' function takes an instance of Hono as its first argument and returns an object of the Hono Client. This allows you to define your requests for testing purposes.\n\n### Important notes\n\n- The 'testClient()' function is part of the 'hono/testing' module and must be imported before use.\n- The function requires an instance of Hono as its first argument.\n\n### References\n\n- Hono Client: /docs/guides/rpc#client\n\n### Common use cases\n\n- Testing Hono applications: The 'testClient()' function simplifies the testing process by providing an instance of the Hono Client, which can be used to define requests.",
      "ruleTitle": "Importing and Using the testClient Function in Hono",
      "sourcePath": "docs/helpers/testing.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'testClient' function from Hono's testing module to test a Hono application. It shows how to create a Hono application, define a route, and then use the 'testClient' function to send a GET request to that route. The response is then checked to ensure it matches the expected output. This is a fundamental aspect of testing in Hono, ensuring that the application behaves as expected.",
      "ruleFile": "## Testing Hono Applications with testClient\n\nThis code snippet demonstrates how to use the 'testClient' function from Hono's testing module to test a Hono application.\n\n```ts\nimport { testClient } from 'hono/testing'\n\nit('test', async () => {\n  const app = new Hono().get('/search', (c) =>\n    c.json({ hello: 'world' })\n  )\n  const res = await testClient(app).search.$get()\n\n  expect(await res.json()).toEqual({ hello: 'world' })\n})\n```\n\nIn this example, a Hono application is created with a GET route '/search' that returns a JSON response. The 'testClient' function is then used to send a GET request to this route. The response is awaited and then checked to ensure it matches the expected output.\n\n### Important Notes\n\n- The 'testClient' function takes a Hono application as its argument and returns an object that can be used to send requests to the application.\n- The '$get' function is used to send a GET request to a specific route.\n\n### References\n\n- [Hono Testing Documentation](https://hono.bayrell.org/docs/en/testing)\n\n### Common Use Cases\n\n- Testing the behavior of routes in a Hono application.\n- Checking the response of a route to ensure it matches the expected output.",
      "ruleTitle": "Testing Hono Applications with testClient",
      "sourcePath": "docs/helpers/testing.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the streaming helpers provided by the Hono framework. These helpers allow for streaming responses in a Hono application, which can be useful for handling large amounts of data or real-time updates.",
      "ruleFile": "# Importing and Using Streaming Helpers in Hono\n\nThis code demonstrates how to import and use the streaming helpers provided by the Hono framework.\n\n```ts\nimport { Hono } from 'hono'\nimport { stream, streamText, streamSSE } from 'hono/streaming'\n```\n\n## How it works\n\n1. The `Hono` object is imported from the `hono` package. This object is the main entry point for using the Hono framework.\n2. The `stream`, `streamText`, and `streamSSE` functions are imported from the `hono/streaming` module. These functions are used to create streaming responses.\n\n## Important notes\n\n- The `stream` function returns a simple streaming response as a `Response` object.\n- The `streamText` function is used for streaming text responses.\n- The `streamSSE` function is used for streaming Server-Sent Events (SSE).\n\n## References\n\n- [Hono Documentation](https://hono.bike/docs/helpers/)\n\n## Common use cases\n\n- Streaming large amounts of data in a response.\n- Sending real-time updates to the client using SSE.",
      "ruleTitle": "Importing and Using Streaming Helpers in Hono",
      "sourcePath": "docs/helpers/streaming.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the stream() function in Hono to return a simple streaming response as a Response object. It shows how to handle the abort event, write a Uint8Array to the stream, and pipe a readable stream. Understanding this rule is crucial for developers who need to handle streaming responses in their Hono applications.",
      "ruleFile": "## Hono Streaming with stream()\n\nIn Hono, the `stream()` function is used to return a simple streaming response as a `Response` object. This function takes two arguments: the context `c` and an async function that handles the stream.\n\nHere is a code snippet demonstrating its usage:\n\n```ts\napp.get('/stream', (c) => {\n  return stream(c, async (stream) => {\n    // Write a process to be executed when aborted.\n    stream.onAbort(() => {\n      console.log('Aborted!')\n    })\n    // Write a Uint8Array.\n    await stream.write(new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]))\n    // Pipe a readable stream.\n    await stream.pipe(anotherReadableStream)\n  })\n})\n```\n\nIn this snippet:\n\n1. The `onAbort()` function is used to handle the abort event. In this case, it logs 'Aborted!' to the console.\n2. The `write()` function is used to write a Uint8Array to the stream.\n3. The `pipe()` function is used to pipe a readable stream.\n\n### Important Notes\n\n- Make sure to handle the abort event to prevent unexpected behavior.\n- The `write()` and `pipe()` functions return promises, so make sure to use `await` or handle the promises properly.\n\n### References\n\n- [Hono Documentation](https://hono.balthazar.dev/docs)\n\n### Common Use Cases\n\n- Streaming large files or data in chunks to prevent blocking the event loop.\n- Streaming real-time data.",
      "ruleTitle": "Handling Streaming Responses with Hono's stream() Function",
      "sourcePath": "docs/helpers/streaming.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the streamText function in Hono to return a streaming response with specific headers. It shows how to write text with and without a new line, and how to introduce a delay in the stream. This is useful in scenarios where data needs to be streamed to the client, for example, in real-time applications.",
      "ruleFile": "## Streaming Text in Hono\n\nThis code demonstrates how to use the `streamText` function in Hono to return a streaming response with specific headers. It shows how to write text with and without a new line, and how to introduce a delay in the stream.\n\n```ts\napp.get('/streamText', (c) => {\n  return streamText(c, async (stream) => {\n    // Write a text with a new line ('\\n').\n    await stream.writeln('Hello')\n    // Wait 1 second.\n    await stream.sleep(1000)\n    // Write a text without a new line.\n    await stream.write(`Hono!`)\n  })\n})\n```\n\n### How it works\n\nThe `streamText` function takes two arguments: the context `c` and a callback function. The callback function takes a `stream` object, which is used to write text to the response. The `writeln` method writes a text with a new line, while the `write` method writes a text without a new line. The `sleep` method introduces a delay in the stream.\n\n### Important notes\n\nIf you are developing an application for Cloudflare Workers, a streaming may not work well on Wrangler. If so, add `Identity` for `Content-Encoding` header.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common use cases\n\n- Real-time applications\n- Streaming large amounts of data",
      "ruleTitle": "Streaming Text in Hono",
      "sourcePath": "docs/helpers/streaming.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle streaming in Cloudflare Workers using the Hono framework. It shows the correct way to set the 'Content-Encoding' header to 'Identity' to ensure proper functioning of streaming on Wrangler.",
      "ruleFile": "## Handling Streaming in Cloudflare Workers with Hono\n\nWhen developing an application for Cloudflare Workers, streaming may not work well on Wrangler. To handle this, you need to set the 'Content-Encoding' header to 'Identity'.\n\nHere is a code snippet demonstrating this:\n\n```ts\napp.get('/streamText', (c) => {\n  c.header('Content-Encoding', 'Identity')\n  return streamText(c, async (stream) => {\n    // ...\n  })\n})\n```\n\nIn this code snippet, we are defining a GET route '/streamText'. Inside the route handler, we first set the 'Content-Encoding' header to 'Identity'. Then, we return a stream of text.\n\n### Important Notes\n\n- Make sure to set the 'Content-Encoding' header to 'Identity' when working with streaming on Wrangler.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common Use Cases\n\n- Streaming text or other data in a Cloudflare Worker application.",
      "ruleTitle": "Handling Streaming in Cloudflare Workers with Hono",
      "sourcePath": "docs/helpers/streaming.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the streamSSE() function in Hono to stream Server-Sent Events (SSE). This is a common use case for real-time applications where the server needs to push updates to the client.",
      "ruleFile": "## Streaming Server-Sent Events (SSE) with Hono\n\nThis code snippet demonstrates how to use the `streamSSE()` function in Hono to stream Server-Sent Events (SSE). This is a common use case for real-time applications where the server needs to push updates to the client.\n\n```ts\nconst app = new Hono()\nlet id = 0\n\napp.get('/sse', async (c) => {\n  return streamSSE(c, async (stream) => {\n    while (true) {\n      const message = `It is ${new Date().toISOString()}`\n      await stream.writeSSE({\n        data: message,\n        event: 'time-update',\n        id: String(id++),\n      })\n      await stream.sleep(1000)\n    }\n  })\n})\n```\n\n### How it works\n\nThe `streamSSE()` function takes two arguments: the context object `c` and a callback function. The callback function is called with a `stream` object that has a `writeSSE()` method. This method is used to send a Server-Sent Event to the client.\n\n### Important notes\n\n- The `writeSSE()` method takes an object with `data`, `event`, and `id` properties. The `data` property is the message to send, the `event` property is the type of event, and the `id` property is a unique identifier for the event.\n- The `stream.sleep()` method is used to pause execution for a specified amount of time. This is useful for throttling the rate of events.\n\n### References\n\n- [Hono Documentation](https://hono.bouzuya.net/)\n\n### Common use cases\n\n- Real-time updates: Use SSE to push updates from the server to the client in real-time. For example, you could use this to push real-time stock price updates, chat messages, or game state updates.",
      "ruleTitle": "Streaming Server-Sent Events with Hono",
      "sourcePath": "docs/helpers/streaming.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to handle errors in Hono's streaming helper. It shows how to use the third argument of the streaming helper as an error handler, and how to write a process to be executed when an error occurs or when the stream is aborted.",
      "ruleFile": "## Error Handling in Hono's Streaming Helper\n\nIn Hono, the third argument of the streaming helper is used as an error handler. This argument is optional, and if not specified, the error will be output as a console error.\n\nHere is an example of how to use it:\n\n```ts\napp.get('/stream', (c) => {\n  return stream(\n    c,\n    async (stream) => {\n      // Write a process to be executed when aborted.\n      stream.onAbort(() => {\n        console.log('Aborted!')\n      })\n      // Write a Uint8Array.\n      await stream.write(\n        new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f])\n      )\n      // Pipe a readable stream.\n      await stream.pipe(anotherReadableStream)\n    },\n    (err, stream) => {\n      stream.writeln('An error occurred!')\n      console.error(err)\n    }\n  )\n})\n```\n\nIn this code snippet, the error handler is used to write a message to the stream and output the error to the console when an error occurs.\n\nThe stream will be automatically closed after the callbacks are executed. If the callback function of the streaming helper throws an error, the `onError` event of Hono will not be triggered.\n\n### Important Notes\n\n- The error handler is optional. If not specified, the error will be output as a console error.\n- The stream will be automatically closed after the callbacks are executed.\n\n### References\n\n- [Hono Documentation](https://hono.bouzuya.net/)\n\n### Common Use Cases\n\n- Streaming large amounts of data\n- Handling errors during streaming",
      "ruleTitle": "Error Handling in Hono's Streaming Helper",
      "sourcePath": "docs/helpers/streaming.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the Factory Helper in Hono, which provides useful functions for creating Hono's components such as Middleware. It also shows how to create an instance of the Factory class using the createFactory() function. This is crucial for setting up the proper TypeScript types in Hono.",
      "ruleFile": "## Importing and Using Factory Helper in Hono\n\nThis code demonstrates how to import and use the Factory Helper in Hono to create an instance of the Factory class.\n\n```ts\nimport { Hono } from 'hono'\nimport { createFactory, createMiddleware } from 'hono/factory'\n```\n\nTo create an instance of the Factory class, use the `createFactory()` function.\n\n```ts\nimport { createFactory } from 'hono/factory'\n\nconst factory = createFactory()\n```\n\n### How it works\n\nThe `createFactory` function is imported from 'hono/factory' and used to create an instance of the Factory class. This instance can then be used to create Hono's components such as Middleware.\n\n### Important notes\n\n- The Factory Helper is a useful tool for setting up the proper TypeScript types in Hono.\n- The `createFactory` function creates an instance of the Factory class.\n\n### References\n\n- Hono documentation: https://hono.boshanlu.com/\n\n### Common use cases\n\n- Creating an instance of the Factory class to use in creating Hono's components such as Middleware.",
      "ruleTitle": "Importing and Using Factory Helper in Hono",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create an instance of the Factory class using the 'createFactory()' function in Hono. It also shows how to pass environment types as Generics to the function, which is crucial for type safety and ensuring the correct usage of environment variables within the application.",
      "ruleFile": "## Creating an Instance of the Factory Class in Hono\n\nIn Hono, you can create an instance of the Factory class using the 'createFactory()' function. This function is imported from 'hono/factory'.\n\nHere is a basic example of how to use it:\n\n```ts\nimport { createFactory } from 'hono/factory'\n\nconst factory = createFactory()\n```\n\nYou can also pass your environment types as Generics to the 'createFactory()' function. This is useful for ensuring type safety and correct usage of environment variables within your application. Here is an example:\n\n```ts\nimport { createFactory } from 'hono/factory'\n\ntype Env = {\n  Variables: {\n    foo: string\n  }\n}\n\nconst factory = createFactory<Env>()\n```\n\n### Important Notes\n\n- The 'createFactory()' function is a part of the 'hono/factory' module.\n- You can pass environment types as Generics to the function for type safety.\n\n### References\n\n- Hono Documentation: [https://hono.bespokejs.com](https://hono.bespokejs.com)\n\n### Common Use Cases\n\n- Creating an instance of the Factory class in Hono.\n- Passing environment types as Generics to the 'createFactory()' function.",
      "ruleTitle": "Creating an Instance of the Factory Class and Passing Environment Types as Generics in Hono",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create a factory instance in Hono with environment variables. It shows how to use the 'createFactory' function and how to pass environment types as Generics. This is a common pattern in Hono framework usage, and understanding this can help in creating more flexible and reusable code.",
      "ruleFile": "## Creating Factory Instance with Environment Variables in Hono\n\nIn Hono, you can create a factory instance using the 'createFactory' function. You can also pass your environment types as Generics to this function. Here is an example:\n\n```ts\nimport { createFactory } from 'hono/factory'\n\ntype Env = {\n  Variables: {\n    foo: string\n  }\n}\n\nconst factory = createFactory<Env>()\n```\n\nIn this code snippet, a type 'Env' is defined with a 'Variables' property. This 'Env' type is then passed as a Generic to the 'createFactory' function to create a factory instance.\n\n### How it works\n\nThe 'createFactory' function in Hono is used to create a factory instance. This function can take environment types as Generics, allowing you to define the types of your environment variables.\n\n### Important notes\n\n- The 'createFactory' function is a part of the 'hono/factory' module.\n- The environment types passed as Generics should be defined before they are used.\n\n### References\n\n- Hono Documentation: https://hono.bosch.io/docs/\n\n### Common use cases\n\n- Defining environment variables for a Hono application.\n- Creating a factory instance with specific environment variables.",
      "ruleTitle": "Creating Factory Instance with Environment Variables in Hono",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to set default options for a Hono application using the 'createFactory' function. It shows how to create a factory with default options and then use this factory to create an application with these default options.",
      "ruleFile": "## Setting Default Options for a Hono Application\n\nThis code snippet demonstrates how to set default options for a Hono application using the 'createFactory' function.\n\n```ts\nconst factory = createFactory({\n  defaultAppOptions: { strict: false },\n})\n\nconst app = factory.createApp() // `strict: false` is applied\n```\n\nIn this example, a factory is created with the default option 'strict' set to false. This factory is then used to create an application, and the 'strict' option is automatically applied to this application.\n\n### How it works\n\n1. The 'createFactory' function is called with an object containing the default options.\n2. This function returns a factory with these default options.\n3. The 'createApp' method of the factory is then called to create an application with these default options.\n\n### Important notes\n\n- The 'createFactory' function can be used to set any default options for a Hono application.\n- The 'createApp' method of the factory will automatically apply these default options to any applications it creates.\n\n### References\n\n- [Hono Documentation](https://hono.bryntum.com/docs/)\n\n### Common use cases\n\n- Setting default options for a Hono application to ensure consistent behavior across multiple instances of the application.",
      "ruleTitle": "Setting Default Options for a Hono Application",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create custom middleware in Hono. Middleware is a crucial part of any web application as it allows you to execute code before the final request handler, thus providing a way to manage the request-response cycle. In this case, the custom middleware is used to set a response header.",
      "ruleFile": "## Creating Custom Middleware in Hono\n\nIn Hono, you can create custom middleware using the `createMiddleware()` function. This function allows you to execute code before the final request handler, thus providing a way to manage the request-response cycle.\n\nHere is an example of how to create a custom middleware that sets a response header:\n\n```ts\nconst messageMiddleware = createMiddleware(async (c, next) => {\n  await next()\n  c.res.headers.set('X-Message', 'Good morning!')\n})\n```\n\nIn this code snippet, `createMiddleware()` is used to create a middleware that sets the 'X-Message' response header to 'Good morning!'. The `next()` function is called to pass control to the next middleware function in the stack.\n\n### Important Notes\n\n- The `next()` function is crucial as it passes control to the next middleware function. If it is not called, the request will hang.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/middleware/)\n\n### Common Use Cases\n\n- Setting response headers\n- Logging requests\n- Authenticating users",
      "ruleTitle": "Creating Custom Middleware in Hono",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to create and use middleware in Hono to set custom response headers. Middleware functions are a fundamental part of any Hono application as they have access to the request and response objects, and the next middleware function in the applicationâ€™s request-response cycle. This pattern allows developers to encapsulate logic that manipulates the response object in a reusable function.",
      "ruleFile": "## Creating and Using Middleware in Hono\n\nIn Hono, middleware functions are used to perform operations on the request and response objects. They are functions that have access to the `context` object and the `next` middleware function in the applicationâ€™s request-response cycle.\n\nThe following code snippet demonstrates how to create a middleware function that sets a custom response header. This middleware function can be reused across different routes or for all routes.\n\n```ts\nconst messageMiddleware = (message: string) => {\n  return createMiddleware(async (c, next) => {\n    await next()\n    c.res.headers.set('X-Message', message)\n  })\n}\n\napp.use(messageMiddleware('Good evening!'))\n```\n\nIn this code:\n\n1. A middleware function `messageMiddleware` is created. This function takes a string `message` as an argument and returns another function that is the actual middleware.\n2. The returned middleware function takes `context` and `next` as arguments. `context` is the context object that encapsulates a request and a response. `next` is a function that, when called, passes control to the next middleware function.\n3. The middleware function sets a custom response header 'X-Message' with the value of `message`.\n4. The middleware function is then used in the application with `app.use()`. This applies the middleware to all routes.\n\nThis pattern is useful when you need to perform the same operation for multiple or all routes, such as setting custom headers, logging, or error handling.",
      "ruleTitle": "Creating and Using Middleware to Set Custom Response Headers in Hono",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the factory module in Hono to create middleware and handlers. It also shows how to use these created elements in an application. This pattern is crucial for organizing code in a modular way, allowing for better maintainability and scalability.",
      "ruleFile": "# Using Factory Module in Hono\n\nThis code demonstrates how to use the factory module in Hono to create middleware and handlers, and how to use them in an application.\n\n```ts\nimport { createFactory } from 'hono/factory'\nimport { logger } from 'hono/logger'\n\n// ...\n\nconst factory = createFactory()\n\nconst middleware = factory.createMiddleware(async (c, next) => {\n  c.set('foo', 'bar')\n  await next()\n})\n\nconst handlers = factory.createHandlers(logger(), middleware, (c) => {\n  return c.json(c.var.foo)\n})\n\napp.get('/api', ...handlers)\n```\n\n## How it works\n\n1. Import the necessary modules from Hono.\n2. Create a factory instance using `createFactory()`.\n3. Use the factory instance to create middleware using `createMiddleware()`. This middleware sets a variable 'foo' to 'bar'.\n4. Use the factory instance to create handlers using `createHandlers()`. These handlers return a JSON response with the value of 'foo'.\n5. Use the created handlers in the application's route.\n\n## Important notes\n\n- The factory module in Hono helps to organize code in a modular way.\n- Middleware and handlers created using the factory can be used across different parts of the application.\n\n## References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n## Common use cases\n\n- Creating reusable middleware and handlers for an application.",
      "ruleTitle": "Creating Middleware and Handlers using Factory in Hono",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to avoid redundancy in the definition of the `Env` type in Hono framework. It shows how to use `createFactory()` and `createApp()` to set the `Env` only in one place, instead of setting it in two places when using `new Hono()` and `createMiddleware()`. This leads to cleaner and more maintainable code.",
      "ruleFile": "## Avoid Redundancy in `Env` Type Definition\n\nIn Hono framework, you might need to set the `Env` type in two places when using `new Hono()` and `createMiddleware()`. This can lead to redundancy and potential errors if the `Env` type changes.\n\nHere is an example of this scenario:\n\n```ts\nimport { createMiddleware } from 'hono/factory'\n\ntype Env = {\n  Variables: {\n    myVar: string\n  }\n}\n\n// 1. Set the `Env` to `new Hono()`\nconst app = new Hono<Env>()\n\n// 2. Set the `Env` to `createMiddleware()`\nconst mw = createMiddleware<Env>(async (c, next) => {\n  await next()\n})\n\napp.use(mw)\n```\n\nTo avoid this redundancy, you can use `createFactory()` and `createApp()` to set the `Env` only in one place. This leads to cleaner and more maintainable code.\n\n## References\n\n- [Hono Documentation](https://hono.bike/#/)\n\n## Common Use Cases\n\nThis pattern is commonly used when you have a complex `Env` type that is used in multiple places in your Hono application.",
      "ruleTitle": "Avoiding Redundancy in `Env` Type Definition in Hono",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `createFactory()` and `createApp()` methods in Hono to set the `Env` in one place. This is a best practice in Hono framework usage as it promotes code reusability and maintainability.",
      "ruleFile": "## Using `createFactory()` and `createApp()` in Hono\n\nThis code snippet demonstrates how to use the `createFactory()` and `createApp()` methods in Hono to set the `Env` in one place.\n\n```ts\nimport { createFactory } from 'hono/factory'\n\n// ...\n\n// Set the `Env` to `createFactory()`\nconst factory = createFactory<Env>()\n\nconst app = factory.createApp()\n\n// factory also has `createMiddleware()`\nconst mw = factory.createMiddleware(async (c, next) => {\n  await next()\n})\n```\n\n### How it works\n\n1. Import the `createFactory` function from the 'hono/factory' module.\n2. Set the `Env` to `createFactory()`.\n3. Use the `createApp()` method of the factory to create an app.\n4. Use the `createMiddleware()` method of the factory to create a middleware.\n\n### Important notes\n\n- `createFactory()` can receive the `initApp` option to initialize an `app` created by `createApp()`.\n\n### References\n\n- [Hono Documentation](https://hono.bayrell.org/en/)\n\n### Common use cases\n\n- When you want to set the `Env` in one place for better code reusability and maintainability.",
      "ruleTitle": "Using `createFactory()` and `createApp()` to Set `Env` in One Place in Hono",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to initialize an application with a database using the `initApp` option in the `createFactory` function. This is a common pattern in Hono framework to set up middleware for the application, in this case, setting up a database connection.",
      "ruleFile": "## Initializing an Application with a Database in Hono Framework\n\nThe following code snippet demonstrates how to initialize an application with a database using the `initApp` option in the `createFactory` function in Hono framework.\n\n```ts\n// factory-with-db.ts\ntype Env = {\n  Bindings: {\n    MY_DB: D1Database\n  }\n  Variables: {\n    db: DrizzleD1Database\n  }\n}\n\nexport default createFactory<Env>({ \n  initApp: (app) => {\n    app.use(async (c, next) => {\n      const db = drizzle(c.env.MY_DB)\n      c.set('db', db)\n      await next()\n    })\n  },\n})\n```\n\n### How it works\n\nIn the `createFactory` function, the `initApp` option is used to initialize the application. A middleware is set up using the `app.use` function. This middleware creates a database connection using the `drizzle` function and the `MY_DB` binding from the environment. The database connection is then set in the context using the `c.set` function.\n\n### Important notes\n\n- The `initApp` option is a common way to set up middleware in Hono framework.\n- The `drizzle` function is used to create a database connection.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Setting up a database connection for an application.\n- Initializing an application with other types of middleware.",
      "ruleTitle": "Initializing an Application with a Database in Hono Framework",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use a factory function to initialize an application with a database connection in the Hono framework. It shows how to use middleware to set up a database connection and how to access this connection in a route handler.",
      "ruleFile": "## Using a Factory Function to Initialize a Database Connection in Hono\n\nThis code snippet demonstrates how to use a factory function to initialize an application with a database connection in the Hono framework.\n\n```ts\nexport default createFactory<Env>({ \n  initApp: (app) => { \n    app.use(async (c, next) => { \n      const db = drizzle(c.env.MY_DB) \n      c.set('db', db) \n      await next() \n    }) \n  }, \n})\n```\n\nAnd accessing the database connection in a route handler:\n\n```ts\n// crud.ts\nimport factoryWithDB from './factory-with-db'\n\nconst app = factoryWithDB.createApp()\n\napp.post('/posts', (c) => { \n  c.var.db.insert() \n  // ...\n})\n```\n\n### How it works\n\n1. The `createFactory` function is used to create a factory for the application. This factory includes an `initApp` function that sets up a middleware to create a database connection using the `drizzle` function and the `MY_DB` environment variable.\n2. The middleware sets the database connection on the context object (`c`) using the `set` method.\n3. In the route handler, the database connection is accessed from the context object and used to perform a database operation.\n\n### Important notes\n\n- The `drizzle` function and the `MY_DB` environment variable are placeholders and should be replaced with actual database connection logic and configuration.\n- The `set` method is used to set the database connection on the context object, and the `var` property is used to access it.\n\n### References\n\n- [Hono documentation](https://hono.boutique/docs/)\n\n### Common use cases\n\n- Initializing a database connection when starting an application\n- Accessing a database connection in route handlers",
      "ruleTitle": "Initializing and Accessing a Database Connection in Hono",
      "sourcePath": "docs/helpers/factory.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important because it demonstrates how to import and use the Adapter Helper from the Hono framework. The Adapter Helper provides a unified interface to interact with various platforms, which is crucial for building scalable and maintainable applications. The `env()` function and `getRuntimeKey()` function are particularly useful for retrieving environment variables across different runtimes.",
      "ruleFile": "## Importing and Using the Adapter Helper in Hono\n\nThis code snippet demonstrates how to import and use the Adapter Helper from the Hono framework.\n\n```ts\nimport { Hono } from 'hono'\nimport { env, getRuntimeKey } from 'hono/adapter'\n```\n\n### How it works\n\n1. The `Hono` object is imported from the 'hono' package.\n2. The `env` and `getRuntimeKey` functions are imported from the 'hono/adapter' module.\n\n### Important notes\n\n- The `env()` function is used to retrieve environment variables across different runtimes.\n- The `getRuntimeKey()` function is used to get the runtime key for the current environment.\n\n### References\n\n- [Hono Documentation](https://hono.bryntum.com/docs)\n\n### Common use cases\n\n- Retrieving environment variables in a unified way across different platforms.\n- Getting the runtime key for the current environment.",
      "ruleTitle": "Importing and Using the Adapter Helper in Hono",
      "sourcePath": "docs/helpers/adapter.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to retrieve environment variables in different runtimes using Hono's 'env' function from the 'adapter' module. It shows how to access environment variables in a unified way across different platforms, which is crucial for building scalable and portable applications.",
      "ruleFile": "## Retrieving Environment Variables in Different Runtimes with Hono\n\nThis code snippet demonstrates how to retrieve environment variables across different runtimes using Hono's 'env' function from the 'adapter' module.\n\n```ts\nimport { env } from 'hono/adapter'\n\napp.get('/env', (c) => {\n  // NAME is process.env.NAME on Node.js or Bun\n  // NAME is the value written in `wrangler.toml` on Cloudflare\n  const { NAME } = env<{ NAME: string }>(c)\n  return c.text(NAME)\n})\n```\n\n### How it works\n\nThe 'env' function retrieves the value of the environment variable 'NAME'. The value that can be retrieved may be different for each runtime. For example, in Node.js or Bun, 'NAME' is process.env.NAME, while in Cloudflare, 'NAME' is the value written in `wrangler.toml`.\n\n### Important notes\n\n- The 'env' function supports different runtimes, serverless platforms, and cloud services, including Cloudflare Workers and Deno.\n\n### References\n\n- [Deno.env](https://docs.deno.com/runtime/manual/basics/env_va)\n\n### Common use cases\n\n- Retrieving environment variables in a unified way across different platforms\n- Building scalable and portable applications",
      "ruleTitle": "Retrieving Environment Variables in Different Runtimes with Hono",
      "sourcePath": "docs/helpers/adapter.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to retrieve environment variables in the Hono framework by specifying the runtime key. Understanding this is crucial for managing user-defined data and configuring the application based on the runtime environment.",
      "ruleFile": "## Retrieve Environment Variables in Hono\n\nThis code snippet demonstrates how to retrieve environment variables in the Hono framework by passing the runtime key as the second argument.\n\n```ts\napp.get('/env', (c) => {\n  const { NAME } = env<{ NAME: string }>(c, 'workerd')\n  return c.text(NAME)\n})\n```\n\n### How it works\n\nIn the code snippet, `env<{ NAME: string }>(c, 'workerd')` is used to get the environment variable `NAME` for the 'workerd' runtime. The `env` function takes two arguments: the context `c` and the runtime key 'workerd'.\n\n### Important notes\n\n- The `env` function is used to manage user-defined data in Hono.\n- The runtime key must be specified correctly to retrieve the appropriate environment variables.\n\n### References\n\n- [Hono Documentation](https://hono.bevry.me/)\n\n### Common use cases\n\n- Configuring the application based on the runtime environment\n- Managing user-defined data",
      "ruleTitle": "Retrieving Environment Variables in Hono",
      "sourcePath": "docs/helpers/adapter.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `getRuntimeKey()` function in Hono to identify the current runtime environment. This can be useful in scenarios where the application behavior needs to be adjusted based on the runtime environment.",
      "ruleFile": "## Using `getRuntimeKey()` to Identify Runtime Environment\n\nThe `getRuntimeKey()` function in Hono is used to identify the current runtime environment. This can be useful when the application behavior needs to be adjusted based on the runtime environment.\n\nHere is a code snippet demonstrating its usage:\n\n```ts\napp.get('/', (c) => {\n  if (getRuntimeKey() === 'workerd') {\n    return c.text('You are on Cloudflare')\n  } else if (getRuntimeKey() === 'bun') {\n    return c.text('You are on Bun')\n  }\n  ...\n})\n```\n\nIn this snippet, the `getRuntimeKey()` function is used to check if the current runtime environment is 'workerd' or 'bun'. Depending on the result, a different response is returned.\n\n### Important Notes\n\n- The `getRuntimeKey()` function returns a string that represents the current runtime environment.\n- The returned value can be 'workerd', 'bun', or any other string representing a supported runtime environment.\n\n### Common Use Cases\n\n- Adjusting application behavior based on the runtime environment.\n- Debugging issues that occur only in specific runtime environments.",
      "ruleTitle": "Using `getRuntimeKey()` to Identify Runtime Environment in Hono",
      "sourcePath": "docs/helpers/adapter.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to import and use the proxy helper from the Hono framework. The proxy helper provides useful functions when using a Hono application as a (reverse) proxy. Understanding how to correctly import and use this helper is crucial for developers working with Hono.",
      "ruleFile": "# Importing and Using Proxy Helper in Hono\n\nThis guide demonstrates how to import and use the proxy helper from the Hono framework.\n\n## Code Snippet\n\n```ts\nimport { Hono } from 'hono'\nimport { proxy } from 'hono/proxy'\n```\n\n## How it Works\n\nThe above code imports the Hono framework and the proxy helper from it. The proxy helper provides a `fetch()` API wrapper for proxy. The parameters and return value are the same as for `fetch()` (except for the proxy-specific options).\n\n## Important Notes\n\n- The `proxy()` function is a `fetch()` API wrapper for proxy.\n- The parameters and return value are the same as for `fetch()` (except for the proxy-specific options).\n\n## References\n\n- [Hono Documentation](https://hono.bosch.io/docs/)\n\n## Common Use Cases\n\n- Using a Hono application as a (reverse) proxy.",
      "ruleTitle": "Importing and Using Proxy Helper in Hono",
      "sourcePath": "docs/helpers/proxy.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the proxy function in Hono to handle requests and redirect them to another server. This is a common use case in many applications where you need to proxy requests to different services.",
      "ruleFile": "## Proxying Requests in Hono\n\nThis code demonstrates how to use the proxy function in Hono to handle requests and redirect them to another server.\n\n```ts\napp.get('/proxy/:path', (c) => {\n  return proxy(`http://${originServer}/${c.req.param('path')}`)\n})\n```\n\n### How it works\n\nThe `app.get` function is used to handle GET requests to the '/proxy/:path' endpoint. The `:path` is a parameter that will be replaced by the actual path in the request. The `proxy` function is then used to create a new request to the `originServer` with the same path as the original request.\n\n### Important notes\n\n- The `originServer` variable should be the URL of the server you want to proxy the requests to.\n- The `c.req.param('path')` function is used to get the path parameter from the request.\n\n### References\n\n- [Hono Documentation](https://hono.bike/#/)\n\n### Common use cases\n\n- Proxying requests to different services in a microservices architecture.\n- Redirecting requests to a different domain.",
      "ruleTitle": "Proxying Requests in Hono",
      "sourcePath": "docs/helpers/proxy.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the proxy helper in Hono to forward requests to another server. It shows how to handle headers, including how to forward all request data, how to set specific headers, and how to prevent certain headers from being propagated. It also shows how to delete a response header before returning the response.",
      "ruleFile": "## Proxy Helper Usage in Hono\n\nThis code snippet demonstrates how to use the proxy helper in Hono to forward requests to another server. It also shows how to handle headers, including how to forward all request data, how to set specific headers, and how to prevent certain headers from being propagated. Finally, it shows how to delete a response header before returning the response.\n\n```ts\napp.get('/proxy/:path', async (c) => {\n  const res = await proxy(\n    `http://${originServer}/${c.req.param('path')}',\n    {\n      headers: {\n        ...c.req.header(), // optional, specify only when forwarding all the request data (including credentials) is necessary.\n        'X-Forwarded-For': '127.0.0.1',\n        'X-Forwarded-Host': c.req.header('host'),\n        Authorization: undefined, // do not propagate request headers contained in c.req.header('Authorization')\n      },\n    }\n  )\n  res.headers.delete('Set-Cookie')\n  return res\n})\n```\n\n### How it works\n\nThe proxy helper is used to forward the request to another server. The path to the other server is specified in the first argument to the proxy function. The second argument is an options object, where you can specify headers to be included in the forwarded request. You can forward all request data by spreading `c.req.header()`, set specific headers, or prevent certain headers from being propagated by setting them to `undefined`. After the request is forwarded and the response is received, you can manipulate the response headers before returning the response.\n\n### Important notes\n\n- Be careful when forwarding all request data, as it might include sensitive information like credentials.\n- When setting the 'X-Forwarded-For' and 'X-Forwarded-Host' headers, make sure to use the correct values.\n- Deleting a response header might affect the behavior of the client that receives the response.\n\n### References\n\n- [Hono documentation](https://hono.beebotte.com/docs)\n\n### Common use cases\n\n- Forwarding requests to another server in a microservices architecture.\n- Implementing a reverse proxy.",
      "ruleTitle": "Using the Proxy Helper in Hono",
      "sourcePath": "docs/helpers/proxy.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use a proxy in Hono to forward requests to another server, while also showing how to manipulate the headers of the request. This is particularly useful when you want to hide sensitive information like 'Authorization' from being propagated.",
      "ruleFile": "## Proxying Requests in Hono\n\nThis code snippet demonstrates how to use a proxy in Hono to forward requests to another server. It also shows how to manipulate the headers of the request to prevent sensitive information from being propagated.\n\n```ts\napp.all('/proxy/:path', (c) => {\n  return proxy(`http://${originServer}/${c.req.param('path')}`, {\n    ...c.req, // optional, specify only when forwarding all the request data (including credentials) is necessary.\n    headers: {\n      ...c.req.header(),\n      'X-Forwarded-For': '127.0.0.1',\n      'X-Forwarded-Host': c.req.header('host'),\n      Authorization: undefined, // do not propagate request headers contained in c.req.header('Authorization')\n    },\n  })\n})\n```\n\n### How it works\n\nThe `app.all` method is used to handle all types of HTTP requests. The `proxy` function is used to forward the request to another server. The headers of the request are manipulated by spreading the existing headers and then overriding the 'Authorization' header with `undefined` to prevent it from being propagated.\n\n### Important notes\n\n- Be careful when manipulating headers as it can lead to unexpected behavior.\n\n### References\n\n- [Hono documentation](https://hono.bike/)\n\n### Common use cases\n\n- Forwarding requests to another server while hiding sensitive information.",
      "ruleTitle": "Proxying Requests and Manipulating Headers in Hono",
      "sourcePath": "docs/helpers/proxy.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to define interfaces for a ProxyFetch function in Hono. It shows how to extend the RequestInit interface while omitting the 'headers' property and how to define the ProxyFetch function that takes an input and an optional ProxyRequestInit object and returns a Promise of type Response.",
      "ruleFile": "## ProxyFetch Interface Definition in Hono\n\nThis code snippet demonstrates how to define interfaces for a ProxyFetch function in Hono.\n\n```ts\ninterface ProxyRequestInit extends Omit<RequestInit, 'headers'> {\n  raw?: Request\n  headers?:\n    | HeadersInit\n    | [string, string][]\n    | Record<RequestHeader, string | undefined>\n    | Record<string, string | undefined>\n}\n\ninterface ProxyFetch {\n  (\n    input: string | URL | Request,\n    init?: ProxyRequestInit\n  ): Promise<Response>\n}\n```\n\n### How it works\n\nThe `ProxyRequestInit` interface extends the `RequestInit` interface but omits the 'headers' property. It defines two optional properties: 'raw' of type Request and 'headers' which can be of type HeadersInit, an array of string pairs, or a Record of RequestHeader or string to string or undefined.\n\nThe `ProxyFetch` interface defines a function that takes an input of type string, URL, or Request and an optional `ProxyRequestInit` object and returns a Promise of type Response.\n\n### Important notes\n\n- The 'headers' property is omitted from the `RequestInit` interface to allow for custom header definitions.\n\n### References\n\n- [Hono Documentation](https://hono.bike/docs/)\n\n### Common use cases\n\n- Defining a ProxyFetch function in Hono to handle HTTP requests.",
      "ruleTitle": "Defining ProxyFetch Interface in Hono",
      "sourcePath": "docs/helpers/proxy.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `html` helper in Hono to write HTML in JavaScript template literals. It also shows how to use the `raw()` function to render content as is, which is crucial when dealing with user-generated content or any content that needs to be rendered exactly as it is without any modifications.",
      "ruleFile": "## Using the `html` Helper in Hono\n\nThe `html` helper in Hono allows you to write HTML in JavaScript template literals. This is particularly useful when you need to generate dynamic HTML content based on some variables.\n\nHere is a code snippet demonstrating its usage:\n\n```ts\nimport { Hono } from 'hono'\nimport { html, raw } from 'hono/html'\n\nconst app = new Hono()\n\napp.get('/:username', (c) => {\n  const { username } = c.req.param()\n  return c.html(\n    html`<!doctype html>\n      <h1>Hello! ${username}!</h1>`\n  )\n})\n```\n\nIn this example, the `html` helper is used to generate a simple HTML document with a greeting message that includes the username passed in the URL.\n\nThe `raw()` function can be used to render content as is. This is useful when dealing with user-generated content or any content that needs to be rendered exactly as it is without any modifications. However, you need to be careful with this function as it does not escape the content, so you have to escape these strings by yourself to prevent any potential security issues.\n\n### References\n\n- [Hono Documentation](https://hono.bike/#/)\n\n### Common Use Cases\n\n- Generating dynamic HTML content based on some variables\n- Rendering user-generated content or any content that needs to be rendered exactly as it is",
      "ruleTitle": "Using the `html` Helper in Hono",
      "sourcePath": "docs/helpers/html.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'html' helper function in Hono to generate HTML content dynamically. It shows how to insert dynamic content into HTML templates, which is a common requirement in web development.",
      "ruleFile": "## Rule\n\nThis rule demonstrates how to use the 'html' helper function in Hono to generate HTML content dynamically. The 'html' function allows you to insert dynamic content into HTML templates.\n\n## Code Snippet\n\n```ts\nconst app = new Hono()\n\napp.get('/:username', (c) => {\n  const { username } = c.req.param()\n  return c.html(\n    html`<!doctype html>\n      <h1>Hello! ${username}!</h1>`\n  )\n})\n```\n\n## How it Works\n\nIn the code snippet, a new Hono application is created. A route handler is defined for the path '/:username'. In the route handler, the 'username' parameter is extracted from the request parameters. The 'html' function is then used to generate an HTML response that includes the 'username' parameter.\n\n## Important Notes\n\nThe 'html' function allows you to insert dynamic content into HTML templates. However, it does not automatically escape the content. You need to ensure that the content is properly escaped to prevent cross-site scripting (XSS) attacks.\n\n## References\n\n- [Hono Documentation](https://hono.bike/#/)\n\n## Common Use Cases\n\nThe 'html' function is commonly used in web development to generate dynamic HTML content. For example, it can be used to personalize web pages based on user input or to display data from a database.",
      "ruleTitle": "Using the 'html' Helper Function in Hono to Generate Dynamic HTML Content",
      "sourcePath": "docs/helpers/html.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use Hono's `html` helper to insert inline scripts into JSX and how it can act as a functional component. It shows how to avoid using `dangerouslySetInnerHTML` by writing scripts directly into the JSX, which will not be escaped. It also highlights the performance benefits of using `html` over `memo`.",
      "ruleFile": "## Using Hono's `html` Helper for Inline Scripts and Functional Components\n\nThis code snippet demonstrates how to use Hono's `html` helper to insert inline scripts into JSX and how it can act as a functional component.\n\n```tsx\napp.get('/', (c) => {\n  return c.html(\n    <html>\n      <head>\n        <title>Test Site</title>\n        {html`\n          <script>\n            // No need to use dangerouslySetInnerHTML.\n            // If you write it here, it will not be escaped.\n          </script>\n        `}\n      </head>\n      <body>Hello!</body>\n    </html>\n  )\n})\n```\n\n### How it works\n\nThe `html` helper allows you to insert inline scripts directly into your JSX. This means you can avoid using `dangerouslySetInnerHTML` and the potential security risks it carries. The scripts you write will not be escaped.\n\n### Important notes\n\nSince `html` returns an HtmlEscapedString, it can act as a fully functional component without using JSX. This can be a performance benefit as it can be faster than using `memo`.\n\n### References\n\n- [Hono Documentation](https://hono.dev/docs)\n\n### Common use cases\n\n- When you need to insert inline scripts into your JSX\n- When you want to use a functional component without using JSX",
      "ruleTitle": "Using Hono's `html` Helper for Inline Scripts and Functional Components",
      "sourcePath": "docs/helpers/html.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `html` helper function in Hono to create a functional component. This is a key aspect of Hono, as it allows for the creation of reusable components without the need for JSX. The rule also shows how to embed HTML directly into the component, which can be a more efficient way of creating components in certain situations.",
      "ruleFile": "## Using `html` helper function to create functional components in Hono\n\nIn Hono, the `html` helper function can be used to create fully functional components without the need for JSX. This function returns an HtmlEscapedString, which can be embedded directly into the component. This can be a more efficient way of creating components in certain situations.\n\nHere is an example of how to use the `html` function to create a functional component:\n\n```typescript\nconst Footer = () => html`\n  <footer>\n    <address>My Address...</address>\n  </footer>\n`\n```\n\nIn this example, the `html` function is used to create a `Footer` component. The HTML for the footer is embedded directly into the component using the `html` function.\n\n### Important notes\n\n- The `html` function returns an HtmlEscapedString, which can be embedded directly into the component.\n- This approach can be more efficient than using JSX in certain situations.\n\n### References\n\n- [Hono documentation](https://hono.bayfront.io/)\n\n### Common use cases\n\n- Creating reusable components without the need for JSX.\n- Embedding HTML directly into components for efficiency.",
      "ruleTitle": "Creating Functional Components with `html` Helper Function in Hono",
      "sourcePath": "docs/helpers/html.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the `html` helper in Hono to create HTML templates with embedded values. It shows how to define a layout with props and how to pass these props to the layout. It also shows how to use the `html` helper to return HTML from a route handler. This is a common pattern in Hono and understanding it can help in creating dynamic web pages efficiently.",
      "ruleFile": "## Using `html` Helper in Hono to Create HTML Templates with Embedded Values\n\nThe following code snippet demonstrates how to use the `html` helper in Hono to create HTML templates with embedded values. It defines a layout with props and passes these props to the layout. It also uses the `html` helper to return HTML from a route handler.\n\n```typescript\ninterface SiteData {\n  title: string\n  description: string\n  image: string\n  children?: any\n}\nconst Layout = (props: SiteData) => html`\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>${props.title}</title>\n  <meta name=\"description\" content=\"${props.description}\">\n  <head prefix=\"og: http://ogp.me/ns#\">\n  <meta property=\"og:type\" content=\"article\">\n  <!-- More elements slow down JSX, but not template literals. -->\n  <meta property=\"og:title\" content=\"${props.title}\">\n  <meta property=\"og:image\" content=\"${props.image}\">\n</head>\n<body>\n  ${props.children}\n</body>\n</html>\n`\n\nconst Content = (props: { siteData: SiteData; name: string }) => (\n  <Layout {...props.siteData}>\n    <h1>Hello {props.name}</h1>\n  </Layout>\n)\n\napp.get('/', (c) => {\n  const props = {\n    name: 'World',\n    siteData: {\n      title: 'Hello <> World',\n      description: 'This is a description',\n      image: 'https://example.com/image.png',\n    },\n  }\n  return c.html(<Content {...props} />)\n})\n```\n\n### How it works\n\n1. A `SiteData` interface is defined to type the props.\n2. A `Layout` component is defined using the `html` helper. It takes a `SiteData` object as props and embeds the values in the HTML template.\n3. A `Content` component is defined that takes a `SiteData` object and a `name` as props. It passes the `SiteData` to the `Layout` and embeds the `name` in a `<h1>` tag.\n4. In the route handler for '/', an object with the `SiteData` and `name` is created and passed to the `Content` component. The `html` helper is used to return the resulting HTML.\n\n### Important notes\n\n- The `html` helper allows for efficient creation of HTML templates with embedded values.\n- More elements slow down JSX, but not template literals.\n\n### References\n\n- [Hono Documentation](https://hono.boutell.com/)\n\n### Common use cases\n\n- Creating dynamic web pages with embedded values.\n- Returning HTML from route handlers.",
      "ruleTitle": "Using `html` Helper in Hono to Create HTML Templates with Embedded Values",
      "sourcePath": "docs/helpers/html.md",
      "category": "helpers"
    },
    {
      "reasoning": "This rule is important as it demonstrates how to use the 'raw()' function in Hono to prevent HTML encoding of a string. This is useful when you want to include special characters in your string without them being converted into their HTML encoded equivalents.",
      "ruleFile": "## Using the 'raw()' function in Hono\n\nThis code snippet demonstrates how to use the 'raw()' function in Hono to prevent HTML encoding of a string.\n\n```ts\napp.get('/', (c) => {\n  const name = 'John &quot;Johnny&quot; Smith'\n  return c.html(html`<p>I'm ${raw(name)}.</p>`)\n})\n```\n\nIn this example, the string 'John &quot;Johnny&quot; Smith' is passed to the 'raw()' function. This prevents the HTML encoding of the string when it is included in the HTML template literal.\n\n### Important Notes\n\n- The 'raw()' function should be used with caution as it can potentially introduce security vulnerabilities if user-supplied input is not properly sanitized.\n\n### References\n\n- Hono documentation: <https://hono.boutique/>\n\n### Common Use Cases\n\n- When you want to include special characters in your string without them being converted into their HTML encoded equivalents.",
      "ruleTitle": "Using the 'raw()' Function in Hono to Prevent HTML Encoding",
      "sourcePath": "docs/helpers/html.md",
      "category": "helpers"
    }
  ]
}
