# Drizzle SQLite Rules - 4/1/2025, 4:47:28 PM

## Customizing Integer Columns in SQLite with Drizzle ORM

This rule demonstrates how to create and customize integer columns in SQLite tables using the Drizzle ORM. By leveraging different modes, it is possible to store various types of data like numbers, booleans, and timestamps.

- `sqliteTable('table', {...})`: Defines a table named 'table' with specified columns.
- `integer()`: Creates an integer column by default.
- `integer({ mode: 'number' })`: Initializes the column in number mode, storing typical numeric values.
- `integer({ mode: 'boolean' })`: Initializes the column in boolean mode, allowing true/false values.
- `integer({ mode: 'timestamp_ms' })`: Sets the column to interpret values as timestamps in milliseconds.
- `integer({ mode: 'timestamp' })`: Allows the column to store Date objects directly.

- Ensure that the appropriate mode is selected based on the use case to prevent data misinterpretation.
- Consider potential performance implications when working with timestamp modes.

- [Drizzle ORM Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- Storing user IDs or order numbers using `mode: 'number'`.
- Saving settings or flags in `mode: 'boolean'`.
- Logging timestamps for events with `mode: 'timestamp_ms'`.
- Tracking created or updated times directly using Date objects in `mode: 'timestamp'`.

## Code Snippet

```typescript
import { integer, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
  id: integer()
});

// you can customize integer mode to be number, boolean, timestamp, timestamp_ms
integer({ mode: 'number' })
integer({ mode: 'boolean' })
integer({ mode: 'timestamp_ms' })
integer({ mode: 'timestamp' }) // Date
```

**Reasoning:** This rule is important because it demonstrates how to define and customize integer columns in a SQLite table using the Drizzle ORM. This flexibility allows developers to handle different data types and operations efficiently, ensuring compatibility and optimal performance in SQLite databases.

## Defining an Integer Column in SQLite

This code snippet demonstrates how to define a basic table in SQLite with an integer column. Using integer columns is essential for storing numerical data, such as identifiers or counters.

- **CREATE TABLE**: This command creates a new table in the database.
- **`id`**: This is the name of the column.
- **integer**: This is the data type of the column, specifically for storing whole numbers.

- SQLite uses dynamic typing, so `integer` can store values as small as 1-byte integers up to 8-byte integers, depending on the value.
- It's important to define primary keys using integer types to leverage SQLite's auto-increment capability, though `PRIMARY KEY AUTOINCREMENT` is not shown here.

- [SQLite Data Types Documentation](https://www.sqlite.org/datatype3.html)

1. Defining unique identifiers for each record in a table.
2. Storing numerical data such as counters or sequential numbers.

- You can specify an `INTEGER PRIMARY KEY` to automatically increment the `id`.

## Code Snippet

```typescript
CREATE TABLE `table` (
  `id` integer
);
```

**Reasoning:** This rule is important because it demonstrates how to define an integer column in an SQLite database table. Understanding column types and their declarations is crucial for designing efficient and correct database schemas.

## Auto-incrementing Integer Primary Key in SQLite

This code snippet illustrates how to create an integer primary key in SQLite that auto-increments. This is a common pattern for generating unique identifiers for database records automatically.

- `integer({ mode: 'number' })`: Initializes an integer column with number mode.
- `.primaryKey({ autoIncrement: true })`: Sets the column as a primary key and enables auto-increment, allowing SQLite to automatically generate a unique incremental integer for each new row.

- Auto-increment primary keys are suited for ensuring each row has a unique identifier which is generally used as a reference in other tables.
- In SQLite, `INTEGER PRIMARY KEY` is a special alias for the rowid, and using `autoIncrement` ensures that this value is automatically incremented with each inserted row.

- [SQLite ROWID](https://www.sqlite.org/lang_createtable.html#rowid)
- [Primary Keys](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- Automatically generating unique identifiers for rows in a user database.
- Maintaining consistent and unique references in tables that are frequently queried or joined.

- Creating a composite key with an additional column if more complexity is needed in unique identification.

## Code Snippet

```typescript
// to make integer primary key auto increment
integer({ mode: 'number' }).primaryKey({ autoIncrement: true })
```

**Reasoning:** This rule is important as it demonstrates how to define an auto-incrementing integer primary key in SQLite using Drizzle's TypeScript syntax. This pattern is essential for creating unique identifiers for records in a database table, which is a common necessity in database management.

## Defining SQLite REAL Column Types with Drizzle ORM

This rule demonstrates how to define and use a REAL column type in an SQLite table using the Drizzle ORM. It is essential to understand how to work with various data types in SQLite to leverage the full potential of the database while maintaining type safety and clarity in TypeScript.

- **Import Statements**: The code starts by importing the `real` function and `sqliteTable` from the Drizzle ORM SQLite core package.
- **Table Definition**: A table is defined with the `sqliteTable()` function, which takes the table name ('table') and an object defining the schema. The `real()` function specifies that the column named 'real' should have the SQLite REAL data type, which is used to store floating-point numbers.

- **Precision**: REAL types store floating point numbers, which might cause precision issues in certain calculations.
- **Compatibility**: Always ensure compatibility with the SQLite database version being used, as behavior may differ slightly with different versions.

- [Drizzle ORM SQLite Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)
- [SQLite Data Types](https://www.sqlite.org/datatype3.html)

- **Storing Decimal Numbers**: Use REAL for prices, measurements, or other decimal values where the precision offered by floating point numbers is sufficient.
- **Alternative Types**: For more precise numeric storage, consider using `integer` for whole numbers or `numeric` for fixed-point arithmetic.

## Code Snippet

```typescript
import { real, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
  real: real()
});
```

**Reasoning:** This rule is important because it demonstrates how to define a table with a REAL column type in SQLite using the Drizzle ORM. This is critical for developers who need to handle floating point numbers and integrations with databases using a type-safe approach.

## Defining a 'REAL' Column in SQLite

This rule demonstrates how to create a table in SQLite with a column of type `REAL`. This column type is used for storing floating-point numbers.

- The `CREATE TABLE` statement initializes a new table named `table`.
- The column `real` is defined with the `REAL` type, suitable for floating-point numbers.

- Use the `REAL` type when you need to store decimal numbers, but be aware of floating-point precision limitations.
- Avoid using `REAL` for data that requires exact precision, such as currency, which is better stored as `INTEGER` (e.g., storing cents instead of dollars).

- [SQLite Datatypes](https://www.sqlite.org/datatype3.html): This page explains the different column types available in SQLite and their usage.

- **Storing Measurements**: Use `REAL` for measurements where precision is less critical than range, e.g., temperatures, weights.
- **Scientific Data**: For scientific applications that deal with various scales and require the floating-point format.

Variations could include defining multiple `REAL` columns for different types of measurements or combining `REAL` with other types like `INTEGER` for IDs.

## Code Snippet

```typescript
CREATE TABLE `table` (
  `real` real
);
```

**Reasoning:** This rule demonstrates the creation of a table in SQLite using the 'REAL' column type. Understanding how to define column types is crucial for managing data with appropriate precision and performance.

## Defining SQLite Column Types with Drizzle ORM

This rule demonstrates how to use the Drizzle ORM library to define SQLite table columns with specific types and modifications. It shows how to set up columns with enumerated values and handle JSON data types effectively.

- **`sqliteTable`**: This function is used to create a table in SQLite, specifying the table name and its columns.
- **`text` Column**: The `text` function defines a column with the text data type. It can be customized using options like `enum` and `mode`.
  - **`enum` Option**: Restricts the column values to specific enumerated strings (e.g., "value1", "value2") and allows `null`.
  - **`mode: 'json'`**: Defines the column to store JSON data, enabling the storage of serialized objects in a text field.
  - **`$type<{ foo: string }>()`**: Specifies the TypeScript type for JSON data to ensure type safety when accessing JSON properties.

- Ensure that the database type supports all JSON functionalities when using `mode: 'json'`.
- Using the `enum` option helps prevent invalid data entry, enhancing data integrity.

- [Drizzle ORM SQLite Column Types Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- **Enumerated Text Column**: Useful for fields with a fixed set of possible values, like status or category.
- **JSON Text Column**: Ideal for storing configuration data or complex objects without needing a separate relational structure.

This pattern is especially beneficial when working with dynamic data structures or ensuring data integrity through type restrictions.

## Code Snippet

```typescript
import { text, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
  text: text()
});

// will be inferred as text: "value1" | "value2" | null
text({ enum: ["value1", "value2"] })
text({ mode: 'json' })
text({ mode: 'json' }).$type<{ foo: string }>()
```

**Reasoning:** This rule highlights the use of the Drizzle ORM library for creating and managing SQLite tables with TypeScript. It showcases how to define a table with columns that have specified data types and customizations, such as enumerations and JSON mode. This rule is important for developers who want to leverage TypeScript's typing system for better type safety and readability in database operations with SQLite.

## Creating a Text Column in SQLite with Drizzle ORM

This rule demonstrates how to create a simple table in SQLite with a column of type `text`. The example uses Drizzle ORM syntax for defining the table structure.

The code snippet shows the creation of a database table named `table`, with a single column called `text`. The column is explicitly defined with the type `text`, which is suitable for storing string data in SQLite.

- The type `text` in SQLite is used to store character string data. It is important to select the appropriate data type for each column to ensure that the database behaves as expected and remains efficient.
- SQLite is case-insensitive when it comes to keyword recognition, but it is a good practice to use lowercase for consistency.
- The use of backticks to enclose table and column names is optional in SQLite but can help avoid conflicts with reserved keywords.

- [SQLite Data Types Documentation](https://www.sqlite.org/datatype3.html)
- [Drizzle ORM Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- Defining a text column for storing user-input data like names, comments, or descriptions.
- Using text types for search fields or storing JSON-serialized objects as strings.

- **Using Different Column Names:** You can replace `text` with any appropriate column name as needed.
- **Additional Columns:** Add more columns of different types to accommodate various data requirements such as integers or real numbers.

## Code Snippet

```typescript
CREATE TABLE `table` (
  `text` text
);
```

**Reasoning:** This rule demonstrates the fundamental process of creating a table with a text column in SQLite using the Drizzle ORM. Understanding how to define column types correctly is important for database integrity and optimized data storage.

## Handling Blob Columns in SQLite with Drizzle ORM

This code snippet demonstrates how to define blob columns in a SQLite database using Drizzle ORM. It shows various ways to configure blob columns, highlighting the flexibility offered by the library.

- **Definition of Blob Column**: The `blob()` function is used to create a blob column in a SQLite table.
- **Modes of Blob Storage**:
  - `blob()`: Default blob configuration.
  - `blob({ mode: 'buffer' })`: Stores the blob as a buffer.
  - `blob({ mode: 'bigint' })`: Assumes the blob data can be represented as a bigint.
  - `blob({ mode: 'json' })`: Interprets the blob data as JSON.
- **Custom Type Definition**: The `$type` method allows for specifying a custom TypeScript type for the JSON blob, enhancing type safety and readability.

- Ensure that the Drizzle ORM library is correctly installed and configured in your TypeScript project before using these features.
- Be aware of the database's storage limitations and performance considerations when using blobs, especially for large data.

- [Drizzle ORM SQLite Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)
- [Blob Data Type in SQLite](https://www.sqlite.org/datatype3.html)

- Storing binary files such as images or documents directly in the database.
- Encoding structured data as JSON for storage in a blob column.
- Applications requiring type-safe interactions with binary data through TypeScript.

By following this rule, developers can effectively leverage SQLite's support for binary data using Drizzle ORM, ensuring optimal application performance and maintainability.

## Code Snippet

```typescript
import { blob, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
  blob: blob()
});

blob()
blob({ mode: 'buffer' })
blob({ mode: 'bigint' })

blob({ mode: 'json' })
blob({ mode: 'json' }).$type<{ foo: string }>()
```

**Reasoning:** This rule is important because it demonstrates how to define and manipulate blob columns in a SQLite database using Drizzle ORM. Understanding the different modes of blob storage and how to define custom types is crucial for effectively using SQLite for a wide range of applications that require binary data handling.

## Defining and Using BLOB Data Types in SQLite

This rule demonstrates how to define a column of type BLOB in an SQLite database table. BLOB (Binary Large Object) is used to store binary data such as images, audio, or any other type of files.

The code snippet creates a table with a single column named `blob` of type BLOB. BLOB columns are designed to store large amounts of binary data. This is particularly useful when the data does not fit traditional textual data types.

- BLOB fields can store data up to 2GB in size, but the actual limit may depend on the SQLite implementation and configuration.
- Ensure that your application logic handles BLOB data efficiently to avoid memory issues.

- [SQLite Data Types](https://www.sqlite.org/datatype3.html)
- [Drizzle SQLite Column Types](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- Storing image files in a photo gallery app
- Saving serialized objects for caching complex data structures
- Storing audio files or other multimedia content

- Create a table with multiple BLOBs:

- Use alongside other data types:

## Code Snippet

```typescript
CREATE TABLE `table` (
  `blob` blob
);
```

**Reasoning:** This rule is important as it highlights the use of the BLOB data type in SQLite, showcasing how to store binary data like images or files efficiently within a database. Understanding this allows developers to manage and persist complex data structures directly in their SQL databases.

## Defining Boolean Columns in SQLite with Drizzle ORM

This rule demonstrates how to define a boolean column in an SQLite table using Drizzle ORM. SQLite does not support a native boolean type, so this pattern shows how to use integers to represent boolean values.

- **sqliteTable**: This function is used to define a new table within the SQLite database.
- **integer({ mode: 'boolean' })**: This configuration sets up an integer column that is used to store boolean values (commonly 0 for false and 1 for true).

- SQLite does not have a dedicated boolean type; using integers is a common workaround.
- Ensure consistency in how boolean values are stored across your database schema.

- [Drizzle ORM SQLite Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- Storing boolean flags or status indicators in a SQLite database.
- Representing yes/no or true/false states when dealing with SQLite tables.

Instead of directly using integers, another approach can be mapping strings 'true' and 'false' to integers when reading and writing from the database, though this is less efficient.

## Code Snippet

```typescript
import { integer, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
  id: integer({ mode: 'boolean' })
});
```

**Reasoning:** This rule demonstrates how to define a boolean column in an SQLite table using Drizzle ORM by specifying the integer type with a mode of 'boolean'. It showcases a method to handle boolean data types in SQLite, which natively does not have a dedicated boolean type.

## Handling BLOB Data Types with 'bigint' Mode in Drizzle ORM for SQLite

This rule demonstrates how to define a column using the `blob` type with a 'bigint' mode in a table managed by Drizzle ORM for SQLite databases. This setup is essential for efficiently handling binary data like images, documents, or large integers stored in binary format.

- **Import Statements**: The code imports the `blob` type and `sqliteTable` function from the `drizzle-orm/sqlite-core` package.
- **Table Definition**: The `sqliteTable` function is used to define a new table named `table`.
- **Column Definition**: The `id` column is defined as a `blob` with `{ mode: 'bigint' }`. This means that the column will store binary data intended to represent large integers.

- **BLOB Usage**: Using a BLOB is ideal for any binary data storage necessary for the application, such as storing images, files, or large integer values.
- **Performance Considerations**: Be aware of potential performance implications when storing large BLOBs, and ensure that your database and application architecture can handle such payloads efficiently.

- [SQLite Documentation on BLOBs](https://www.sqlite.org/datatype3.html)
- [Drizzle ORM SQLite Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- Storing large integer values as BLOBs when precision or size surpasses the capabilities of standard integer data types.
- Saving binary large objects such as images, audio files, or documents in a database table for easy retrieval and processing.

- Using other modes or configurations with BLOB data types to accommodate different binary storage needs, such as handling different file types or encryption requirements.

## Code Snippet

```typescript
import { blob, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
  id: blob({ mode: 'bigint' })
});
```

**Reasoning:** This rule demonstrates how to use the 'blob' data type with a 'bigint' mode in a Drizzle ORM SQLite setup. It highlights the flexibility of handling binary large objects within a database table, ensuring developers understand how to define and manipulate binary data effectively.

## Using BLOB Column Type in SQLite Tables

This rule demonstrates how to define a column using the `BLOB` type in SQLite. BLOB, which stands for Binary Large Object, is a versatile data type that allows for the storage of large binary data, such as images or multimedia files, directly in the database table.

- **Table Creation**: The snippet creates a table named `table` with a single column `id`.
- **Column Type**: The `id` column is defined with the `BLOB` data type, which is suitable for storing binary data.
- **Flexibility**: SQLite's dynamic typing system allows `BLOB` fields to store any type of data, making them useful for diverse applications.

- **Storage Considerations**: BLOBs can consume significant storage space, which might affect database performance if not managed properly.
- **Data Handling**: Careful handling of binary data is necessary to ensure data integrity and efficient retrieval.

- [SQLite Data Types](https://sqlite.org/datatype3.html) for a comprehensive overview of SQLite's data types.

- **Storing Images**: Use BLOBs for storing image files directly within a database.
- **Multimedia Storage**: Suitable for video or audio files that need to be stored along with other data in a database entry.
- **Document Archiving**: Ideal for applications that require the archiving of various types of documents.

Consider exploring variations, such as combining BLOB with other column types to handle complex data structures.

## Code Snippet

```typescript
CREATE TABLE `table` (
  `id` blob
);
```

**Reasoning:** This rule is important because it demonstrates the use of the `BLOB` type in SQLite, highlighting how SQLite's dynamic typing allows for flexible data storage. It showcases a fundamental understanding of how to define columns in SQLite tables and utilize compound data types.

## Defining Numeric Column Types in SQLite with Drizzle ORM

This document demonstrates how to define various numeric column types in a SQLite table using Drizzle ORM in a TypeScript environment.

This code snippet shows how to create a SQLite table with columns that use different numeric types controlled by Drizzle ORM. Here's a breakdown of the column definitions:

- `numeric`: Defaults to a general numeric type.
- `numericNum`: Specifies numeric type in `number` mode, implying traditional floating-point or fixed-point arithmetic.
- `numericBig`: Specifies numeric type in `bigint` mode, which is optimal for very large numbers that require precise integer arithmetic.

- **Type Safety**: Using specific modes like 'number' and 'bigint' enhances type safety, preventing potential errors in handling numerics.
- **Compatibility**: Ensure your TypeScript environment is properly set up to utilize Drizzle ORM.

- [Drizzle ORM SQLite Column Types](https://drizzle.zhcndoc.com/docs/column-types/sqlite)
- [Drizzle ORM GitHub Repository](https://github.com/drizzle-team/drizzle)

- Defining columns for a finance application where precision in decimal and integer operations is crucial.
- Creating tables for scientific data storage, utilizing large integer columns for massive datasets or identifiers.

## Code Snippet

```typescript
import { blob, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
  numeric: numeric(),
  numericNum: numeric({ mode: 'number' }),
  numericBig: numeric({ mode: 'bigint' }),
});
```

**Reasoning:** This rule is important because it demonstrates how to define a SQLite table with different numeric column types using Drizzle ORM. It highlights the flexibility and clarity provided by Drizzle's type definitions, which improve type safety and the accuracy of SQL operations in a TypeScript environment.

## Defining Columns with Numeric Type in SQLite

This document demonstrates how to define columns with the 'numeric' type in SQLite. The 'numeric' type is versatile, allowing for flexible storage and operation on numeric data within a table.

The code snippet creates a table named `table` with three columns, each using the 'numeric' type. The 'numeric' type is one of the supported storage types in SQLite, which can store any type of numeric data. It can auto-convert the stored data between integer and floating-point numbers based on need.

- SQLite uses dynamic typing. The 'numeric' storage class can store values as an integer, floating point, or text, depending on the value.
- While flexible, this can lead to unexpected results; it's crucial to ensure stored values are in the intended format.

- [SQLite Data Types](https://www.sqlite.org/datatype3.html)
- [Drizzle SQLite Column Types](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- Storing dynamic numeric data where precision and format may vary.
- Situations requiring data operations that involve various numeric types.

Other related column types include 'integer', 'real', and 'text', which may be used depending on the specific needs concerning precision and performance.

## Code Snippet

```typescript
CREATE TABLE `table` (
  `numeric` numeric,
  `numericNum` numeric,
  `numericBig` numeric,
);
```

**Reasoning:** This rule highlights the use of the 'numeric' column type in SQLite, which is important for defining columns that can store numbers, allowing for flexibility and precision in data storage. It demonstrates how to declare multiple columns with the same data type in a table.

## Type-Safe SQLite Column Definitions with Drizzle

This rule demonstrates how to define columns in a SQLite table using Drizzle, with a focus on type safety and structured data. By utilizing TypeScript's branding and type inference features, developers can enhance schema definitions and ensure consistency across their applications.

- **Branded Types**: The `UserId` type is defined using a TypeScript intersection type with a brand property. This ensures that only values explicitly marked as `UserId` can be assigned to it, promoting type safety.
- **Structured Data with JSON**: The `jsonField` column is declared as a blob, with a custom type `Data` that specifies its structure. This approach allows developers to enforce a specific structure for JSON data stored in the database.
- **Type Inference**: Drizzle leverages TypeScript's `$type` method to associate these custom types with database columns, ensuring that operations on these columns respect the defined types.

- **Branding Limitation**: Note that TypeScript's branding pattern is a compile-time construct and doesn’t enforce constraints at runtime.
- **JSON Handling**: Storing JSON data as a blob requires careful handling. Ensure that JSON is correctly serialized and deserialized when interacting with the database.

- [SQLite Column Types Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)
- [TypeScript Intersection Types](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html)

- Defining primary keys with unique types to avoid assignment errors.
- Enforcing structure for JSON fields in SQLite, enhancing data integrity and simplifying querying logic.

By following this rule, developers can create robust and maintainable database schemas that leverage TypeScript's strengths to prevent common runtime errors and improve developer productivity.

## Code Snippet

```typescript
type UserId = number & { __brand: 'user_id' };
type Data = {
  foo: string;
  bar: number;
};

const users = sqliteTable('users', {
  id: integer().$type<UserId>().primaryKey(),
  jsonField: blob().$type<Data>(),
});
```

**Reasoning:** This rule demonstrates best practices for defining strongly typed columns in a SQLite table using Drizzle. By employing TypeScript's `& { __brand: 'custom_type' }` pattern for unique identifiers, such as `UserId`, and custom types for fields like JSON, developers can leverage TypeScript's type system to ensure type safety and prevent assignment of incorrect types. This pattern also showcases how database schema definitions can be enhanced with type information that guides development and reduces runtime errors.

## Defining Non-Nullable Integer Columns in SQLite Tables Using Drizzle ORM

This rule demonstrates how to define a non-nullable integer column in a SQLite table using Drizzle ORM. This practice is crucial to enforce data integrity by ensuring that critical fields receive valid integer inputs and do not have null values.

- **`sqliteTable`**: A function to define a new SQLite table.
- **`numInt`**: The name of the column, indicating it stores numerical integer values.
- **`integer()`**: Specifies that the column type is `INTEGER`, a built-in type in SQLite.
- **`notNull()`**: Ensures that the `numInt` column cannot have `NULL` values, forcing data input for every row in the table.

- **Data Integrity**: Using `notNull()` helps maintain data integrity by preventing `NULL` entries in essential columns.
- Always ensure that your ORM or database driver is correctly set up to support type definitions and constraints.

- [Drizzle SQLite Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)
- [SQLite Data Types](https://sqlite.org/datatype3.html)

- Defining columns in user tables where IDs or other numerical identifiers must always be present.
- Ensuring that financial transactions have valid amounts without null entries.

- Defining other non-nullable types, such as `text().notNull()` for string values.

## Code Snippet

```typescript
const table = sqliteTable('table', { 
  numInt: integer().notNull() 
});
```

**Reasoning:** This rule highlights how to define a non-nullable integer column in a SQLite table using Drizzle ORM. It demonstrates the importance of ensuring data integrity by preventing null values in columns that require mandatory information.

## Defining NOT NULL Integer Columns in SQLite

This rule demonstrates how to create a table with an integer column using SQLite's data type conventions. Specifically, it shows how to set a NOT NULL constraint to ensure data integrity.

- `CREATE TABLE table`: This statement initializes a new table named `table`.
- `` `numInt` integer NOT NULL ``: Defines a column named `numInt` as an integer. The `NOT NULL` constraint ensures that this column cannot contain NULL values, meaning every entry must have a valid integer.

- Using `integer` in SQLite allows for a flexible range of numeric types, including 1-byte, 2-byte, 4-byte, and 8-byte signed integers.
- The `NOT NULL` constraint is essential for ensuring that crucial values are always present, preventing incomplete or corrupted data entries.

- [SQLite Data Types](https://www.sqlite.org/datatype3.html)
- [Drizzle SQLite Column Types Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- Enforcing mandatory fields such as IDs or timestamps where null values would be unacceptable.
- Ensuring data consistency in applications requiring precise data input.

Variations of this pattern could include using different constraints like `DEFAULT` values or `UNIQUE` constraints to further refine data integrity rules.

## Code Snippet

```typescript
CREATE TABLE table (
  `numInt` integer NOT NULL
);
```

**Reasoning:** This rule is important because it demonstrates how to define an integer column in an SQLite table using Drizzle. Understanding how to set constraints like NOT NULL is crucial for data integrity, ensuring that every entry in the column must have a value.

## Defining Default Values for SQLite Columns Using Drizzle ORM

This rule demonstrates how to define default values for columns in a SQLite table using Drizzle ORM. It covers the use of both constant values and SQL expressions.

- **Constant Default Value:** The `int1` column is defined with a default value of `42`. This is a straightforward method where a constant is assigned as the default.

- **SQL Expression as Default Value:** The `int2` column uses a SQL expression `sql` to compute its default value. This allows for dynamic default values using SQLite functions or operations, providing more flexibility.

- **Type Safety:** Ensure that the default value matches the column type to prevent runtime errors.

- **Performance Considerations:** While using SQL expressions for defaults can be powerful, it may have performance implications depending on the complexity of the expressions.

- **Database Compatibility:** This pattern is SQLite-specific; check compatibility if migrating to another database system.

- [Drizzle ORM Documentation](https://drizzle.zhcndoc.com/docs/)
- [SQLite Column Types](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- **Setting Default Numeric Values:** Use constant defaults for columns where a common numeric value is expected.
- **Dynamic Defaults:** Use SQL expressions to calculate defaults based on other parameters or conditions, such as timestamps or computed averages.

By understanding these methods, developers can make informed decisions on how to initialize database columns effectively.

## Code Snippet

```typescript
import { sql } from "drizzle-orm";
import { integer, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
  int1: integer().default(42),
  int2: integer().default(sql`(abs(42))`)
});
```

**Reasoning:** This rule is important as it illustrates how to define default values for columns in a SQLite table using Drizzle ORM. It demonstrates two methods: using a constant value and using a SQL expression. Understanding these methods is crucial for setting default behaviors in database applications, ensuring that tables have meaningful default data, and leveraging SQL functions for dynamic defaults.

## Using Default Values in SQLite Columns

This code snippet demonstrates how to define default values for columns in an SQLite table. It includes both a static default value and a dynamic default value using a function.

- **`int1 integer DEFAULT 42`**: This defines a column `int1` with an integer data type and a static default value of 42.
- **`int2 integer DEFAULT (abs(42))`**: This defines a column `int2` with an integer data type and a dynamic default value. The default is computed using the `abs()` function applied to 42. 

- Default values are used when an `INSERT` statement does not provide a value for the column.
- Dynamic defaults like the use of functions can provide flexibility but may have performance implications.

- [SQLite Column Types Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- **Static Defaults**: When a consistent value is often used, such as setting a default user role or status.
- **Dynamic Defaults**: When the default needs to be calculated, such as timestamping with the current date or applying a function to another column.

## Code Snippet

```typescript
CREATE TABLE `table` (
  `int1` integer DEFAULT 42,
  `int2` integer DEFAULT (abs(42))
);
```

**Reasoning:** This rule is important for understanding the use of default values in SQLite column definitions, showcasing both static and dynamic defaults. It demonstrates how to set a column with a constant default value and another with a computed default using a function.

## Automating Date and Time Defaults in SQLite with Drizzle ORM

This code snippet demonstrates how to define a table in SQLite using Drizzle ORM, where specific columns are automatically set to the current date and time using SQLite's built-in functions.

- **`CURRENT_TIME`**, **`CURRENT_DATE`**, and **`CURRENT_TIMESTAMP`** are SQL functions that return the current time, date, and timestamp respectively. When a new record is inserted into the table, these functions automatically set the column values.
- The `text()` function is used to define the column type as text in SQLite. Although SQLite is type-flexible, using `text` ensures consistency for date and time values.
- `default(sql...)` allows setting a default SQL expression for a column, meaning each insertion defaults to the current time or date unless specified otherwise.

- Make sure the database connection is correctly configured to respect SQLite's native functions.
- Default expressions like this are evaluated at the time of insertion.

- [SQLite Column Types](https://drizzle.zhcndoc.com/docs/column-types/sqlite)
- [SQLite Date and Time functions](https://www.sqlite.org/lang_datefunc.html)

- Automatically timestamping records for audit trails or logs.
- Efficiently setting the default timezone information.
- Simplifying code by reducing the need to manually insert timestamps.

## Code Snippet

```typescript
import { sql } from "drizzle-orm";
import { text, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable("table", {
  time: text().default(sql`(CURRENT_TIME)`),
  date: text().default(sql`(CURRENT_DATE)`),
  timestamp: text().default(sql`(CURRENT_TIMESTAMP)`),
});
```

**Reasoning:** This rule is important because it illustrates the use of default values for date and time columns in SQLite using Drizzle ORM. It demonstrates how to set default SQL expressions for fields, ensuring that each new entry gets assigned the current date and time automatically, which is crucial for applications needing timestamped records.

## Default Date and Time in SQLite Tables

This rule demonstrates how to create SQLite tables with columns that have default values for the current time, date, and timestamp using text data types. It is useful for automatically capturing when records are created.

- **`time` column**: This column defaults to the current time when a record is inserted, using the `CURRENT_TIME` function.
- **`date` column**: This column defaults to the current date, using the `CURRENT_DATE` function.
- **`timestamp` column**: This column captures both date and time at the moment of insertion, using the `CURRENT_TIMESTAMP` function.

These columns are defined with the `text` type to store the date and time data as strings in SQLite.

- SQLite stores date and time as strings, which means the operations on such fields might require conversions if needed in different formats.
- Ensure that the server's time zone is correctly set, as the date and time functions rely on this setting.

- [SQLite Date and Time Functions](https://www.sqlite.org/lang_datefunc.html)
- [Drizzle SQLite Column Types Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- Time-stamping records when they are created for auditing or logging purposes.
- Creating modification logs for changes in a database.

- Using different default functions or formats for special use cases, such as including/excluding specific time components.

## Code Snippet

```typescript
CREATE TABLE `table` (
  `time` text DEFAULT (CURRENT_TIME),
  `date` text DEFAULT (CURRENT_DATE),
  `timestamp` text DEFAULT (CURRENT_TIMESTAMP)
);
```

**Reasoning:** This rule is important as it demonstrates how to set default date and time in SQLite tables using text data types. It ensures that the fields automatically capture the current date and time when a new record is inserted, which is crucial for logging and tracking modifications.

## Setting Default Functions for SQLite Columns with Drizzle ORM

This code snippet demonstrates how to set up a SQLite table with a default function for generating values for a column using Drizzle ORM.

- **Import Statements**: The code imports necessary functions from 'drizzle-orm/sqlite-core' and '@paralleldrive/cuid2'.
- **sqliteTable Function**: Used to define a new SQLite table named 'table'.
- **Column Definition**: The `id` column is of type `text`, with a default function that generates a unique identifier using `createId()`.

- The use of `defaultFn` allows automatic assignment of values, reducing manual entry errors.
- Ensure the `@paralleldrive/cuid2` library is installed and properly configured in your environment, as it provides the `createId()` function.

- [Drizzle ORM Documentation](https://drizzle.zhcndoc.com/docs)
- [cuid2 Documentation](https://www.npmjs.com/package/@paralleldrive/cuid2)

- **Unique Identifier Generation**: Automatically generate unique IDs for primary keys.
- **Timestamp Assignment**: Use for default timestamps in records.

- **UUIDs**: Use UUID libraries for ID generation instead of `cuid2`.
- **Default Boolean/Integer Values**: Define other default values such as `boolean().$default(true)` or `integer().$default(0)`.

## Code Snippet

```typescript
import { text, sqliteTable } from "drizzle-orm/sqlite-core";
import { createId } from '@paralleldrive/cuid2';

const table = sqliteTable('table', {
  id: text().$defaultFn(() => createId()),
});
```

**Reasoning:** This rule is important as it demonstrates how to define a default value generation for a SQLite table column using Drizzle ORM. It showcases the usage of custom functions to automatically assign values, which can be particularly useful for unique identifiers.

## Always Null Column in SQLite with Drizzle ORM

This code snippet illustrates how to define a column in an SQLite table using Drizzle ORM that will always hold a null value whenever it's updated.

- **Importing Modules**: The snippet imports `text` and `sqliteTable` from the Drizzle ORM core for SQLite, which are essential for defining a table structure.
- **Table Definition**: The `sqliteTable` function defines a new table with a column named `alwaysNull`.
- **Column Type**: The column uses the `text()` method to specify a text type, but it is also set up to potentially accept `null` values by chaining the `$type<string | null>()` method.
- **Update Logic**: The `$onUpdate(() => null)` method ensures that whenever a record in this table is updated, this specific column will automatically be set to null.

- This pattern should be used carefully as forcing a column to always remain null could lead to data consistency issues if not properly justified by the application logic.
- Ensure that this behavior is aligned with the rest of the application to prevent unexpected data loss.

- [Drizzle ORM Documentation](https://drizzle.zhcndoc.com/docs/column-types/sqlite)

- **Audit Trails**: Use in scenarios where nullifying a field signifies the completion or invalidation of a record.
- **Data Privacy**: Automatically nullify sensitive fields after use.

This rule demonstrates a specific use of Drizzle ORM column configuration for SQLite, highlighting an advanced pattern useful in specialized database management scenarios.

## Code Snippet

```typescript
import { text, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
    alwaysNull: text().$type<string | null>().$onUpdate(() => null),
});
```

**Reasoning:** This rule is important because it demonstrates how to define a column in an SQLite table using Drizzle ORM that is always null. This pattern is essential for ensuring that certain fields are initialized or updated with a null value, which can be useful in specific database operations or logic implementations.

## Establishing an SQLite Connection with Drizzle ORM and Expo

This code snippet demonstrates how to establish a connection to an SQLite database using Drizzle ORM and Expo in a React Native environment.

- `import { drizzle } from "drizzle-orm/expo-sqlite";`: This imports the `drizzle` function from the Drizzle ORM package, which is tailored to work with Expo.
- `import { openDatabaseSync } from "expo-sqlite/next";`: This line imports the `openDatabaseSync` function from the `expo-sqlite` package, allowing for synchronous database connection creation.
- `const expo = openDatabaseSync("db.db");`: This initializes a connection to the local SQLite database named `db.db`. It establishes a bridge between the React Native app and the database.
- `const db = drizzle(expo);`: This wraps the SQLite connection with Drizzle ORM, enabling the use of ORM functionalities for managing the database.

- Ensure that the `drizzle-orm` and `expo-sqlite` packages are installed and properly configured in your project.
- This pattern is specific to environments where Expo is used as part of React Native applications.

- [Drizzle ORM Documentation](https://drizzle.zhcndoc.com/docs/connect-overview)
- [Expo SQLite Documentation](https://docs.expo.dev/versions/latest/sdk/sqlite/)

- Setting up a new project that requires data persistence with SQLite in a React Native application.
- Migrating existing SQLite querying logic to use ORM patterns with Drizzle for better maintainability and scalability.
- Developing offline-first mobile applications that need efficient local data storage.

## Code Snippet

```typescript
import { drizzle } from "drizzle-orm/expo-sqlite";
import { openDatabaseSync } from "expo-sqlite/next";

const expo = openDatabaseSync("db.db");
const db = drizzle(expo);
```

**Reasoning:** This rule demonstrates how to establish a connection to an SQLite database using the Drizzle ORM with Expo. Understanding how to set up this connection is crucial for developers who need to interact with a local SQLite database in a React Native application. This pattern simplifies database operations, facilitating efficient data management and retrieval.

## Initializing SQLite with Drizzle ORM in TypeScript Projects

This rule explains how to initialize a SQLite database using Drizzle ORM in a TypeScript project.

- **Import Environment Variables:** The snippet imports environment variables using `dotenv`. This allows you to use environment variables stored in a `.env` file, which is a common practice for managing configuration settings, such as database connection details.

- **Drizzle ORM Import:** The code imports the `drizzle` function from the `drizzle-orm/libsql` package. Drizzle ORM is a lightweight ORM that provides a simple API for interacting with databases.

- **Database Initialization:** The `drizzle` function initializes a connection to the SQLite database using the file name specified in the `DB_FILE_NAME` environment variable.

- **Environment Variables:** Ensure that the `.env` file is properly configured and contains the necessary variables, like `DB_FILE_NAME` pointing to the correct SQLite database file.

- **Error Handling:** Consider wrapping the database initialization in a try-catch block to handle possible errors gracefully.

- [Drizzle ORM Documentation](https://orm.drizzle.team/docs)
- [dotenv Package Documentation](https://www.npmjs.com/package/dotenv)

- **Using Different SQLite Files:** You can switch between different SQLite databases by changing the `DB_FILE_NAME` value in the `.env` file.

- **Integration with Express:** Use the initialized `db` object with Express.js for handling route-based database interactions.

- **TypeScript Type Safety:** Extend this pattern by defining models that provide full TypeScript support and type safety for database operations.

## Code Snippet

```typescript
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/libsql';

const db = drizzle(process.env.DB_FILE_NAME!);
```

**Reasoning:** This rule demonstrates how to set up and initialize a SQLite database connection using Drizzle ORM in an existing TypeScript project. It is crucial for developers who want to leverage Drizzle ORM as their database abstraction layer, allowing for type-safe and maintainable database operations.

## Connecting to SQLite with Drizzle ORM in TypeScript

This guide demonstrates how to connect to a SQLite database using Drizzle ORM in an existing TypeScript project.

1. **Environment Configuration**: The code begins by importing environment variables with `dotenv/config`, ensuring that sensitive information like the database file name is managed securely.

2. **Library Imports**: The `drizzle` and `createClient` functions are imported from their respective libraries. These are essential for setting up and managing the database connection.

3. **Client Creation**: `createClient` is used to establish a connection to the SQLite database. It uses the `DB_FILE_NAME` environment variable to locate the database file.

4. **Drizzle ORM Initialization**: The `drizzle` function is called with the client as a parameter, which initializes the ORM, allowing for interaction with the database through a structured, object-oriented approach.

- Ensure that the `DB_FILE_NAME` is properly set in your environment variables to avoid connection issues.
- This setup is specific to TypeScript projects using SQLite with Drizzle ORM. Other database systems may require different configurations.

- [Drizzle ORM Documentation](https://orm.drizzle.team/)
- [Node.js dotenv Documentation](https://www.npmjs.com/package/dotenv)

- Rapid prototyping with a lightweight SQLite database.
- Projects requiring an easily configurable local database solution for testing or development.

- Modifying the client to include additional options, such as logging or connection pooling, based on project requirements.

## Code Snippet

```typescript
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/libsql';
import { createClient } from '@libsql/client';

const client = createClient({ url: process.env.DB_FILE_NAME! });
const db = drizzle({ client });
```

**Reasoning:** This rule demonstrates how to connect to a SQLite database using Drizzle ORM in a TypeScript project. It highlights the setup process, including importing required libraries, configuring the database client, and establishing a connection. Understanding this pattern is crucial for effectively using Drizzle ORM with SQLite, ensuring a streamlined database integration.

## Basic CRUD Operations with Drizzle ORM and SQLite

This guide demonstrates how to integrate Drizzle ORM with SQLite, showing key database operations such as creating, reading, updating, and deleting records.

1. **Setup**: Import the necessary modules, including dotenv for environment variables, and initialize the Drizzle ORM with your SQLite database file specified in `.env`.

2. **Create**: Insert a new record into the `usersTable` and confirm creation.

3. **Read**: Select and log all users from the `usersTable`.

4. **Update**: Update specific user details using a WHERE clause for precision.

5. **Delete**: Remove records by criteria, demonstrating a full CRUD cycle.

- Ensure all environment variables, such as `DB_FILE_NAME`, are correctly configured.
- Handle exceptions or errors that may occur during operations to maintain data integrity and stability.

- [Drizzle ORM Documentation](https://orm.drizzle.team/docs/get-started/sqlite-existing)
- SQLite and Drizzle ORM integration guide

- Rapid prototyping with SQLite.
- CRUD operations in lightweight applications.
- Applications or scripts where portability of the database is beneficial.

## Code Snippet

```typescript
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/libsql';
import { eq } from 'drizzle-orm';
import { usersTable } from './db/schema';

const db = drizzle(process.env.DB_FILE_NAME!);

async function main() {
  const user: typeof usersTable.$inferInsert = {
    name: 'John',
    age: 30,
    email: '[email protected]',
  };

  await db.insert(usersTable).values(user);
  console.log('New user created!')

  const users = await db.select().from(usersTable);
  console.log('Getting all users from the database: ', users)
  /*
  const users: {
    id: number;
    name: string;
    age: number;
    email: string;
  }[]
  */

  await db
    .update(usersTable)
    .set({
      age: 31,
    })
    .where(eq(usersTable.email, user.email));
  console.log('User info updated!')

  await db.delete(usersTable).where(eq(usersTable.email, user.email));
  console.log('User deleted!')
}

main();
```

**Reasoning:** This rule is important because it provides a practical guide to using Drizzle ORM with SQLite in an existing project. It demonstrates basic database operations such as inserting, updating, selecting, and deleting data. Understanding these operations is crucial for anyone looking to manage SQLite databases effectively with Drizzle ORM.

## Creating a User Table in SQLite with Drizzle

This snippet demonstrates how to create a `users_table` in SQLite using the Drizzle ORM. The table captures essential user information and enforces data integrity through constraints.

- **`id` field**: An integer that serves as the primary key and automatically increments for each new record, ensuring a unique identifier for each user.
- **`name` field**: A non-null text field that records the user's name.
- **`age` field**: A non-null integer field that stores the user's age.
- **`email` field**: A non-null text field with a unique constraint to ensure no duplicate emails are entered.

- Defining a primary key with `AUTOINCREMENT` helps maintain a unique identity for each record.
- The `UNIQUE` constraint on the `email` field is essential for maintaining user uniqueness and preventing duplicate email entries.

- [Drizzle ORM - Get Started with SQLite](https://orm.drizzle.team/docs/get-started/sqlite-existing)
- [SQLite Documentation](https://www.sqlite.org/docs.html)

- This table structure is ideal for managing user data in applications such as web apps, user management systems, or any platform requiring user registration and authentication.
- Variations may include adding fields like `created_at` for timestamps, `password` for authentication purposes, or `role` for user permissions management.

## Code Snippet

```typescript
CREATE TABLE `users_table` (
  `id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
  `name` text NOT NULL,
  `age` integer NOT NULL,
  `email` text NOT NULL UNIQUE
);
```

**Reasoning:** This rule demonstrates how to create a basic table in SQLite using the Drizzle ORM. It highlights how to define primary keys, data types, and constraints to ensure database integrity and uniqueness. This pattern is essential for managing structured data effectively within a database.
