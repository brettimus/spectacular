# Hono Framework Rules - 4/2/2025, 4:55:02 PM

Generated from 79 documentation files.

## Builtin

### Importing and Using Language Detector in Hono

This code demonstrates how to import and use the language detector feature in Hono. This is useful for internationalization (i18n) and locale-specific content.

```ts
import { Hono } from 'hono'
import { languageDetector } from 'hono/language'
```

1. The `Hono` module is imported from the 'hono' package.
2. The `languageDetector` module is imported from 'hono/language'.
3. These modules can then be used to detect language from query string, cookie, and header, with a fallback to English.

- The order of detection is query string, cookie, and header by default.
- It's important to specify the supported languages when using the language detector.

- [Hono Documentation](https://hono.bespoken.io/)

- Internationalization (i18n)
- Locale-specific content

**Reasoning:** This rule is important as it demonstrates how to use the language detector feature in Hono for internationalization (i18n) and locale-specific content. It shows how to import the necessary modules and use them to detect language from query string, cookie, and header, with a fallback to English.

*Source: docs/middleware/builtin/language.md*

### Language Detection in Hono

This code demonstrates how to use the `languageDetector` middleware in Hono to detect the language from the query string, cookie, and header. It also shows how to set a fallback language and how to retrieve the detected language in a route handler.

```ts
const app = new Hono()

app.use(
  languageDetector({
    supportedLanguages: ['en', 'ar', 'ja'],
    fallbackLanguage: 'en',
  })
)

app.get('/', (c) => {
  const lang = c.get('language')
  return c.text(`Hello! Your language is ${lang}`)
})
```

The `languageDetector` middleware is used with the Hono application. It is configured with an array of supported languages and a fallback language. The middleware will try to detect the language from the query string, cookie, and header (in that order). If it cannot detect a language, it will use the fallback language.

In the route handler, the detected language can be retrieved with `c.get('language')`.

- The `supportedLanguages` array must include the `fallbackLanguage`.

- [Hono documentation](https://hono.beyondnifty.com/)

- Building a multilingual web application

**Reasoning:** This rule is important as it demonstrates how to use the languageDetector middleware in Hono to detect the language from the query string, cookie, and header. It also shows how to set a fallback language and how to retrieve the detected language in a route handler. This is a common requirement in web applications that need to support multiple languages.

*Source: docs/middleware/builtin/language.md*

### Language Detection and Localization in Hono

This code snippet demonstrates how to handle language detection and localization in Hono. It shows how to set up a fallback language and how to retrieve the language from different sources.

```sh

curl http://localhost:8787/ar/home

curl http://localhost:8787/?lang=ar

curl -H 'Cookie: language=ja' http://localhost:8787/

curl -H 'Accept-Language: ar,en;q=0.9' http://localhost:8787/
```

The Hono framework allows you to specify a fallback language that will be used if no language is specified by the client. The language can be specified in several ways: via the path, a query parameter, a cookie, or a header.

The order of precedence for language detection is as follows: querystring, cookie, header. This means that if a language is specified in both the querystring and the cookie, the language from the querystring will be used.

- [Hono Documentation](https://hono.bouzuya.net/)

This pattern is commonly used in web applications that need to support multiple languages.

**Reasoning:** This rule is important as it demonstrates how to handle language detection and localization in Hono. It shows how to set up a fallback language and how to retrieve the language from different sources such as path, query parameter, cookie, and header.

*Source: docs/middleware/builtin/language.md*

### Setting Up Language Detection in Hono

This code snippet demonstrates how to set up language detection in a Hono application. The `DEFAULT_OPTIONS` object defines the default configuration for language detection.

```ts
export const DEFAULT_OPTIONS: DetectorOptions = {
  order: ['querystring', 'cookie', 'header'],
  lookupQueryString: 'lang',
  lookupCookie: 'language',
  lookupFromHeaderKey: 'accept-language',
  lookupFromPathIndex: 0,
  caches: ['cookie'],
  ignoreCase: true,
  fallbackLanguage: 'en',
  supportedLanguages: ['en'],
  cookieOptions: {
    sameSite: 'Strict',
    secure: true,
    maxAge: 365 * 24 * 60 * 60,
    httpOnly: true,
  },
  debug: false,
}
```

The `order` array defines the sequence of sources that the detector will check for a language preference. It will first check the query string, then the cookie, and finally the header. The `lookup*` properties define the specific keys to look for in each source.

If no language preference is found, the detector will fall back to the language specified by `fallbackLanguage`.

- The `caches` array specifies which sources to cache the detected language in. In this case, the language will be cached in the cookie.
- The `ignoreCase` property determines whether the detector should ignore case when matching languages.

- [Hono Documentation](https://hono.bouzuya.net/)

- Internationalizing a Hono application
- Providing a localized user experience

**Reasoning:** This rule is important as it demonstrates how to set up language detection in a Hono application. It shows the default configuration for language detection, including the order of sources to check for language preference (query string, cookie, header), the specific keys to look for in each source, and the fallback language to use if no preference is found. Understanding this rule can help developers to effectively internationalize their applications, providing a better user experience for users of different languages.

*Source: docs/middleware/builtin/language.md*

### Custom Language Detection Order in Hono

This code snippet demonstrates how to configure the language detection order in Hono. It prioritizes URL path detection over other methods like cookies, query strings, and headers.

```ts
app.use(
  languageDetector({
    order: ['path', 'cookie', 'querystring', 'header'],
    lookupFromPathIndex: 0, // /en/profile → index 0 = 'en'
    supportedLanguages: ['en', 'ar'],
    fallbackLanguage: 'en',
  })
)
```

The `order` array determines the priority of language detection methods. The `lookupFromPathIndex` option is used to specify the index of the language code in the URL path. The `supportedLanguages` array lists the languages supported by the application. If no valid language is detected, the `fallbackLanguage` is used.

- The `order` array should contain at least one method.
- The `lookupFromPathIndex` should be a valid index in the URL path.
- The `supportedLanguages` should contain valid language codes.
- The `fallbackLanguage` should be a valid language code and must be included in the `supportedLanguages` array.

- [Hono Documentation](https://hono.bouzuya.net/)

- Multilingual applications
- Applications that prioritize URL path for language detection

**Reasoning:** This rule is important as it demonstrates how to configure the language detection order in Hono. It shows how to prioritize URL path detection over other methods like cookies, query strings, and headers. This is useful in applications that need to support multiple languages and have a specific preference for how the language should be detected.

*Source: docs/middleware/builtin/language.md*

### Configuring Language Detection in Hono

This code snippet demonstrates how to configure language detection in a Hono application. It shows how to normalize complex language codes and set supported languages and a fallback language.

```ts
app.use(
  languageDetector({
    convertDetectedLanguage: (lang) => lang.split('-')[0],
    supportedLanguages: ['en', 'ja'],
    fallbackLanguage: 'en',
  })
)
```

1. `convertDetectedLanguage`: This function is used to normalize complex language codes. It splits the detected language code by '-' and returns the first part. For example, it converts 'en-US' to 'en'.
2. `supportedLanguages`: This is an array of supported language codes. In this example, 'en' and 'ja' are supported.
3. `fallbackLanguage`: This is the default language that will be used if the detected language is not supported.

- The `languageDetector` middleware must be used before any other middleware that needs to know the user's language preference.

- [Hono Documentation](https://hono.beeceptor.com/docs)

- Multilingual applications that need to adapt the user interface based on the user's language preference.

**Reasoning:** This rule is important as it demonstrates how to configure language detection in a Hono application. It shows how to normalize complex language codes (e.g., en-US to en) and set supported languages and a fallback language. This is crucial for applications that support multiple languages and need to adapt the user interface based on the user's language preference.

*Source: docs/middleware/builtin/language.md*

### Configuring Language Detection and Cookie Settings in Hono

This code snippet demonstrates how to configure language detection and cookie settings in Hono.

```ts
app.use(
  languageDetector({
    lookupCookie: 'app_lang',
    caches: ['cookie'],
    cookieOptions: {
      path: '/',
      sameSite: 'Lax',
      secure: true,
      maxAge: 86400 * 365,
      httpOnly: true,
      domain: '.example.com',
    },
  })
)
```

1. `lookupCookie: 'app_lang'` - This sets the name of the cookie to be used for language detection.
2. `caches: ['cookie']` - This enables caching of the detected language in cookies.
3. `cookieOptions` - This is used to specify various options for the cookie.

- `sameSite: 'Lax'` - This sets the SameSite attribute of the cookie to 'Lax', which means the cookie will only be sent in a first-party context and not with cross-origin requests.
- `secure: true` - This ensures that the cookie is only sent over HTTPS.
- `httpOnly: true` - This makes the cookie inaccessible via JavaScript, providing protection against cross-site scripting (XSS) attacks.

- [Hono Documentation](https://www.eclipse.org/hono/docs/)

- Internationalization and localization of applications
- Managing user sessions securely

**Reasoning:** This rule is important as it demonstrates how to configure language detection and cookie settings in Hono. It shows how to specify supported languages, fallback language, cookie options, and how to enable or disable caching and debugging. Understanding this rule is crucial for internationalization and localization of applications, as well as for managing user sessions securely.

*Source: docs/middleware/builtin/language.md*

### Disabling Cookie Caching in Hono

In Hono, you can disable cookie caching by setting the `caches` option to `false` in the `languageDetector` function.

Here is a code snippet demonstrating this:

```ts
languageDetector({
  caches: false,
})
```

When `caches` is set to `false`, Hono will not store any cookies. This means that every time a request is made, Hono will not have any stored data to refer to and will have to process the request as if it is the first time.

This can be useful in situations where the data is sensitive and should not be stored, or when the data changes frequently and the cache would serve stale data. However, keep in mind that disabling caching can impact performance, as Hono will have to process every request from scratch.

- [Hono Documentation](https://hono.bouzuya.net/)

- When dealing with sensitive data that should not be stored
- When the data changes frequently and the cache would serve stale data

**Reasoning:** This rule is important as it demonstrates how to disable cookie caching in Hono. Caching can be useful for performance, but there may be situations where it is necessary to disable it, such as when the data is sensitive and should not be stored, or when the data changes frequently and the cache would serve stale data.

*Source: docs/middleware/builtin/language.md*

### Enabling Debugging in Hono's Language Detector

This code snippet demonstrates how to enable debugging in Hono's language detector.

```ts
languageDetector({
  debug: true, // Shows: "Detected from querystring: ar"
})
```

By setting the 'debug' option to 'true', the language detector will log the detection steps. This can be useful for understanding how the language detector is working and diagnosing any issues.

When the 'debug' option is set to 'true', the language detector will log the detection steps to the console. This includes the source of the detected language (e.g., 'Detected from querystring: ar').

- Debugging should generally be disabled in production environments, as it can expose sensitive information and negatively impact performance.

- [Hono Documentation](https://www.example.com)

- Debugging issues with language detection
- Understanding how the language detector is working

**Reasoning:** This rule is important as it demonstrates how to enable debugging in Hono's language detector. Debugging is a crucial part of development and testing, as it allows developers to trace the execution of a program and find and fix bugs. In this case, setting the 'debug' option to 'true' will log the detection steps, which can be helpful in understanding how the language detector is working and diagnosing any issues.

*Source: docs/middleware/builtin/language.md*

### Implementing Language Detection and Localization in Hono

The following code snippets demonstrate how to implement language detection and localization in Hono.

```ts
app.get('/:lang/home', (c) => {
  const lang = c.get('language') // 'en', 'ar', etc.
  return c.json({ message: getLocalizedContent(lang) })
})
ts
languageDetector({
  supportedLanguages: ['en', 'en-GB', 'ar', 'ar-EG'],
  convertDetectedLanguage: (lang) => lang.replace('_', '-'), // Normalize
})
```

This snippet demonstrates how to define supported languages and normalize detected languages for consistency.

1. The `languageDetector` function is called with an object that specifies the supported languages and a function to normalize the detected language.
2. The `convertDetectedLanguage` function replaces underscores with hyphens in the detected language code to ensure consistency.

- The `languageDetector` function and the `convertDetectedLanguage` function are part of the Hono framework's internationalization (i18n) support.

- [Hono Documentation](https://hono.boutique/docs)

- Providing localized content to users based on their language preference or location.

#### Code Snippet

```typescript

This snippet shows how to retrieve the language from the request context and return localized content.

```

**Reasoning:** This rule is important as it demonstrates how to implement language detection and localization in Hono. It shows how to define supported languages and normalize detected languages for consistency. This is crucial for applications that need to support multiple languages and provide localized content to users.

*Source: docs/middleware/builtin/language.md*

### Using the 'compress' Middleware in Hono

This code snippet demonstrates how to use the 'compress' middleware in Hono to automatically compress the response body.

```ts
import { Hono } from 'hono'
import { compress } from 'hono/compress'

const app = new Hono()

app.use(compress())
```

The 'compress' middleware uses 'CompressionStream' to compress the response body. This can significantly reduce the size of the data being sent over the network, leading to faster response times.

This middleware uses 'CompressionStream', which is not yet supported in bun. Therefore, it should not be used if you are using bun.

- [Hono Documentation](https://hono.bun.dev/)

This middleware is commonly used in applications where large amounts of data are being sent over the network and faster response times are desired.

**Reasoning:** This rule is important as it demonstrates how to use the 'compress' middleware in Hono. The 'compress' middleware is used to automatically compress the response body, which can significantly reduce the size of the data being sent over the network, leading to faster response times. However, it's important to note that this middleware uses 'CompressionStream', which is not yet supported in bun.

*Source: docs/middleware/builtin/compress.md*

### Using Compression Middleware in Hono

This rule demonstrates how to use the 'compress' middleware in the Hono web framework.

```ts
import { Hono } from 'hono'
import { compress } from 'hono/compress'

const app = new Hono()

app.use(compress())
```

1. Import the necessary modules from 'hono' and 'hono/compress'.
2. Create a new Hono application.
3. Use the 'compress' middleware in the Hono application.

- The 'compress' middleware uses 'CompressionStream' which is not yet supported in bun.
- The 'compress' middleware allows for response compression using either 'gzip' or 'deflate'. If not defined, both are allowed.

- [Hono Documentation](https://hono.bun.dev/)

- Use this middleware when you want to reduce the size of the response body and increase the speed of your web application.

**Reasoning:** This rule is important as it demonstrates how to use the 'compress' middleware in the Hono web framework. It shows how to import the necessary modules and apply the middleware to the Hono application. This is a common practice in web development to reduce the size of the response body and hence, increase the speed of a web application.

*Source: docs/middleware/builtin/compress.md*

### Conditionally Enabling Timing in Hono

In Hono, you can conditionally enable timing for your requests. This can be done by passing a function to the `enabled` option in the `timing` middleware. This function receives the request context and should return a boolean indicating whether or not to enable timing.

Here's an example of how to enable timing only for POST requests:

```ts
const app = new Hono()

app.use(
  '*',
  timing({
    // c: Context of the request
    enabled: (c) => c.req.method === 'POST',
  })
)
```

In this example, the `enabled` function checks if the request method is 'POST'. If it is, timing is enabled for that request.

- The `enabled` function should return a boolean.
- The `enabled` function is called for every request, so it should be as lightweight as possible to avoid impacting performance.

- [Hono Documentation](https://hono.bespokejs.com)

- Conditionally enabling timing based on request method, headers, or other request properties.

**Reasoning:** This rule is important as it demonstrates how to conditionally enable timing in Hono. It shows how to use a function to determine whether or not to enable timing based on the request method. This can be useful in scenarios where you only want to measure the time taken for certain types of requests, such as POST requests.

*Source: docs/middleware/builtin/timing.md*

### Importing IP Restriction Middleware in Hono

This code demonstrates how to import the IP Restriction Middleware in Hono. This middleware is used to limit access to resources based on the user's IP address.

```ts
import { Hono } from 'hono'
import { ipRestriction } from 'hono/ip-restriction'
```

The `import` statements are used to include the `Hono` and `ipRestriction` modules from the 'hono' and 'hono/ip-restriction' packages respectively.

- Make sure the 'hono' and 'hono/ip-restriction' packages are installed in your project before importing them.
- The 'ipRestriction' middleware should be used judiciously as it can block access to legitimate users if not configured properly.

- [Hono Documentation](https://hono.bun.dev/docs)

- Restricting access to certain resources based on the user's IP address.
- Implementing IP-based rate limiting.

**Reasoning:** This rule is important as it demonstrates how to import the IP Restriction Middleware in Hono. This middleware is used to limit access to resources based on the user's IP address, which is crucial for security purposes.

*Source: docs/middleware/builtin/ip-restriction.md*

### Implementing IP Restriction in Hono

This code demonstrates how to implement IP restriction in Hono using the 'ipRestriction' middleware.

```ts
import { Hono } from 'hono'
import { getConnInfo } from 'hono/bun'
import { ipRestriction } from 'hono/ip-restriction'

const app = new Hono()

app.use(
  '*',
  ipRestriction(getConnInfo, {
    denyList: [],
    allowList: ['127.0.0.1', '::1'],
  })
)

app.get('/', (c) => c.text('Hello Hono!'))
```

The 'ipRestriction' middleware is used with the 'app.use' method to apply the IP restriction to all routes ('*'). The 'getConnInfo' function is passed as the first argument to 'ipRestriction', and an object with 'denyList' and 'allowList' properties is passed as the second argument. The 'denyList' property is an array of IP addresses that are denied access, and the 'allowList' property is an array of IP addresses that are allowed access.

- The 'getConnInfo' function should be imported from the appropriate module for your environment.
- The 'denyList' and 'allowList' arrays can be modified to suit your needs.

- [ConnInfo helper](/docs/helpers/conninfo)

- Restricting access to local development environment
- Preventing unauthorized access to certain routes

**Reasoning:** This rule is important as it demonstrates how to implement IP restriction in Hono. It shows how to use the 'ipRestriction' middleware to allow or deny access to certain IP addresses. This is crucial for security purposes, as it can prevent unauthorized access to the application.

*Source: docs/middleware/builtin/ip-restriction.md*

### Implementing IP Restrictions in Hono Framework

This code snippet demonstrates how to implement IP restrictions in a web application using the Hono framework. The 'ipRestriction' middleware and the 'getConnInfo' helper from the ConnInfo helper are used to achieve this.

```ts
import { getConnInfo } from 'hono/deno'
import { ipRestriction } from 'hono/ip-restriction'

//...

app.use(
  '*',
  ipRestriction(getConnInfo, {
    // ...
  })
)
```

The 'getConnInfo' helper is passed as the first argument to the 'ipRestriction' middleware. This helper provides the connection information necessary for the middleware to determine the IP address of the incoming request.

The 'ipRestriction' middleware then uses this information to restrict access based on the IP address. The specific IP addresses or ranges to be restricted can be specified in the options object passed as the second argument to the middleware.

- The 'getConnInfo' helper used may vary depending on the environment. The example shown is for Deno.

- The IP addresses can be specified in various formats including static IP addresses, CIDR notation, or using '*' to represent all addresses.

- [ConnInfo helper](/docs/helpers/conninfo)

- Restricting access to an application based on IP addresses for security purposes.

**Reasoning:** This rule is important as it demonstrates how to implement IP restrictions using the Hono framework. It shows how to use the 'ipRestriction' middleware and the 'getConnInfo' helper to restrict access to the application based on IP addresses. This is a crucial aspect of securing web applications, as it allows developers to control who can access their application based on their IP address.

*Source: docs/middleware/builtin/ip-restriction.md*

### Using IP Restriction in Hono

This code snippet demonstrates how to use the IP restriction feature in Hono. It shows how to deny access to a specific IP range and how to customize the error message when access is denied.

```ts
app.use(
  '*',
  ipRestriction(
    getConnInfo,
    {
      denyList: ['192.168.2.0/24'],
    },
    async (remote, c) => {
      return c.text(`Blocking access from ${remote.addr}`, 403)
    }
  )
)
```

The `app.use` function is used to apply the IP restriction middleware to all routes (`'*'`). The `ipRestriction` function takes three arguments: the connection information function (`getConnInfo`), the IP restriction options, and an error handling function.

The IP restriction options object has a `denyList` property, which is an array of IP addresses or ranges to deny access to. In this case, all IP addresses in the range '192.168.2.0/24' are denied access.

The error handling function is called when access is denied. It takes two arguments: the remote connection information and the context object. It returns a custom error message and status code.

- The IP restriction middleware should be applied before any other middleware or routes.
- The `denyList` can contain both IPv4 and IPv6 addresses and ranges.

- [Hono documentation](https://hono.bouzuya.net/)

- Restricting access to your application based on IP address or range.
- Customizing the error message when access is denied.

**Reasoning:** This rule is important as it demonstrates how to use the IP restriction feature in Hono. It shows how to deny access to a specific IP range and how to customize the error message when access is denied.

*Source: docs/middleware/builtin/ip-restriction.md*

### Limiting Body Size in Hono POST Requests

This code demonstrates how to limit the size of the body in a POST request using the Hono web framework.

```ts
import { Hono } from 'hono'
import { bodyLimit } from 'hono/body-limit'

const app = new Hono()

app.post(
  '/upload',
  bodyLimit({
    maxSize: 50 * 1024, // 50kb
    onError: (c) => {
      return c.text('overflow :(', 413)
    },
  }),
  async (c) =>
```

The `bodyLimit` function is imported from 'hono/body-limit' and is used as middleware in the POST route. It checks the size of the body against the `maxSize` specified (in this case, 50kb). If the body size exceeds the `maxSize`, the `onError` function is executed.

- The `maxSize` is specified in bytes.
- The `onError` function should return a response to the client. In this case, it returns a text response with the message 'overflow :(' and a 413 (Payload Too Large) HTTP status code.

- [Hono Documentation](https://hono.beyondco.de/)

- Limiting the size of file uploads in a file upload route.
- Preventing large amounts of data from being sent to the server in a form submission route.

**Reasoning:** This rule is important as it demonstrates how to limit the size of the body in a POST request using the Hono web framework. This is crucial in scenarios where you want to prevent clients from sending large amounts of data to the server, which could potentially lead to server overload or other issues.

*Source: docs/middleware/builtin/body-limit.md*

### Limiting Body Size in Hono

This code snippet demonstrates how to limit the size of the body in a POST request using the Hono web framework.

```ts
const app = new Hono()

app.post(
  '/upload',
  bodyLimit({
    maxSize: 50 * 1024, // 50kb
    onError: (c) => {
      return c.text('overflow :(', 413)
    },
  }),
  async (c) => {
    const body = await c.req.parseBody()
    if (body['file'] instanceof File) {
      console.log(`Got file sized: ${body['file'].size}`)
    }
    return c.text('pass :)')
  }
)
```

In this example, the `bodyLimit` middleware is used to limit the size of the body in the POST request to 50KB. If the size of the body exceeds this limit, an error handler is executed, returning a 413 (Payload Too Large) status code and a custom error message.

This is a useful technique for preventing users from uploading files that are too large, which could potentially overload the server or take a long time to process.

- The `maxSize` option is required and specifies the maximum size of the body in bytes.
- The `onError` option is a function that is executed when the size of the body exceeds the `maxSize`.

- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)

- Limiting the size of file uploads in a file upload endpoint.

**Reasoning:** This rule is important as it demonstrates how to limit the size of the body in a POST request using the Hono web framework. This is crucial in scenarios where you want to prevent users from uploading files that are too large, which could potentially overload the server or take a long time to process.

*Source: docs/middleware/builtin/body-limit.md*

### Setting the Maximum Request Body Size in Hono and Bun

In Hono and Bun, the default maximum request body size is set to prevent denial of service (DoS) attacks. However, there may be cases where you need to accept larger requests. To do this, you need to set the `maxRequestBodySize` property.

Here is an example of how to do this:

```ts
export default {
  port: process.env['PORT'] || 3000,
  fetch: app.fetch,
  maxRequestBodySize: 1024 * 1024 * 200, // your value here
}
```

In this code snippet, the `maxRequestBodySize` is set to 200MiB. You can adjust this value according to your needs.

The `maxRequestBodySize` property sets the maximum size of the request body that Hono and Bun will accept. If a request exceeds this size, Hono and Bun will respond with a status code of `413` and terminate the connection.

- Be careful when increasing the `maxRequestBodySize`. Setting this value too high can make your application vulnerable to DoS attacks.
- The `maxRequestBodySize` is specified in bytes.

- [Hono Documentation](https://hono.bun.dev/)
- [Bun Documentation](https://bun.dev/)

- Accepting file uploads that are larger than the default maximum request body size.

**Reasoning:** This rule is important as it demonstrates how to set the maximum request body size in Hono and Bun. By default, Hono and Bun limit the size of the request body to prevent denial of service (DoS) attacks. However, in some cases, you may need to accept larger requests. This rule shows how to increase this limit.

*Source: docs/middleware/builtin/body-limit.md*

### Setting Maximum Request Body Size in Hono

This code snippet demonstrates how to set the maximum request body size in Hono. This is done using the `maxRequestBodySize` property.

```ts
Bun.serve({
  fetch(req, server) {
    return app.fetch(req, { ip: server.requestIP(req) })
  },
  maxRequestBodySize: 1024 * 1024 * 200, // your value here
})
```

The `maxRequestBodySize` property is set to the desired limit in bytes. In this example, it is set to 200MB.

- The value for `maxRequestBodySize` should be set according to the specific needs of your application.
- Be aware that setting a very high limit can potentially lead to resource exhaustion if large amounts of data are sent in a single request.

- [Hono Documentation](https://hono.bouzuya.net/)

- Limiting the size of file uploads
- Preventing large payloads from overloading the server

**Reasoning:** This rule is important as it demonstrates how to set the maximum request body size in Hono. This is crucial for controlling the amount of data that can be sent in a single request, preventing potential overflows or resource exhaustion.

*Source: docs/middleware/builtin/body-limit.md*

### Implementing Basic Authentication in Hono

This rule demonstrates how to implement basic authentication in a Hono application.

```ts
import { Hono } from 'hono'
import { basicAuth } from 'hono/basic-auth'

const app = new Hono()

app.use(
  '/auth/*',
  basicAuth({
    username: 'hono',
    password: 'acoolproject',
  })
)

app.get('/auth/page', (c) => {
  return c.text('You are authorized')
})
```

The `basicAuth` function from 'hono/basic-auth' is used as a middleware for the '/auth/*' route. This function takes an object with a username and password. Any request to '/auth/*' will need to include these credentials in the Authorization header to be successful.

- The username and password are hardcoded in this example, but in a real-world application, you would likely want to check these credentials against a database.

- [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#basic_authentication_scheme)

- Protecting routes that should only be accessible to authenticated users.

**Reasoning:** This rule is important as it demonstrates how to implement basic authentication in a Hono application. Basic authentication is a simple authentication scheme built into the HTTP protocol. The client sends HTTP requests with the Authorization header that contains the word Basic word followed by a space and a base64-encoded string username:password. For an application to be secure, it is crucial to implement some form of authentication, and this rule provides an example of how to do so using the Hono framework.

*Source: docs/middleware/builtin/basic-auth.md*

### Hono Basic Authentication with Manual User Verification

In Hono, you can manually verify user credentials using the 'verifyUser' option in the basicAuth middleware. This provides an additional layer of security and flexibility.

Here is a code snippet demonstrating this:

```ts
const app = new Hono()

app.use(
  basicAuth({
    verifyUser: (username, password, c) => {
      return (
        username === 'dynamic-user' && password === 'hono-password'
      )
    },
  })
)
```

In the above code, the 'verifyUser' function checks if the username is 'dynamic-user' and the password is 'hono-password'. If both conditions are met, the function returns true, indicating that the user is authenticated.

- The 'verifyUser' function should return a boolean value.
- The 'verifyUser' function is called with three arguments: username, password, and the context object.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Manually verifying user credentials in applications that require custom authentication logic.

**Reasoning:** This rule is important as it demonstrates how to use the 'verifyUser' option in the basicAuth middleware of Hono framework. This option allows developers to manually verify the user credentials, providing an additional layer of security and flexibility.

*Source: docs/middleware/builtin/basic-auth.md*

### Defining Multiple Users with Basic Authentication in Hono

This code snippet demonstrates how to define multiple users with basic authentication in Hono. It shows how to pass arbitrary parameters containing objects defining more `username` and `password` pairs.

```ts
app.use(
  '/auth/*',
  basicAuth(
    {
      username: 'hono',
      password: 'acoolproject',
      // Define other params in the first object
      realm: 'www.example.com',
    },
    {
      username: 'hono-admin',
      password: 'super-secure',
      // Cannot redefine other params here
    },
    {
      username: 'hono-user-1',
      password: 'a-secret',
      // Or here
    }
  )
)
```

The `basicAuth` function is used as a middleware in the application. It takes an arbitrary number of objects as arguments, each representing a user. Each object should contain a `username` and `password` pair. Other parameters can only be defined in the first object.

- Other parameters can only be defined in the first object.
- The `username` and `password` pairs are hardcoded in this example, but they can also be loaded from a configuration file or a database.

- [Hono Documentation](https://www.hono.com/docs)

- Defining multiple users for basic authentication in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to define multiple users with basic authentication in Hono. It shows how to pass arbitrary parameters containing objects defining more `username` and `password` pairs. It also highlights that other parameters can only be defined in the first object.

*Source: docs/middleware/builtin/basic-auth.md*

### Importing and Using JWT Middleware in Hono

This code demonstrates how to import and use the JWT middleware in the Hono web framework.

```ts
import { Hono } from 'hono'
import { jwt } from 'hono/jwt'
import type { JwtVariables } from 'hono/jwt'
```

1. The `Hono` object is imported from the 'hono' package. This is the main object used to create a new Hono application.
2. The `jwt` middleware is imported from 'hono/jwt'. This middleware is used to handle JWT authentication and authorization.
3. The `JwtVariables` type is imported from 'hono/jwt'. This type is used to infer the type of the JWT payload.

- The JWT middleware must be used on routes that require authentication or authorization.
- The `JwtVariables` type should be used to infer the type of the JWT payload.

- [Hono Documentation](https://hono.bayrell.org/en/)
- [JWT](https://jwt.io/introduction/)

- Protecting routes or endpoints that require user authentication or authorization.

**Reasoning:** This rule is important as it demonstrates how to import and use the JWT middleware in the Hono web framework. JWT (JSON Web Tokens) are a popular method of handling authentication and authorization in web applications. Understanding how to correctly import and utilize the JWT middleware in Hono is crucial for securing routes and endpoints in a Hono-based application.

*Source: docs/middleware/builtin/jwt.md*

### Using JWT Authentication in Hono

This code snippet demonstrates how to use JWT for authentication in Hono.

```ts
import { Hono } from 'hono'
import { jwt } from 'hono/jwt'
import type { JwtVariables } from 'hono/jwt'

type Variables = JwtVariables

const app = new Hono<{ Variables: Variables }>()

app.use(
  '/auth/*',
  jwt({
    secret: 'it-is-very-secret',
  })
)

app.get('/auth/page', (c) => {
  return c.text('You are authorized')
})
```

1. Import the necessary modules from Hono and JWT.
2. Define the JWT variables.
3. Initialize a new Hono application with the defined JWT variables.
4. Apply the JWT middleware to all routes under '/auth'.
5. Define a GET route '/auth/page' that returns a text response.

- The secret used in the JWT middleware should be kept secure and not exposed.

- [Hono JWT Documentation](https://hono.bayrell.org/docs/en/jwt)

- Protecting routes or endpoints that require authentication.
- Retrieving and using JWT payload data.

**Reasoning:** This rule is important as it demonstrates how to use JWT (JSON Web Tokens) for authentication in Hono. It shows how to import the necessary modules, define the JWT variables, apply the JWT middleware to specific routes, and how to retrieve the JWT payload.

*Source: docs/middleware/builtin/jwt.md*

### Using JWT for Authentication in Hono

This code snippet demonstrates how to use JWT (JSON Web Tokens) for authentication in Hono.

```ts
const app = new Hono()

app.use(
  '/auth/*',
  jwt({
    secret: 'it-is-very-secret',
  })
)

app.get('/auth/page', (c) => {
  const payload = c.get('jwtPayload')
  return c.json(payload) // eg: { "sub": "1234567890", "name": "John Doe", "iat": 1516239022 }
})
js
app.use('/auth/*', (c, next) => {
  const jwtMiddleware = jwt({ secret: c.env.JWT_SECRET })
  return jwtMiddleware(c, next)
})
```

- [Hono Documentation](https://hono.bayrell.org/en/)
- [JWT](https://jwt.io/)

- Protecting routes that require authentication
- Extracting user information from JWTs

#### Code Snippet

```typescript

### How it works

1. A new Hono app is created.
2. A middleware is set up for the route pattern '/auth/*'. This middleware uses the `jwt()` function to check for valid JWTs in the request. The secret used for decoding the JWT is 'it-is-very-secret'.
3. A GET route '/auth/page' is set up. In the route handler, the payload of the JWT is extracted using `c.get('jwtPayload')` and returned as a JSON response.

### Important notes

- The `jwt()` function is just a middleware function. If you want to use an environment variable (eg: `c.env.JWT_SECRET`), you can use it as follows:

```

**Reasoning:** This rule is important as it demonstrates how to use JWT (JSON Web Tokens) for authentication in Hono. It shows how to set up a middleware for a specific route pattern ('/auth/*') to check for valid JWTs, and how to extract the payload from a valid JWT.

*Source: docs/middleware/builtin/jwt.md*

### Using JWT Middleware with Environment Variable for Secret Key in Hono

This code snippet demonstrates how to use the `jwt()` middleware function in Hono with an environment variable for the secret key. This is a common practice to secure sensitive data like the secret key for JWT authentication.

```js
app.use('/auth/*', (c, next) => {
  const jwtMiddleware = jwt({
    secret: c.env.JWT_SECRET,
  })
  return jwtMiddleware(c, next)
})
```

The `jwt()` function is a middleware that is used to authenticate HTTP requests using JSON Web Tokens. In this code snippet, the `jwt()` function is used with an environment variable `c.env.JWT_SECRET` for the secret key. This is done to secure the secret key, as it is sensitive data.

- The `jwt()` function is just a middleware function. It can be used with any route.
- The secret key for the `jwt()` function should be stored securely. In this code snippet, it is stored as an environment variable.

- [Hono Documentation](https://hono.bike/docs)

- Authenticating HTTP requests using JSON Web Tokens.
- Securing sensitive data like the secret key for JWT authentication.

**Reasoning:** This rule is important as it demonstrates how to use the jwt middleware function in Hono with an environment variable for the secret key. This is a common practice to secure sensitive data like the secret key for JWT authentication.

*Source: docs/middleware/builtin/jwt.md*

### Importing and Using jsxRenderer and useRequestContext in Hono

This code demonstrates how to import and use the jsxRenderer and useRequestContext functions from the Hono framework.

```ts
import { Hono } from 'hono'
import { jsxRenderer, useRequestContext } from 'hono/jsx-renderer'
```

1. The jsxRenderer function allows you to render JSX components directly in the c.render() function, without the need for using c.setRenderer().
2. The useRequestContext function enables access to instances of Context within components.

- The jsxRenderer and useRequestContext functions are imported from 'hono/jsx-renderer', not 'hono'.

- [Hono Documentation](https://hono.bayfrontcloud.com/)

- Rendering JSX components in a Hono application.
- Accessing context within components in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to use the jsxRenderer and useRequestContext functions from the Hono framework. The jsxRenderer function allows you to render JSX components directly in the c.render() function, without the need for using c.setRenderer(). The useRequestContext function enables access to instances of Context within components. Understanding this rule is crucial for rendering JSX components and accessing context in a Hono application.

*Source: docs/middleware/builtin/jsx-renderer.md*

### Using jsxRenderer in Hono

This rule demonstrates how to use the jsxRenderer in the Hono framework to render JSX components.

```jsx
import { Hono } from 'hono'
import { jsxRenderer, useRequestContext } from 'hono/jsx-renderer'

const app = new Hono()

app.get(
  '/page/*',
  jsxRenderer(({ children }) => {
    return (
      <html>
        <body>
          <header>Menu</header>
          <div>{children}</div>
        </body>
      </html>
    )
  })
)

app.get('/page/about', (c) => {
  return c.render(<h1>About me!</h1>)
})
```

1. First, the Hono and jsxRenderer modules are imported.
2. A new Hono application is created.
3. The jsxRenderer is used to define a route handler for '/page/*'. This handler returns a JSX component.
4. Another route handler is defined for '/page/about'. This handler uses the context's render method to return a JSX component.

- The jsxRenderer allows for the use of JSX in Hono, which is not natively supported.
- The 'useRequestContext' function can be used to access the context within components.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Building dynamic web applications with Hono.
- Using JSX to define route handlers in Hono.

**Reasoning:** This rule is important as it demonstrates how to use the jsxRenderer in the Hono framework to render JSX components. It also shows how to use the 'useRequestContext' function to access the context within components. This is crucial for building dynamic web applications with Hono.

*Source: docs/middleware/builtin/jsx-renderer.md*

### Using the 'docType' option in jsxRenderer

This code snippet demonstrates how to use the 'docType' option in the jsxRenderer function of the Hono framework.

```tsx
app.use(
  '*',
  jsxRenderer(
    ({ children }) => {
      return (
        <html>
          <body>{children}</body>
        </html>
      )
    },
    { docType: false }
  )
)
```

In this example, the 'docType' option is set to 'false', which means that a DOCTYPE will not be added at the beginning of the HTML.

The jsxRenderer function takes two arguments: a render function and an options object. The render function is used to generate the HTML content, and the options object can be used to control various aspects of the rendering process, including the document type declaration.

- The 'docType' option can be set to 'false' to prevent a DOCTYPE from being added, or it can be set to a string to specify a particular DOCTYPE.

- [Hono documentation](https://hono.bokuweb.me/)

- When you want to control the document type declaration for the rendered HTML.

**Reasoning:** This rule is important as it demonstrates how to use the 'docType' option in the jsxRenderer function of the Hono framework. This option allows developers to control whether a DOCTYPE is added at the beginning of the HTML or not, and if so, what type of DOCTYPE to add. This can be useful in cases where the developer wants to control the document type declaration for the rendered HTML.

*Source: docs/middleware/builtin/jsx-renderer.md*

### Using 'stream' option in jsxRenderer for Streaming Responses in Hono

This rule demonstrates how to use the 'stream' option in the jsxRenderer function in Hono framework to render a streaming response. It also shows how to create an asynchronous component and how to use the Suspense component for fallback UI during loading.

```tsx
const AsyncComponent = async () => {
  await new Promise((r) => setTimeout(r, 1000)) // sleep 1s
  return <div>Hi!</div>
}

app.get(
  '*',
  jsxRenderer(
    ({ children }) => {
      return (
        <html>
          <body>
            <h1>SSR Streaming</h1>
            {children}
          </body>
        </html>
      )
    },
    { stream: true }
  )
)

app.get('/', (c) => {
  return c.render(
    <Suspense fallback={<div>loading...</div>}>
      <AsyncComponent />
    </Suspense>
  )
})
ts
{
  'Transfer-Encoding': 'chunked',
  'Content-Type': 'text/html; charset=UTF-8',
  'Content-Encoding': 'Identity'
}
```

- [Hono jsxRenderer documentation](https://hono.bayfront.cloud/Reference/Server/builtin/jsx-renderer)

- When you want to render a streaming response in your Hono application.
- When you want to provide a fallback UI while an asynchronous component is loading.

#### Code Snippet

```typescript

### How it works:

1. An asynchronous component 'AsyncComponent' is created which returns a div element after a delay of 1 second.
2. The jsxRenderer function is used with the 'stream' option set to true to render a streaming response.
3. The Suspense component is used to provide a fallback UI (loading...) while the AsyncComponent is loading.

### Important notes:

When the 'stream' option is set to true, the following headers are added:

```

**Reasoning:** This rule is important as it demonstrates how to use the 'stream' option in the jsxRenderer function in Hono framework to render a streaming response. It also shows how to create an asynchronous component and how to use the Suspense component for fallback UI during loading.

*Source: docs/middleware/builtin/jsx-renderer.md*

### Rendering JSX, Setting Headers and Using Nested Layouts in Hono

In Hono, you can render JSX components using the `render` method. If you have components that might take some time to render, you can use the `Suspense` component to display a fallback content until the component is ready. Here is an example:

```ts
app.get('/', (c) => {
  return c.render(
    <Suspense fallback={<div>loading...</div>}>
      <AsyncComponent />
    </Suspense>
  )
})
ts
{
  'Transfer-Encoding': 'chunked',
  'Content-Type': 'text/html; charset=UTF-8',
  'Content-Encoding': 'Identity'
}
tsx
app.use(
  jsxRenderer(({ children }) => {
    re
```

- [Hono Documentation](https://hono.bayfront.cloud/)

- Rendering JSX components in Hono
- Setting headers for the response
- Using nested layouts in Hono

#### Code Snippet

```typescript

When rendering the JSX, Hono can also set certain headers for the response. By default, if `true` is set, the following headers are added:

```

**Reasoning:** This rule is important as it demonstrates how to render JSX components in Hono using the Suspense and AsyncComponent. It also shows how to set headers for the response and how to use the Layout component for nested layouts. Understanding this rule is crucial for managing asynchronous operations and improving the user experience during data fetching or code splitting, as well as for structuring the application layout in a nested manner.

*Source: docs/middleware/builtin/jsx-renderer.md*

### Creating Nested Layouts with jsxRenderer in Hono

This rule demonstrates how to use the jsxRenderer in Hono to create nested layouts. The jsxRenderer is a middleware that allows you to use JSX syntax in your Hono applications.

Here is the code snippet:

```tsx
app.use(
  jsxRenderer(({ children }) => {
    return (
      <html>
        <body>{children}</body>
      </html>
    )
  })
)

const blog = new Hono()
blog.use(
  jsxRenderer(({ children, Layout }) => {
    return (
      <Layout>
        <nav>Blog Menu</nav>
        <div>{children}</div>
      </Layout>
    )
  })
)

app.route('/blog', blog)
```

In this snippet, the jsxRenderer is used to create a layout for the application. The children prop is used to render the nested components inside the layout. The Layout component is used to wrap the nested components, creating a nested structure.

Important notes:

- The jsxRenderer is a middleware, so it should be used with the app.use() method.
- The children and Layout props are standard in React and JSX-based frameworks, and they are used to create nested structures.

Common use cases:

- Creating complex UI structures in a modular and reusable way.
- Using JSX syntax in Hono applications.

**Reasoning:** This rule is important as it demonstrates how to use the jsxRenderer in Hono for creating nested layouts. It shows how to use the children and Layout props to create a nested structure of components, which is a common pattern in React and JSX-based frameworks. This pattern is useful for creating complex UI structures in a modular and reusable way.

*Source: docs/middleware/builtin/jsx-renderer.md*

### Using `useRequestContext()` in Hono to Access Request Context within JSX Components

The `useRequestContext()` function in Hono allows you to access the request context within a JSX component. This is useful when you need to display or use request-specific data within your components.

Here is a code snippet demonstrating its usage:

```tsx
import { useRequestContext, jsxRenderer } from 'hono/jsx-renderer'

const app = new Hono()
app.use(jsxRenderer())

const RequestUrlBadge: FC = () => {
  const c = useRequestContext()
  return <b>{c.req.url}</b>
}

app.get('/page/info', (c) => {
  return c.render(
    <div>
      You are accessing: <RequestUrlBadge />
    </div>
  )
})
```

In this example, `useRequestContext()` is used within the `RequestUrlBadge` component to access the request URL. This URL is then displayed within a bold (`<b>`) HTML element.

Note: You can't use `useRequestContext()` with the Deno's `precompile` JSX option. Use the `react-jsx` instead.

Common use cases for this function include displaying the request URL, path, headers, or other request-specific data within your components.

**Reasoning:** This rule is important as it demonstrates how to use the `useRequestContext()` function in Hono to access the request context within a JSX component. This is useful when you need to display or use request-specific data within your components.

*Source: docs/middleware/builtin/jsx-renderer.md*

### Setting Up JSX Configuration in Hono Framework

In Hono framework, the JSX configuration is set in the compiler options. It is important to use 'react-jsx' instead of 'precompile' for JSX. This is because 'useRequestContext()' cannot be used with Deno's 'precompile' JSX option.

Here is the correct configuration:

```json
"compilerOptions": {
     "jsx": "react-jsx",
     "jsxImportSource": "hono/jsx"
   }
 }
```

The 'jsx' option in the compiler options is set to 'react-jsx'. This allows the use of 'useRequestContext()' in Hono.

The 'jsxImportSource' option is set to 'hono/jsx'. This specifies the module to be used as the source of JSX-related functions.

- 'useRequestContext()' cannot be used with Deno's 'precompile' JSX option.
- Always use 'react-jsx' for JSX in Hono.

- [Hono Documentation](https://hono.bayfront.io/)

- Setting up JSX configuration in Hono framework.

**Reasoning:** This rule is important as it demonstrates the correct JSX configuration for Hono framework. It shows how to set up the compiler options to use 'react-jsx' instead of 'precompile' for JSX. This is crucial because 'useRequestContext()' cannot be used with Deno's 'precompile' JSX option.

*Source: docs/middleware/builtin/jsx-renderer.md*

### Using ContextRenderer to Pass Additional Content to the Renderer in Hono

This rule demonstrates how to use the `ContextRenderer` interface in Hono to pass additional content to the renderer. This is particularly useful when you want to modify the contents of the head tag depending on the page.

Here is the code snippet:

```tsx
declare module 'hono' {
  interface ContextRenderer {
    (
      content: string | Promise<string>,
      props: { title: string }
    ): Response
  }
}

const app = new Hono()

app.get(
  '/page/*',
  jsxRenderer(({ children, title }) => {
    return (
      <html>
        <head>
          <title>{title}</title>
        </head>
        <body>
          <header>Menu</header>
          <div>{children}</div>
        </body>
      </html>
    )
  })
)

app.get('/page/favorites', (c) => {
  return c.render(
    <div>
      <ul>
        <li>Eating sushi</li>
        <li>Watching baseball games</li>
      </ul>
    </div>,
    {
      title: 'My favorites',
    }
  )
})
```

1. The `ContextRenderer` interface is declared with a function that takes a content (which can be a string or a Promise that resolves to a string) and a props object with a title property.
2. The `jsxRenderer` function is used in the `app.get` method to return a JSX element.
3. The `render` method is used in another `app.get` method to render a JSX element with specific properties.

- The `ContextRenderer` interface allows you to pass additional content to the renderer, which can be useful for modifying the contents of the head tag depending on the page.
- The `jsxRenderer` function and the `render` method are used to render JSX elements.

- [Hono Documentation](https://hono.bayfront.io/)

- Modifying the contents of the head tag depending on the page
- Rendering JSX elements with specific properties

**Reasoning:** This rule is important as it demonstrates how to use the ContextRenderer interface in Hono to pass additional content to the renderer. This is particularly useful when you want to modify the contents of the head tag depending on the page. The rule also shows how to use the jsxRenderer function to return a JSX element and how to use the render method to render a JSX element with specific properties.

*Source: docs/middleware/builtin/jsx-renderer.md*

### Using Pretty JSON Middleware in Hono

Pretty JSON middleware in Hono enables '_JSON pretty print_' for JSON response body. By simply adding `?pretty` to the URL query param, the JSON strings are prettified.

Here is an example:

```js
// GET /
{"project":{"name":"Hono","repository":"https://github.com/honojs/hono"}}
js
// GET /?pretty
{
  "project": {
    "name": "Hono",
    "repository": "https://github.com/honojs/hono"
  }
}
```

The Pretty JSON middleware intercepts the JSON response and formats it in a more readable way if the `?pretty` query parameter is present in the URL.

- The Pretty JSON middleware should be used judiciously as it adds overhead to the response time, especially for large JSON objects.

- [Hono Documentation](https://github.com/honojs/hono)

- Debugging: The Pretty JSON middleware can be very useful during development and debugging when you need to inspect the JSON response.
- API Documentation: It can also be used in API documentation to present the JSON response in a more readable way.

#### Code Snippet

```typescript

When the `?pretty` query parameter is added to the URL, the JSON response will be prettified:

```

**Reasoning:** This rule is important as it demonstrates how to use the Pretty JSON middleware in Hono to enable JSON pretty print for JSON response body. This is useful for improving the readability of JSON responses, especially when dealing with large and complex JSON objects.

*Source: docs/middleware/builtin/pretty-json.md*

### Prettifying JSON Responses in Hono

In Hono, you can use the 'prettyJSON' function to format JSON responses. This can be done by adding '?pretty' to the URL query parameter. The JSON strings will then be formatted in a more readable way.

Here is an example of how to use it:

```ts
import { Hono } from 'hono'
import { prettyJSON } from 'hono/pretty-json'

const app = new Hono()

app.use(prettyJSON()) // With options: prettyJSON({ space: 4 })
js
// GET /?pretty
{
  "project": {
    "name": "Hono",
    "repository": "https://github.com/honojs/hono"
  }
}
```

This feature can be particularly useful during debugging or when presenting data to end users.

- The 'prettyJSON' function is part of the 'hono/pretty-json' package, so make sure to import it before using it.
- You can customize the amount of space used for indentation by passing an object with a 'space' property to the 'prettyJSON' function. The default value is 2.

- [Hono Documentation](https://honojs.com/docs)

- Debugging: Prettifying JSON can make it easier to spot errors or inconsistencies in the data.
- User interface: If you're presenting JSON data directly to the end user, prettifying it can make it more readable and user-friendly.

#### Code Snippet

```typescript

And here is an example of the result:

```

**Reasoning:** This rule is important as it demonstrates how to use the 'prettyJSON' function in Hono to format JSON responses for better readability. By adding '?pretty' to the URL query parameter, the JSON strings are formatted in a more readable way, which can be particularly useful during debugging or when presenting data to end users.

*Source: docs/middleware/builtin/pretty-json.md*

### Using prettyJSON Middleware in Hono

This code snippet demonstrates how to use the 'prettyJSON' middleware in Hono to format JSON responses.

```ts
import { Hono } from 'hono'
import { prettyJSON } from 'hono/pretty-json'

const app = new Hono()

app.use(prettyJSON()) // With options: prettyJSON({ space: 4 })
app.get('/', (c) => {
  return c.json({ message: 'Hono!' })
})
```

1. Import the 'Hono' and 'prettyJSON' modules from the 'hono' package.
2. Create a new Hono application.
3. Use the 'prettyJSON' middleware in the Hono application. You can optionally pass an options object to the 'prettyJSON' function to customize the formatting. For example, 'prettyJSON({ space: 4 })' will use 4 spaces for indentation.
4. Define a GET route that returns a JSON response.

- The 'prettyJSON' middleware should be used before defining the routes that return JSON responses.

- [Hono Documentation](https://github.com/honojs/hono)

- Improving the readability of JSON responses during development and debugging.

**Reasoning:** This rule is important as it demonstrates how to use the 'prettyJSON' middleware in Hono to format JSON responses. This is useful for improving the readability of JSON responses, especially during development and debugging.

*Source: docs/middleware/builtin/pretty-json.md*

### Using Request ID Middleware in Hono

This code demonstrates how to import and use the Request ID Middleware in Hono. The Request ID Middleware generates a unique ID for each request, which can be used in handlers and middleware.

```ts
import { Hono } from 'hono'
import { requestId } from 'hono/request-id'
```

After importing, you can use the Request ID Middleware in your Hono application. You can access the Request ID through the `requestId` variable in the handlers and middleware to which the Request ID Middleware is applied.

This feature is useful for tracking requests and debugging. It can also be used to log request data, correlate logs for specific requests, and more.

- [Hono Documentation](https://hono.bosch.io/docs/)

- Tracking requests
- Debugging
- Logging request data
- Correlating logs for specific requests

**Reasoning:** This rule is important as it demonstrates how to import and use the Request ID Middleware in Hono. The Request ID Middleware generates a unique ID for each request, which can be used in handlers and middleware. This is useful for tracking requests and debugging.

*Source: docs/middleware/builtin/request-id.md*

### Using RequestIdVariables for Type Safety in Hono

This code snippet demonstrates how to use the 'RequestIdVariables' type in Hono to explicitly specify the type of variables. This is crucial for type safety and ensuring that the correct data types are used throughout the application.

```ts
import type { RequestIdVariables } from 'hono/request-id'

const app = new Hono<{
  Variables: RequestIdVariables
}>()
```

1. The 'RequestIdVariables' type is imported from 'hono/request-id'.
2. A new Hono application is set up, with the 'Variables' type explicitly set to 'RequestIdVariables'.

- This is a good practice for ensuring type safety in your Hono application.

- [Hono Documentation](https://hono.bevry.me/)

- When setting up a new Hono application and you want to ensure type safety.

**Reasoning:** This rule is important as it demonstrates how to use the 'RequestIdVariables' type in Hono to explicitly specify the type of variables. It also shows how to set up a new Hono application with these variables. This is crucial for type safety and ensuring that the correct data types are used throughout the application.

*Source: docs/middleware/builtin/request-id.md*

### Using Bearer Authentication in Hono

This code demonstrates how to use bearer authentication in Hono. Bearer authentication is a common method used in APIs to authenticate HTTP requests.

```sh
curl -H 'Authorization: Bearer honoiscool' http://localhost:8787/auth/page
```

In this example, 'honoiscool' is the bearer token. This token is added in the 'Authorization' header of the HTTP request.

The HTTP client adds the 'Authorization' header with 'Bearer {token}' as the header value in the request. The server then verifies this token to authenticate the request.

Your `token` must match the regex `/[A-Za-z0-9._~+/-]+=*/`, otherwise a 400 error will be returned.

- [Hono Documentation](https://www.eclipse.org/hono/docs/)

This method is commonly used when you want to authenticate HTTP requests in your Hono application.

**Reasoning:** This rule is important as it demonstrates how to use bearer authentication in Hono. Bearer authentication is a common method used in APIs to authenticate HTTP requests. The rule shows how to add the 'Authorization' header with 'Bearer {token}' as the header value in the request.

*Source: docs/middleware/builtin/bearer-auth.md*

### Importing and Using Bearer Authentication in Hono

This code snippet demonstrates how to import and use the 'bearerAuth' module from the Hono framework for handling Bearer token authentication.

```ts
import { Hono } from 'hono'
import { bearerAuth } from 'hono/bearer-auth'
```

1. The 'Hono' object is imported from the 'hono' package. This is the main object that is used to interact with the Hono framework.
2. The 'bearerAuth' module is imported from 'hono/bearer-auth'. This module provides functionality for handling Bearer token authentication.

Your `token` must match the regex `/[A-Za-z0-9._~+/-]+=*/`, otherwise a 400 error will be returned. Notably, this regex accommodates both URL-safe Base64 and standard Base64.

- Hono Documentation: [https://hono.bjss.com/docs](https://hono.bjss.com/docs)

- Securing endpoints with Bearer token authentication.
- Validating Bearer tokens in requests.

**Reasoning:** This rule is important as it demonstrates how to import and use the 'bearerAuth' module from the Hono framework for handling Bearer token authentication. It is a common practice in web development to secure endpoints using Bearer token authentication, and this rule provides a clear example of how to implement this in Hono.

*Source: docs/middleware/builtin/bearer-auth.md*

### Bearer Token Authentication in Hono

This code snippet demonstrates how to implement bearer token authentication in Hono. It shows how to restrict access to specific routes and methods using a bearer token.

```ts
const app = new Hono()

const token = 'honoiscool'

app.use('/api/*', bearerAuth({ token }))

app.get('/api/page', (c) => {
  return c.json({ message: 'You are authorized' })
})
```

1. A new Hono application is created.
2. A bearer token is defined.
3. The `app.use` method is used to apply the `bearerAuth` middleware to all routes starting with '/api/'. This middleware checks if the request contains the correct bearer token.
4. If the request contains the correct bearer token, the user is authorized and can access the '/api/page' route.

- The `bearerAuth` middleware does not require the bearer token to be a JWT, just that it matches the above regex.
- This code snippet does not handle the case where the request does not contain a bearer token or contains an incorrect bearer token. In a real application, you would need to handle these cases and return appropriate error responses.

- [Hono Documentation](https://hono.bike/)

- Restricting access to certain routes in your application.
- Implementing token-based authentication.

**Reasoning:** This rule is important as it demonstrates how to implement bearer token authentication in Hono. It shows how to restrict access to specific routes and methods using a bearer token. This is crucial for securing your application and ensuring that only authorized users can access certain parts of your application.

*Source: docs/middleware/builtin/bearer-auth.md*

### Implementing Bearer Token Authentication in Hono

This code snippet demonstrates how to implement bearer token authentication in Hono. It shows how to restrict access to specific routes and methods using a token, and how to implement multiple tokens for different levels of access.

```ts
const app = new Hono()

const token = 'honoiscool'

app.get('/api/page', (c) => {
  return c.json({ message: 'Read posts' })
})

app.post('/api/page', bearerAuth({ token }), (c) => {
  return c.json({ message: 'Created post!' }, 201)
})
```

The `bearerAuth` middleware is used to restrict access to the POST route. It checks if the request includes the correct bearer token in the Authorization header. If the token is correct, the request is allowed to proceed. If not, the request is rejected.

- The `bearerAuth` middleware should be used on any routes that require authentication.
- The token should be kept secret and secure.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Restricting access to certain routes or methods to authenticated users.
- Implementing different levels of access using multiple tokens.

**Reasoning:** This rule is important as it demonstrates how to implement bearer token authentication in Hono. It shows how to restrict access to specific routes and methods using a token, and how to implement multiple tokens for different levels of access.

*Source: docs/middleware/builtin/bearer-auth.md*

### Implementing Multiple Tokens for Different Access Levels in Hono

This code snippet demonstrates how to implement multiple tokens for different levels of access in Hono. It shows how to restrict certain HTTP methods to a privileged token, while allowing read access to any valid token.

```ts
const app = new Hono()

const readToken = 'read'
const privilegedToken = 'read+write'
const privilegedMethods = ['POST', 'PUT', 'PATCH', 'DELETE']

app.on('GET', '/api/page/*', async (c, next) => {
  // List of valid tokens
  const bearer = bearerAuth({ token: [readToken, privilegedToken] })
  return bearer(c, next)
})
app.on(privilegedMethods, '/api/page/*', async (c, next) => {
  // Single valid privileged token
  const bearer = bearerAuth({ token: privilegedToken })
  return bearer(c, next)
})

// Define handlers for GET, POST, etc.
```

The `app.on` method is used to define handlers for different HTTP methods and paths. The `bearerAuth` function is used to authenticate the request using the provided tokens.

- The `bearerAuth` function takes an object with a `token` property, which can be a single token or an array of tokens.
- The `privilegedMethods` array contains the HTTP methods that require the privileged token.

- [Hono Documentation](https://hono.bevry.me/)

- Implementing different levels of access in a web application
- Restricting certain actions to privileged users

**Reasoning:** This rule is important as it demonstrates how to implement multiple tokens for different levels of access in Hono. It shows how to restrict certain HTTP methods to a privileged token, while allowing read access to any valid token. This is crucial for maintaining security and access control in web applications.

*Source: docs/middleware/builtin/bearer-auth.md*

### Using Bearer Token Authentication in Hono

This code snippet demonstrates how to use the `bearerAuth` middleware in Hono to authenticate requests using bearer tokens. It also shows how to define a custom token verification function.

```ts
const app = new Hono()

app.use(
  '/auth-verify-token/*',
  bearerAuth({
    verifyToken: async (token, c) => {
      return token === 'dynamic-token'
    },
  })
)
```

In this example, the `verifyToken` function checks if the provided token equals the string 'dynamic-token'. If it does, the function returns `true`, indicating that the token is valid.

The `bearerAuth` middleware intercepts incoming requests and checks the Authorization header for a bearer token. If a token is found, it is passed to the `verifyToken` function for validation.

- The `verifyToken` function should return a boolean indicating whether the token is valid or not.

- [Hono Documentation](https://hono.bevry.me/)

- Protecting routes or endpoints that require authentication.
- Implementing custom logic for token validation.

**Reasoning:** This rule is important as it demonstrates how to use the bearerAuth middleware in Hono to authenticate requests using bearer tokens. It shows how to define a custom token verification function, which is useful when you need to implement custom logic for token validation, such as checking the token against a dynamic value or a database.

*Source: docs/middleware/builtin/bearer-auth.md*

### Importing and Using Combine Functions in Hono

In Hono, the `combine` module provides three functions that control the execution of middleware: `some`, `every`, and `except`.

```ts
import { Hono } from 'hono'
import { some, every, except } from 'hono/combine'
```

- `some` runs only one of the given middleware.
- `every` runs all given middleware.
- `except` runs all given middleware only if a condition is not met.

These functions are used to create complex access control rules and other logic in your Hono application.

- [Hono Documentation](https://hono.bevry.me/)

- Restricting access to certain routes based on user roles or permissions.
- Running specific middleware only under certain conditions.

**Reasoning:** This rule is important as it demonstrates how to import and use the combine functions from the Hono web framework. These functions are used to control the execution of middleware in the application, allowing for more complex logic and control flow.

*Source: docs/middleware/builtin/combine.md*

### Using Combine Middleware in Hono for Complex Access Control Rules

This code snippet demonstrates how to use the 'combine' middleware in Hono to create complex access control rules. It shows the usage of 'some' and 'every' functions to combine different middleware functions.

```ts
import { Hono } from 'hono'
import { bearerAuth } from 'hono/bearer-auth'
import { getConnInfo } from 'hono/cloudflare-workers'
import { every, some } from 'hono/combine'
import { ipRestriction } from 'hono/ip-restriction'
import { rateLimit } from '@/my-rate-limit'

const app = new Hono()

app.use(
  '*',
  some(
    every(
      ipRestriction(getConnInfo, { allowList: ['192.168.0.2'] }),
      bearerAuth({ token })
    ),
    // If both conditions are met, rateLimit will not execute.
    rateLimit()
  )
)

app.get('/', (c) => c.text('Hello Hono!'))
```

In this code:
- 'some' function runs the first middleware that returns true. Middleware is applied in order, and if any middleware exits successfully, subsequent middleware will not run.
- 'every' function runs all middleware and requires all to return true.

This pattern is useful when you want to apply multiple conditions for a route and want either all or some of them to be met.

**Reasoning:** This rule is important as it demonstrates how to use the 'combine' middleware in Hono to create complex access control rules. It shows how to use the 'some' and 'every' functions to combine different middleware functions and create a rule that requires either all or some conditions to be met.

*Source: docs/middleware/builtin/combine.md*

### Controlling Middleware Execution with 'some' in Hono

This code demonstrates how to use the 'some' function from Hono's 'combine' module to control the execution of middleware in a Hono application. The 'some' function runs the first middleware that returns true, and if any middleware exits successfully, subsequent middleware will not run.

```ts
import { some } from 'hono/combine'
import { bearerAuth } from 'hono/bearer-auth'
import { myRateLimit } from '@/rate-limit'

// If client has a valid token, skip rate limiting.
// Otherwise, apply rate limiting.
app.use(
  '/api/*',
  some(bearerAuth({ token }), myRateLimit({ limit: 100 }))
)
```

In this example, if the 'bearerAuth' middleware function returns true (indicating that the client has a valid token), the 'myRateLimit' middleware function will not run, effectively skipping rate limiting for clients with a valid token.

- The order of middleware functions passed to 'some' matters, as they are applied in order.
- The 'some' function is part of Hono's 'combine' module, which provides functions for controlling middleware execution.

- [Hono Documentation](https://hono.bjacobel.com/docs)

- Conditionally applying middleware based on the result of a previous middleware function.
- Skipping certain middleware functions for specific requests or clients.

**Reasoning:** This rule is important as it demonstrates how to use the 'some' function from Hono's 'combine' module to control the execution of middleware in a Hono application. It shows how to conditionally apply middleware based on the result of a previous middleware function, in this case, skipping rate limiting if the client has a valid token.

*Source: docs/middleware/builtin/combine.md*

### Controlling Middleware Execution with 'some' and 'every' in Hono

This code snippet demonstrates how to use the 'some' and 'every' functions from Hono's 'combine' module to control the execution of middleware.

```ts
import { some, every } from 'hono/combine'
import { bearerAuth } from 'hono/bearer-auth'
import { myCheckLocalNetwork } from '@/check-local-network'
import { myRateLimit } from '@/rate-limit'

// If client is in local network, skip authentication and rate limiting.
// Otherwise, apply authentication and rate limiting.
app.use(
  '/api/*',
  some(
    myCheckLocalNetwork(),
    every(bearerAuth({ token }), myRateLimit({ limit: 100 }))
  )
)
```

The 'some' function runs the provided middleware until one of them does not throw an error. In this case, it first checks if the client is in the local network. If it is, the 'every' function is not executed.

The 'every' function runs all the provided middleware in order and stops if any of them throw an error. In this case, it applies the 'bearerAuth' and 'myRateLimit' middleware.

- The order of middleware in the 'every' function matters. If the 'bearerAuth' middleware throws an error, the 'myRateLimit' middleware will not run.

- [Hono documentation](https://hono.bjss.com/docs)

- Conditionally applying middleware based on the result of a check function
- Controlling the order and execution of middleware

**Reasoning:** This rule is important as it demonstrates how to use the 'some' and 'every' functions from Hono's 'combine' module to control the execution of middleware. It shows how to conditionally apply middleware based on the result of a check function. This is useful for applying different middleware under different conditions, improving the flexibility and control of the application.

*Source: docs/middleware/builtin/combine.md*

### Excluding Routes from Middleware Application in Hono

This code snippet demonstrates how to use the 'except' function from Hono's 'combine' module to exclude certain routes from middleware application. In this case, it's used to bypass authentication for public API routes.

```ts
import { except } from 'hono/combine'
import { bearerAuth } from 'hono/bearer-auth'

// If client is accessing public API, skip authentication.
// Otherwise, require a valid token.
app.use('/api/*', except('/api/public/*', bearerAuth({ token })))
```

The 'except' function takes two arguments: a condition and a middleware function. If the condition is met (in this case, if the route matches '/api/public/*'), the middleware function is not applied. This allows for selective application of middleware based on the route.

- The condition can be a string or a function.
- If multiple targets need to be matched, pass them as an array.

- [Hono documentation](https://hono.bouzuya.net/)

- Bypassing authentication for public API routes
- Applying specific middleware only to certain routes

**Reasoning:** This rule is important as it demonstrates how to use the 'except' function from Hono's 'combine' module to exclude certain routes from middleware application. In this case, it's used to bypass authentication for public API routes. This is a common use case in web development where certain routes are public and do not require authentication, while others do.

*Source: docs/middleware/builtin/combine.md*

### Implementing CORS in Hono using Middleware

This code snippet demonstrates how to implement Cross-Origin Resource Sharing (CORS) in Hono using middleware.

```ts
import { Hono } from 'hono'
import { cors } from 'hono/cors'

const app = new Hono()

// CORS should be called before the route
app.use('/api/*', cors())
app.use(
  '/api2/*',
  cors({
    origin: 'http://example.com',
    allowHeaders: ['X-Custom-Header']
  })
)
```

1. Import the necessary modules from Hono.
2. Create a new Hono application.
3. Use the `app.use()` function to apply the CORS middleware to specific routes.

- The CORS middleware should be called before defining the route.
- You can customize the CORS configuration by passing an options object to the `cors()` function.

- [Hono Documentation](https://hono.beyondco.de/)

- Building APIs that need to be accessed from different origins.
- Implementing web security measures in your Hono application.

**Reasoning:** This rule is important as it demonstrates how to implement Cross-Origin Resource Sharing (CORS) in Hono using middleware. CORS is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated. It's a crucial aspect of web security and is necessary when building APIs that are accessed from different origins.

*Source: docs/middleware/builtin/cors.md*

### Implementing CORS in Hono

This code snippet demonstrates how to implement Cross-Origin Resource Sharing (CORS) in Hono using middleware.

```ts
import { Hono } from 'hono'
import { cors } from 'hono/cors'

const app = new Hono()

// CORS should be called before the route
app.use('/api/*', cors())
app.use(
  '/api2/*',
  cors({
    origin: 'http://example.com',
    allowHeaders: ['X-Custom-Header', 'Upgrade-Insecure-Requests'],
    allowMethods: ['POST', 'GET', 'OPTIONS'],
    exposeHeaders: ['Content-Length', 'X-Kuma-Revision'],
    maxAge: 600,
    credentials: true,
  })
)

app.all('/api/abc', (c) => {
  return c.json({ success: true })
})
app.all('/api2/abc', (c) => {
  return c.json({ success: true })
})
```

The `cors()` function is used as middleware in the application. It should be called before the route that needs to implement CORS. The function takes an optional configuration object where you can specify the origin, allowed headers, allowed methods, exposed headers, max age for the preflight request, and whether credentials are included in the requests.

- The `cors()` function should be called before the route.
- The configuration object passed to the `cors()` function is optional.

- [Hono Documentation](https://hono.beyondx.io/docs)

- Implementing CORS in APIs that are accessed from different origins.

**Reasoning:** This rule is important as it demonstrates how to implement Cross-Origin Resource Sharing (CORS) in Hono using middleware. CORS is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated. It's a crucial aspect of web security and is necessary when building APIs that are accessed from different origins.

*Source: docs/middleware/builtin/cors.md*

### Setting Up CORS in Hono

This code snippet demonstrates how to set up Cross-Origin Resource Sharing (CORS) in Hono.

```ts
app.use(
  '/api3/*',
  cors({
    origin: ['https://example.com', 'https://example.com'],
  })
)

// Or you can use "function"
app.use(
  '/api4/*',
  cors({
    // `c` is a `Context` object
    origin: (origin, c) => {
      return origin.endsWith('.example.com')
        ? origin
        : 'http://example.com'
    },
  })
)
```

The `app.use` function is used to set up middleware functions in Hono. In this case, it's being used to set up CORS. The `cors` function takes an options object, which can include an `origin` property. This property can be a string, an array of strings, or a function that returns a string. The value(s) represent the domain(s) that are allowed to access the server's resources.

- The `origin` function receives two arguments: the origin of the request and the context object. You can use this function to dynamically determine the allowed origin.

- [Hono Documentation](https://hono.bayrell.org/en/latest/)

- Allowing specific trusted domains to access your server's resources.
- Dynamically determining the allowed origin based on the request.

**Reasoning:** This rule is important as it demonstrates how to set up Cross-Origin Resource Sharing (CORS) in Hono. CORS is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated. It's a crucial aspect of web security and is essential for any server serving resources to clients on different domains.

*Source: docs/middleware/builtin/cors.md*

### Using CORS Middleware in Hono

This code snippet demonstrates how to use CORS middleware in Hono framework. CORS (Cross-Origin Resource Sharing) is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated.

```ts
app.use('*', async (c, next) => {
  const corsMiddlewareHandler = cors({
    origin: c.env.CORS_ORIGIN,
  })
  return corsMiddlewareHandler(c, next)
})
```

The `app.use` function is used to apply the CORS middleware to every route (`*`). The middleware is configured with an origin that is retrieved from the environment variables (`c.env.CORS_ORIGIN`). This allows for flexibility as the origin can be easily changed depending on the environment the application is running in.

- The CORS middleware should be applied before any other middleware that needs to be protected.
- The origin should be a trusted domain to prevent potential security risks.

- [CORS on MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)

- Protecting routes that serve sensitive data.
- Allowing cross-origin requests in development environment.

**Reasoning:** This rule is important as it demonstrates how to use CORS middleware in Hono framework. CORS (Cross-Origin Resource Sharing) is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated. It's a crucial aspect of web security and should be properly implemented in any web application.

*Source: docs/middleware/builtin/cors.md*

### Using CSRF Protection Middleware in Hono

This code demonstrates how to use the CSRF protection middleware in Hono.

```ts
import { Hono } from 'hono'
import { csrf } from 'hono/csrf'

const app = new Hono()

app.use(csrf())

// Specifying origins with using `origin` option
// string
app.use(csrf({ origin: 'myapp.example.com' }))

// string[]
app.use(
  csrf({
```

1. Import the 'Hono' and 'csrf' modules.
2. Create a new Hono application.
3. Use the 'csrf' middleware in the application.
4. Specify the origins using the 'origin' option if necessary.

- In environments where browsers do not send 'Origin' headers, or environments that use reverse proxies to remove 'Origin' headers, use the 'origin' option to specify the origins.

- [Hono CSRF Middleware](https://hono.beyondco.de/middleware/csrf.html)

- Protecting your Hono application from CSRF attacks.
- Specifying origins in environments where 'Origin' headers are not sent or removed.

**Reasoning:** This rule is important as it demonstrates how to use the CSRF protection middleware in the Hono framework. CSRF (Cross-Site Request Forgery) is a type of attack that tricks the victim into submitting a malicious request. It uses the identity and privileges of the victim to perform an undesired function on their behalf. In Hono, CSRF protection can be added to the application by using the 'csrf' middleware. This rule also shows how to specify origins using the 'origin' option, which is useful in environments where browsers do not send 'Origin' headers, or environments that use reverse proxies to remove 'Origin' headers.

*Source: docs/middleware/builtin/csrf.md*

### Using CSRF Protection in Hono

In Hono, you can use CSRF protection middleware to protect your application from Cross-Site Request Forgery attacks. Here is how you can do it:

```ts
import { Hono } from 'hono'
import { csrf } from 'hono/csrf'

const app = new Hono()

app.use(csrf())

// Specifying origins with using `origin` option
// string
app.use(csrf({ origin: 'myapp.example.com' }))

// string[]
app.use(
  csrf({
    origin: ['myapp.example.com', 'development.myapp.example.com'],
  })
)

// Function
// It is strongly recommended that the protocol be verified to ensure a match to `$`.
// You should *never* do a forward match.
app.use(
  '*',
  csrf({
    origin: (origin) =>
      /https://(\w+.)?myapp.example.com$/.test(origin),
  })
)
```

The `csrf()` function is a middleware that adds CSRF protection to your application. You can specify the origins that are allowed to make requests to your application using the `origin` option. The `origin` option can be a string, an array of strings, or a function that returns a boolean.

- It is strongly recommended to verify the protocol in the function form of the `origin` option to ensure a match to `$`. You should never do a forward match.

- [Hono CSRF middleware](https://hono.com/docs/csrf)

- Protecting your application from CSRF attacks
- Restricting the origins that can make requests to your application

**Reasoning:** This rule is important as it demonstrates how to use CSRF protection in Hono framework. CSRF (Cross-Site Request Forgery) is a type of attack that tricks the victim into submitting a malicious request. It uses the identity and privileges of the victim to perform an undesired function on their behalf. The rule shows how to import and use the CSRF middleware, and how to specify origins using the `origin` option in different ways: as a string, as an array of strings, or as a function.

*Source: docs/middleware/builtin/csrf.md*

### Using 'jwk' Middleware for Authentication in Hono

This code demonstrates how to import and use the 'jwk' middleware in Hono for handling JSON Web Key Set (JWKS) for authentication.

```ts
import { Hono } from 'hono'
import { jwk } from 'hono/jwk'

const app = new Hono()

app.use(
  '/auth/*',
  jwk({
    jwks_uri: `https://${backendServer}/.well-known/jwks.json`,
  })
)

app.get('/auth/page', (c) => {
  return c.text('You are authenticated')
})
```

1. The 'jwk' middleware is imported from 'hono/jwk'.
2. A new Hono application is created.
3. The 'jwk' middleware is used on all routes starting with '/auth/'. The middleware is configured with the URI of the JWKS.
4. When a GET request is made to '/auth/page', if the request is authenticated, a text response 'You are authenticated' is returned.

- The 'jwk' middleware requires a valid JWKS URI to function correctly.

- [Hono Documentation](https://hono.beyondnlp.com)

- Securing routes in a Hono application with JWT authentication.

**Reasoning:** This rule is important as it demonstrates how to use the 'jwk' middleware in Hono framework to handle JSON Web Key Set (JWKS) for authentication. This is a common practice in securing routes in a Hono application.

*Source: docs/middleware/builtin/jwk.md*

### Using 'jwk' Middleware for Authentication in Hono Framework

This code demonstrates how to use the 'jwk' middleware in the Hono framework for authentication. The 'jwk' middleware is used to validate JSON Web Tokens (JWTs) from a JSON Web Key Set (JWKS) endpoint.

```ts
import { Hono } from 'hono'
import { jwk } from 'hono/jwk'

const app = new Hono()

app.use(
  '/auth/*',
  jwk({
    jwks_uri: `https://${backendServer}/.well-known/jwks.json`,
  })
)

app.get('/auth/page', (c) => {
  return c.text('You are authorized')
})
```

1. The 'jwk' middleware is imported from 'hono/jwk'.
2. A new Hono application is created.
3. The 'jwk' middleware is used on all routes starting with '/auth'. It validates JWTs using the JWKS endpoint specified.
4. If the JWT is valid, the user is authorized and can access the '/auth/page' route.

- The 'jwk' middleware requires a JWKS endpoint to validate JWTs.
- The JWKS endpoint is usually provided by the authentication server.

- [Hono Documentation](https://hono.bevry.me/)

- Securing routes in a web application with JWT authentication.

**Reasoning:** This rule is important as it demonstrates how to use the 'jwk' middleware in the Hono framework for authentication. The 'jwk' middleware is used to validate JSON Web Tokens (JWTs) from a JSON Web Key Set (JWKS) endpoint. This is a common practice in securing routes in a web application.

*Source: docs/middleware/builtin/jwk.md*

### Using jwk Middleware for Authentication and JWT Payload Extraction in Hono

This code snippet demonstrates how to use the jwk middleware in Hono to authenticate routes and extract JWT payload. The jwk middleware is used to secure the '/auth/*' route. The middleware is configured with the URI of the JSON Web Key Set (JWKS) which contains the public keys used to verify any JSON Web Token (JWT) issued by the authorization server.

```ts
const app = new Hono()

app.use(
  '/auth/*',
  jwk({
    jwks_uri: `https://${backendServer}/.well-known/jwks.json`,
  })
)

app.get('/auth/page', (c) => {
  const payload = c.get('jwtPayload')
  return c.json(payload) // eg: { "sub": "1234567890", "name": "John Doe", "iat": 1516239022 }
})
```

In the '/auth/page' route handler, the JWT payload is retrieved from the context object using the 'get' method and returned as a JSON response.

- The jwk middleware must be configured with the correct JWKS URI.
- The JWT payload can be retrieved from the context object in the route handler.

- [Hono Documentation](https://hono.bevry.me/)

- Securing routes with JWT authentication.
- Extracting JWT payload for user identification or authorization.

**Reasoning:** This rule is important as it demonstrates how to use the jwk middleware in Hono to authenticate routes and extract JWT payload. It shows how to secure a route and how to retrieve the JWT payload from the context object.

*Source: docs/middleware/builtin/jwk.md*

### Importing and Using Context Storage in Hono

This code snippet demonstrates how to import and use context storage in Hono.

```ts
import { Hono } from 'hono'
import { contextStorage, getContext } from 'hono/context-storage'
```

1. The `Hono` object is imported from the `hono` package.
2. The `contextStorage` and `getContext` functions are imported from `hono/context-storage`.

- The `getContext()` function will return the current Context object if the `contextStorage()` is applied as a middleware.

- [Hono Documentation](https://hono.bespokejs.com)

- Storing and retrieving state across different middleware or routes.

**Reasoning:** This rule is important as it demonstrates how to import and use context storage in Hono. Context storage is a crucial feature in Hono that allows developers to store and retrieve context data across different parts of their application. This is especially useful in scenarios where state needs to be shared across different middleware or routes.

*Source: docs/middleware/builtin/context-storage.md*

### Using contextStorage to Store and Retrieve Data in Hono

The `contextStorage` middleware in Hono allows you to store and retrieve context-specific data. This can be useful when you need to pass data between different parts of your application without directly linking them.

Here is an example of how to use it:

```ts
type Env = {
  Variables: {
    message: string
  }
}

const app = new Hono<Env>()

app.use(contextStorage())

app.use(async (c, next) => {
  c.set('message', 'Hello!')
  await next()
})

// You can access the variable outside the handler.
const getMessage = () => {
  return getContext<Env>().var.message
}

app.get('/', (c) => {
  return c.text(getMessage())
})
```

In this example, we first define an environment type `Env` with a `message` variable. We then create a new Hono application and use the `contextStorage` middleware. In the next middleware, we set the `message` variable in the context to 'Hello!'. Finally, we define a function `getMessage` that retrieves the `message` variable from the context and use it in a route handler.

- The `contextStorage` middleware must be used before any middleware that wants to use the context storage.
- The `getContext` function can be used to retrieve the current context object.

- [Hono documentation](https://hono.bayrell.org/en/)

- Passing data between middleware and route handlers
- Storing request-specific data

**Reasoning:** This rule is important as it demonstrates how to use the contextStorage middleware in Hono to store and retrieve context-specific data. It shows how to set a variable in the context and how to retrieve it later, even outside of the handler. This is useful in scenarios where you need to pass data between different parts of your application without directly linking them.

*Source: docs/middleware/builtin/context-storage.md*

### Accessing Bindings Outside the Handler in Hono

In Hono, you can use context storage to access bindings outside the handler. This is particularly useful in Cloudflare Workers where you may need to access and manipulate bindings such as KV storage.

Here is a code snippet demonstrating this:

```ts
type Env = {
  Bindings: {
    KV: KVNamespace
  }
}

const app = new Hono<Env>()

app.use(contextStorage())

const setKV = (value: string) => {
  return getContext<Env>().env.KV.put('key', value)
}
```

In this code:

1. We define a type `Env` that includes a `Bindings` property with a `KV` property of type `KVNamespace`.
2. We create a new Hono app with the `Env` type.
3. We use the `contextStorage` middleware.
4. We define a `setKV` function that uses `getContext` to access the `KV` binding and put a value.

- `contextStorage` is a middleware provided by Hono that allows you to access the context outside the handler.
- `getContext` is a function provided by Hono that allows you to access the context.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Storing and retrieving data in KV storage in Cloudflare Workers.

**Reasoning:** This rule is important as it demonstrates how to use context storage in Hono to access bindings outside the handler. This is useful in Cloudflare Workers where you may need to access and manipulate bindings such as KV storage.

*Source: docs/middleware/builtin/context-storage.md*

### Importing and Using Cache in Hono

This rule demonstrates how to import and use the cache module from the Hono framework.

```ts
import { Hono } from 'hono'
import { cache } from 'hono/cache'
ts
app.get(
  '*',
  cache({
    cacheName: 'my-app',
    cacheControl: 'max-age=3600',
  })
)
```

In this example, the cache name is 'my-app' and the cache control directive is 'max-age=3600', which means the cached data will be considered fresh for 3600 seconds.

- Deno does not respect headers, so if you need to update the cache, you will need to implement your own mechanism.

- [Hono Documentation](https://hono.bsd.ac/docs)

- Caching responses for frequently accessed routes
- Storing the result of expensive computations to improve performance

#### Code Snippet

```typescript

After importing the necessary modules, you can use the `cache` function in your application routes. The `cache` function takes an object as an argument, where you can specify the cache name and cache control directives.

```

**Reasoning:** This rule is important as it demonstrates how to import and use the cache module from the Hono framework. Caching can significantly improve the performance of an application by storing the result of expensive computations or frequently accessed data. In this context, the rule shows how to set up caching in a Hono application, which is a crucial aspect of optimizing web applications.

*Source: docs/middleware/builtin/cache.md*

### Managing Request Timeouts in Hono

This code demonstrates how to manage request timeouts in a Hono application. It shows how to set a maximum duration for requests and how to use the timeout middleware with both default and custom settings.

```ts
import { Hono } from 'hono'
import { timeout } from 'hono/timeout'

const app = new Hono()

// Applying a 5-second timeout
app.use('/api', timeout(5000))
```

The `timeout` function from 'hono/timeout' is used as a middleware in the Hono application. It is applied to the '/api' route and sets a maximum duration of 5 seconds for any request to this route.

- The timeout value is specified in milliseconds.

- Hono Documentation: [Managing Request Timeouts](https://hono.bespoken.io/docs/managing-request-timeouts/)

- Ensuring that requests to certain routes do not exceed a specified duration to maintain the performance and responsiveness of the application.

**Reasoning:** This rule is important as it demonstrates how to manage request timeouts in a Hono application. It shows how to set a maximum duration for requests and how to use the timeout middleware with both default and custom settings. This is crucial in maintaining the performance and responsiveness of the application.

*Source: docs/middleware/builtin/timeout.md*

### Applying Timeout Middleware in Hono

This code demonstrates how to apply a timeout middleware to a specific route in Hono. This is useful in managing server resources and preventing long-running requests from consuming too much server time.

```ts
const app = new Hono()

// Applying a 5-second timeout
app.use('/api', timeout(5000))

// Handling a route
app.get('/api/data', async (c) => {
  // Your route handler logic
  return c.json({ data: 'Your data here' })
})
```

The `timeout` function from 'hono/timeout' is used as a middleware for the '/api' route. This function will automatically end any request to '/api' that takes longer than 5000 milliseconds (5 seconds) to complete.

- The timeout middleware should be applied before the route handler to ensure it takes effect.

- [Hono Documentation](https://hono.bespokejs.com)

- Applying a timeout to resource-intensive API endpoints to prevent server overload.

**Reasoning:** This rule is important as it demonstrates how to apply a timeout middleware to a specific route in Hono. This is crucial in managing server resources and preventing long-running requests from consuming too much server time.

*Source: docs/middleware/builtin/timeout.md*

### Setting a Timeout and Handling Timeout Exception in Hono

In Hono, you can set a timeout for a specific route using the `timeout` middleware. If the specified duration is exceeded, the middleware will automatically reject the promise and potentially throw an error. You can also customize the exception that is thrown when a timeout occurs.

Here is an example of how to do this:

```ts
import { HTTPException } from 'hono/http-exception'

// Custom exception factory function
const customTimeoutException = (context) =>
  new HTTPException(408, {
    message: `Request timeout after waiting ${context.req.headers.get(
      'Duration'
    )} seconds. Please try again later.`,
  })

// for Static Exception Message
// const customTimeoutException = new HTTPException(408, {
//   message: 'Operation timed out. Please try again later.'
// });

// Applying a 1-minute timeout with a custom exception
app.use('/api/long-process', timeout(60000, customTimeoutException))

app.get('/api/long-process', async (c) => {
  // Simulate a long process
  await new Promise((resolve) => setTimeout(resolve, 61000))
  return c.json({ data: 'This usually takes longer' })
})
```

The `timeout` middleware is applied to the `/api/long-process` route with a duration of 60000 milliseconds (1 minute). If the process takes longer than this, a custom `HTTPException` is thrown with a status code of 408 (Request Timeout) and a custom message.

- The duration for the timeout can be specified in milliseconds.
- You can customize the exception that is thrown when a timeout occurs by providing a factory function or a static exception message.

- [Hono Documentation](https://hono.bespokejs.com)

- Long running processes that may potentially exceed a reasonable response time.
- Routes that need to enforce a strict response time limit.

**Reasoning:** This rule is important as it demonstrates how to set a timeout for a specific route and handle the timeout exception in Hono. This is crucial in managing long running processes and ensuring that the server does not get stuck waiting for a response that may never come.

*Source: docs/middleware/builtin/timeout.md*

### Handling Timeouts in Hono with Streaming Server-Sent Events (SSE)

The following code snippet demonstrates how to handle timeouts in Hono with streaming Server-Sent Events (SSE).

```ts
app.get('/sse', async (c) => {
  let id = 0
  let running = true
  let timer: number | undefined

  return streamSSE(c, async (stream) => {
    timer = setTimeout(() => {
      console.log('Stream timeout reached, closing stream')
      stream.close()
    }, 3000) as unknown as number

    stream.onAbort(async () => {
      console.log('Client closed connection')
      running = false
      clearTimeout(timer)
    })

    while (running) {
      const message = `It is ${new Date().toISOString()}`
      await stream.writeSSE({
        data: message,
        event: 'time-update',
        id: String(id++),
      })
      await stream.sleep(1000)
    }
  })
})
```

1. A timeout is set for the stream using `setTimeout`. If the timeout is reached, the stream is closed.
2. The `onAbort` event handler is set for the stream. If the client closes the connection, the `running` flag is set to false and the timeout is cleared.
3. While the `running` flag is true, the server sends a Server-Sent Event to the client every second.

- The timeout middleware cannot be used with streams. Thus, use `stream.close` and `setTimeout` together.
- Be cautious about the order of middleware, especially when using error-handling or other timing-related middleware, as it might affect the behavior of this timeout middleware.

- [Hono Documentation](https://hono.bike/)

- Real-time applications that require server-client communication with a timeout.

**Reasoning:** This rule is important as it demonstrates how to handle timeouts in Hono with streaming Server-Sent Events (SSE). It shows how to set a timeout for a stream, close the stream when the timeout is reached, and handle the event when a client closes the connection. This is crucial for maintaining efficient and responsive server-client communication.

*Source: docs/middleware/builtin/timeout.md*

### Using Logger Middleware in Hono

This code demonstrates how to use the logger middleware in Hono.

```ts
import { Hono } from 'hono'
import { logger } from 'hono/logger'

const app = new Hono()

app.use(logger())
app.get('/', (c) => c.text('Hello Hono!'))
```

1. Import the Hono framework and the logger middleware.
2. Create a new Hono application.
3. Use the logger middleware in your application with `app.use(logger())`.
4. Define a route for your application. In this case, a GET request to the root URL will return 'Hello Hono!'.

- The logger middleware logs the details of each request, which can be useful for debugging and monitoring purposes.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Use the logger middleware in your Hono application to log details of each request for debugging and monitoring purposes.

**Reasoning:** This rule is important as it demonstrates how to use the logger middleware in the Hono web framework. Logger middleware is crucial for tracking and debugging the flow of requests and responses in your application. It logs details of each request, which can be useful for debugging and monitoring purposes.

*Source: docs/middleware/builtin/logger.md*

### Setting Up a Custom Logger in Hono

This code snippet demonstrates how to set up a custom logger function in Hono. The logger function takes a message and an arbitrary number of additional string arguments, which are then printed to the console.

```ts
export const customLogger = (message: string, ...rest: string[]) => {
  console.log(message, ...rest)
}

app.use(logger(customLogger))
```

The `customLogger` function is defined with two parameters: `message` and `...rest`. The `message` parameter is the main log message, while `...rest` is an array of additional string arguments. These arguments are spread into the `console.log` function, allowing for multiple arguments to be logged at once.

The `customLogger` function is then passed to the `app.use` method, which adds it as a middleware to the application. This means that the `customLogger` function will be called for every request to the application, allowing for comprehensive logging.

- The `...rest` parameter uses the rest parameter syntax, which allows for an arbitrary number of arguments to be passed to the function.
- The `customLogger` function is added as a middleware using the `app.use` method. This means that it will be called for every request to the application.

- [Hono documentation](https://hono.bayrell.org/en/)

- Debugging: Custom loggers can be used to log specific information about requests, which can be useful for debugging purposes.
- Monitoring: Custom loggers can also be used to monitor the state of the application, such as the number of requests or the response times.

**Reasoning:** This rule is important as it demonstrates how to set up a custom logger function in Hono. Custom loggers can be used to format and display log messages in a way that suits the specific needs of the application. This can be particularly useful for debugging and monitoring purposes.

*Source: docs/middleware/builtin/logger.md*

### Implementing a Custom Logger in Hono

This code demonstrates how to implement a custom logger in Hono. Logging is a critical part of any application for debugging and tracking purposes. By creating a custom logger, developers can control what information gets logged and how it is formatted.

```ts
export const customLogger = (message: string, ...rest: string[]) => {
  console.log(message, ...rest)
}

app.use(logger(customLogger))
ts
app.post('/blog', (c) => {
  // Routing logic

  customLogger('Blog saved:', `Path: ${blog.url},`, `ID: ${blog.id}`)
  // Output
  // <-- POST /blog
  // Blog saved: Path: /blog/example, ID: 1
  // --> POST /blog 201 93ms

  // Return Context
})
```

The `customLogger` function is defined to log a message along with any additional arguments. It is then used as a middleware in the Hono application using `app.use()`. In the route, the `customLogger` is used to log information about the blog post.

- The `customLogger` can be used in any part of the application where logging is required.

- [Hono Documentation](https://hono.bike/)

- Logging request and response data
- Debugging application errors

#### Code Snippet

```typescript

In the route:

```

**Reasoning:** This rule is important as it demonstrates how to implement a custom logger in Hono. Logging is a critical part of any application for debugging and tracking purposes. By creating a custom logger, developers can control what information gets logged and how it is formatted.

*Source: docs/middleware/builtin/logger.md*

### Using ETag Middleware in Hono

This code demonstrates how to use the ETag middleware in Hono.

```ts
import { Hono } from 'hono'
import { etag } from 'hono/etag'

const app = new Hono()

app.use('/etag/*', etag())
app.get('/etag/abc', (c) => {
  return c.text('Hono is cool')
})
```

1. Import the Hono and etag modules.
2. Create a new Hono application.
3. Use the etag middleware for any routes that match '/etag/*'.
4. Define a GET route '/etag/abc' that returns a text response.

- The ETag middleware automatically generates an ETag for the response based on the response body.
- If the client sends an 'If-None-Match' request header with the same ETag, the server will respond with a 304 Not Modified status and no body.

- [Hono Documentation](https://hono.bjubnes.com/docs)

- Use the ETag middleware when you want to enable client-side caching and save bandwidth.

**Reasoning:** This rule is important as it demonstrates how to use the ETag middleware in Hono. ETag headers are part of HTTP, the web protocol. They are used to determine whether the client's cached version of the content is the same as that of the server. If the ETag received from the server matches the one the client has, the content is not downloaded again, saving bandwidth.

*Source: docs/middleware/builtin/etag.md*

### Importing and Using 'secureHeaders' Middleware in Hono

This code demonstrates how to import and use the 'secureHeaders' middleware in Hono to simplify the setup of security headers.

```ts
import { Hono } from 'hono'
import { secureHeaders } from 'hono/secure-headers'
ts
const app = new Hono()
app.use(secureHeaders())
```

You can also suppress unnecessary headers by setting them to false.

This middleware is inspired in part by the capabilities of Helmet, and it allows you to control the activation and deactivation of specific security headers. This is crucial for enhancing the security of your web applications.

- Always ensure to import the necessary modules before using them.
- Use the middleware with the default settings unless there's a need to suppress some headers.

- [Hono Documentation](https://hono.bespoken.io/)

- Enhancing the security of web applications by controlling the activation and deactivation of specific security headers.

#### Code Snippet

```typescript

You can use the middleware with the optimal settings by default.

```

**Reasoning:** This rule is important as it demonstrates how to use the 'secureHeaders' middleware in the Hono framework to simplify the setup of security headers. It shows how to import the necessary modules, use the middleware with default settings, and how to suppress unnecessary headers by setting them to false. This is crucial for enhancing the security of web applications by controlling the activation and deactivation of specific security headers.

*Source: docs/middleware/builtin/secure-headers.md*

### Activating Specific Security Headers in Hono

This code demonstrates how to activate specific security headers in Hono. Security headers are a crucial part of web security and can make your application more resistant to common web vulnerabilities.

```ts
import { Hono } from 'hono'
import { secureHeaders } from 'hono/secure-headers'

const app = new Hono()
app.use(secureHeaders())
ts
const app = new Hono()
app.use(
  '*',
  secureHeaders({
    xFrameOptions: false,
    xXssProtection: false,
  })
)
```

- [Hono Documentation](https://hono.bevry.me/)

- Enhancing the security of your web application by activating specific security headers.
- Suppressing unnecessary headers for a more streamlined application.

#### Code Snippet

```typescript

### How it Works

The `secureHeaders()` function is imported from the 'hono/secure-headers' module and used as middleware in the Hono application. By default, it applies optimal settings for security headers.

### Important Notes

You can suppress unnecessary headers by setting them to false, as shown below:

```

**Reasoning:** This rule is important as it demonstrates how to activate specific security headers in Hono. Security headers are a fundamental part of web security. When set correctly, they can make your application more resistant to common web vulnerabilities. By setting them to false, you can suppress unnecessary headers, providing a more streamlined and secure application.

*Source: docs/middleware/builtin/secure-headers.md*

### Using Secure Headers Middleware in Hono

This code demonstrates how to use the secure-headers middleware in Hono to manage HTTP headers for security.

```ts
const app = new Hono()
app.use(
  '*',
  secureHeaders({
    xFrameOptions: false,
    xXssProtection: false,
  })
)
```

In this code snippet, the `secureHeaders` function is used as a middleware in the Hono application. The function is called with an object as an argument, which specifies the HTTP headers to be suppressed (set to false).

- The `secureHeaders` function can be used to set, suppress, or modify HTTP headers for security.
- The headers are set globally for all routes in the application (indicated by the '*' wildcard).

- [Hono Documentation](https://hono.bryntum.com/docs)

- Suppressing unnecessary HTTP headers for security or performance optimization in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to use the secure-headers middleware in Hono to manage HTTP headers for security. It shows how to suppress unnecessary headers by setting them to false, which can be crucial for optimizing security settings and performance in a Hono application.

*Source: docs/middleware/builtin/secure-headers.md*

### Setting Secure Headers in Hono

This code demonstrates how to set secure headers in Hono. Secure headers help to protect your application from certain types of attacks and vulnerabilities.

```ts
const app = new Hono()
app.use(
  '*',
  secureHeaders({
    strictTransportSecurity:
      'max-age=63072000; includeSubDomains; preload',
    xFrameOptions: 'DENY',
    xXssProtection: '1',
  })
)
```

In this example, the `strictTransportSecurity`, `xFrameOptions`, and `xXssProtection` headers are set. These headers can help to prevent clickjacking attacks, cross-site scripting attacks, and enforce secure (HTTPS) connections.

The `app.use` function is used to apply middleware to the Hono application. The `secureHeaders` function is a middleware function that sets the specified headers.

- The `secureHeaders` function takes an object as an argument. Each property in this object corresponds to a header that should be set.
- The value of each property can be a boolean or a string. If the value is `false`, the header will not be set. If the value is a string, the header will be set with that value.

- [Hono Documentation](https://hono.bespokejs.com)

- Setting secure headers to protect your application from attacks and vulnerabilities.

**Reasoning:** This rule is important as it demonstrates how to set secure headers in Hono. Secure headers help to protect your application from certain types of attacks and vulnerabilities. The rule shows how to override default header values using a string, which can be useful for customizing security settings.

*Source: docs/middleware/builtin/secure-headers.md*

### Middleware Order Matters in Hono

In Hono, the order in which middleware is specified can affect the final outcome of the headers. This is especially important when dealing with middleware that manipulates the same header.

Consider the following examples:

```ts
const app = new Hono()
app.use(secureHeaders())
app.use(poweredBy())
ts
const app = new Hono()
app.use(poweredBy())
app.use(secureHeaders())
```

In this case, poweredBy() operates first and the 'x-powered-by' header is added.

This demonstrates that the order of middleware usage can have significant implications on the security and functionality of the application. Therefore, it's crucial to be cautious about the order of specification when dealing with middleware in Hono.

- [Hono Documentation](https://hono.bespokejs.com)

- Setting up security headers in a Hono application
- Manipulating headers in a Hono application

#### Code Snippet

```typescript

In this case, secureHeaders() operates first and the 'x-powered-by' header is removed.

```

**Reasoning:** The order of middleware specification in Hono can affect the final outcome of the headers. This rule is important because it demonstrates how the order of middleware usage can manipulate the same header differently. In the given example, when secureHeaders() is used before poweredBy(), the 'x-powered-by' header is removed. But when poweredBy() is used before secureHeaders(), the 'x-powered-by' header is added. This can have significant implications on the security and functionality of the application.

*Source: docs/middleware/builtin/secure-headers.md*

### Middleware Order in Hono

In Hono, the order of middleware usage is significant and can affect the final outcome. This is demonstrated in the following code snippets:

```ts
const app = new Hono()
app.use(secureHeaders())
app.use(poweredBy())
ts
const app = new Hono()
app.use(poweredBy())
app.use(secureHeaders())
```

In this case, the 'poweredBy()' middleware operates first and adds the 'x-powered-by' header. Then, the 'secureHeaders()' middleware operates but does not remove the 'x-powered-by' header as it has already been added.

In Hono, middleware functions are executed in the order they are used in the application. Therefore, the order of middleware usage can affect the final outcome.

- The order of middleware usage is significant in Hono.
- The 'secureHeaders()' middleware removes the 'x-powered-by' header.
- The 'poweredBy()' middleware adds the 'x-powered-by' header.

- [Hono Documentation](https://hono.bespoken.io/)

- Configuring headers in a Hono application.
- Understanding the order of middleware execution in Hono.

#### Code Snippet

```typescript

In the above case, the 'secureHeaders()' middleware operates first and removes the 'x-powered-by' header. Then, the 'poweredBy()' middleware operates but does not add the 'x-powered-by' header as it has already been removed.

```

**Reasoning:** This rule is important as it demonstrates the order of middleware usage in Hono and how it affects the final outcome. In this case, the order of using 'secureHeaders()' and 'poweredBy()' middleware determines whether the 'x-powered-by' header is included or not.

*Source: docs/middleware/builtin/secure-headers.md*

### Adding a Nonce to a Script or Style Element in Hono

This code snippet demonstrates how to add a nonce to a `script` or `style` element in Hono. The nonce is imported from `hono/secure-headers` and added to a `scriptSrc` or `styleSrc`. The nonce value can be predefined or generated by a function. The nonce value is then retrieved using `c.get('secureHeadersNonce')`.

Code Snippet:
```tsx
import { secureHeaders, NONCE } from 'hono/secure-headers'
import type { SecureHeadersVariables } from 'hono/secure-headers'

type Variables = SecureHeadersVariables

const app = new Hono<{ Variables: Variables }>()

app.get(
  '*',
  secureHeaders({
    contentSecurityPolicy: {
      scriptSrc: [NONCE, 'https://allowed1.example.com'],
    },
  })
)

app.get('/', (c) => {
  return c.html(
    <html>
      <body>
        {/** contents */}
        <script
          src='/js/client.js'
          nonce={c.get('secureHeadersNonce')}
        />
      </body>
    </html>
  )
})
```

This works by setting the nonce value to `scriptSrc` in the `secureHeaders` function. The nonce value is then retrieved in the `c.get('secureHeadersNonce')` function. This ensures that only scripts and styles with the specific nonce value can be executed or applied, enhancing the security of the web application.

Important Note: Always ensure that the nonce value is unique and random for each request to prevent potential security vulnerabilities.

References: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce

Common Use Cases: This is commonly used in web applications that need to enhance their security by preventing XSS attacks.

**Reasoning:** This rule is important as it demonstrates how to add a nonce (a random string that can only be used once) to a `script` or `style` element in Hono. This is a crucial aspect of Content Security Policy (CSP) which helps to prevent Cross-Site Scripting (XSS) attacks by allowing only scripts and styles that have a specific nonce value to be executed or applied.

*Source: docs/middleware/builtin/secure-headers.md*

### Generating and Using Nonce for Secure Headers in Hono

In Hono, you can generate and use a nonce value for secure headers. This is particularly useful for providing an additional layer of security by preventing replay attacks. Here's how you can do it:

```tsx
const app = new Hono<{ Variables: { myNonce: string } }>()

const myNonceGenerator: ContentSecurityPolicyOptionHandler = (c) => {
  const nonce = Math.random().toString(36).slice(2)
  c.set('myNonce', nonce)
  return `'nonce-${nonce}'`
}

app.get('*', secureHeaders({ contentSecurityPolicy: { scriptSrc: [myNonceGenerator, 'https://allowed1.example.com'], }, }))

app.get('/', (c) => {
  return c.html(
    <html>
      <body>
        <script src='/js/client.js' nonce={c.get('myNonce')} />
      </body>
    </html>
  )
})
```

1. A new Hono app is created with a variable for the nonce.
2. A nonce generator function is defined. This function is called on every request, generating a new nonce value and setting it in the context.
3. The nonce generator is used in the Content Security Policy for a script source in the secure headers middleware.
4. The nonce value is retrieved from the context and used in a script tag in the response.

- The nonce value should be unpredictable and generated anew for each request to prevent replay attacks.

- [Hono Documentation](https://hono.boutique/docs/)

- Use this pattern when you need to add an additional layer of security to your scripts by ensuring they can only be executed once per request.

**Reasoning:** This rule is important as it demonstrates how to generate and use a nonce value for secure headers in Hono. Nonce values are used to provide a layer of security that helps prevent replay attacks. In this example, a nonce value is generated for each request and used in the Content Security Policy for a script source. This ensures that the script can only be executed once, providing an additional layer of security.

*Source: docs/middleware/builtin/secure-headers.md*

### Setting Permission-Policy Header in Hono

The code snippet demonstrates how to set the Permission-Policy header in Hono. This header allows you to control which features and APIs can be used in the browser.

```ts
const app = new Hono()
app.use(
  '*',
  secureHeaders({
    permissionsPolicy: {
      fullscreen: ['self'],
      bluetooth: ['none'],
      payment: ['self', 'https://example.com'],
      syncXhr: [],
      camera: false,
      microphone: true,
      geolocation: ['*'],
      usb: ['self', 'https://a.example.com', 'https://b.example.com'],
      accelerometer: ['https://*.example.com'],
      gyroscope: ['src'],
      magnetometer: [
        'https://a.example.com',
        'https://b.example.com',
      ],
    },
  })
)
```

The `secureHeaders` middleware is used to set the headers. The `permissionsPolicy` object is passed as an argument, where each key-value pair represents a feature and its allowed sources.

- The values can be a string, a boolean, or an array of strings.
- The `self` keyword refers to the origin from which the document was served.
- The `none` keyword means that the feature is disabled.

- [MDN Web Docs - Feature Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy)

- Limiting the capabilities of certain APIs for security reasons.
- Controlling the features that can be used in the browser.

**Reasoning:** This rule is important as it demonstrates how to set the Permission-Policy header in Hono. The Permission-Policy header allows you to control which features and APIs can be used in the browser. This is crucial for security and privacy reasons, as it allows the developer to limit the capabilities of certain APIs, thereby reducing the potential attack surface.

*Source: docs/middleware/builtin/secure-headers.md*

### Handling Trailing Slashes in URLs with Hono

In Hono, you can use the `appendTrailingSlash` and `trimTrailingSlash` functions to manage trailing slashes in URLs. This is useful for URL normalization and can help avoid issues related to content duplication and SEO.

```ts
import { Hono } from 'hono'
import {
  appendTrailingSlash,
  trimTrailingSlash,
} from 'hono/trailing-slash'
ts
import { Hono } from 'hono'
import { appendTrailingSlash } from 'hono/trailing-slash'

const app = new Hono()

app.get('/about/me', appendTrailingSlash())
```

In this example, a GET request to `/about/me` will be redirected to `/about/me/`.

- These functions should be used carefully as improper use can lead to issues such as infinite redirects.

- [Hono Documentation](https://hono.bevry.me/)

- URL normalization
- Preventing content duplication

#### Code Snippet

```typescript

### Usage

You can use `appendTrailingSlash` to add a trailing slash to a URL if the content was not found. Similarly, `trimTrailingSlash` can be used to remove the trailing slash.

```

**Reasoning:** This rule is important as it demonstrates how to handle trailing slashes in URLs using Hono's built-in functions `appendTrailingSlash` and `trimTrailingSlash`. This is crucial for URL normalization and can prevent potential issues related to content duplication and SEO.

*Source: docs/middleware/builtin/trailing-slash.md*

### Handling Trailing Slashes in Hono

This code demonstrates how to append or trim trailing slashes in URLs using Hono web framework.

```ts
import { Hono } from 'hono'
import { appendTrailingSlash } from 'hono/trailing-slash'

const app = new Hono({ strict: true })

app.use(appendTrailingSlash())
app.get('/about/me/', (c) => c.text('With Trailing Slash'))
```

The `appendTrailingSlash` function from 'hono/trailing-slash' is used as a middleware in the Hono application. This function appends a trailing slash to the URL if it doesn't already have one.

- The `strict` option in the Hono constructor must be set to `true` for the trailing slash functions to work.

- [Hono Documentation](https://hono.beyondnlp.com)

- Ensuring consistent URL structure for SEO
- Redirecting users to the correct URL

**Reasoning:** This rule is important because it demonstrates how to handle trailing slashes in URLs using Hono web framework. It shows how to append or trim trailing slashes from URLs which is crucial for consistent routing and SEO.

*Source: docs/middleware/builtin/trailing-slash.md*

### Using Method Override Middleware in Hono

This code demonstrates how to use the `methodOverride` middleware in Hono to override the HTTP method of a request.

```ts
import { Hono } from 'hono'
import { methodOverride } from 'hono/method-override'

const app = new Hono()

// If no options are specified, the value of `_method` in the form,
// e.g. DELETE, is used as the method.
app.use('/posts', methodOverride({ app }))
```

The `methodOverride` middleware checks for a `_method` field in the request. If found, it changes the HTTP method of the request to the value of the `_method` field.

- This is useful when the client doesn't support certain HTTP methods, like DELETE or PUT, and instead sends a POST request with the intended method specified in a `_method` field.

- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)

- RESTful APIs where the client may not support all HTTP methods.

**Reasoning:** This rule is important as it demonstrates how to use the methodOverride middleware in Hono to override the HTTP method of a request. This is useful when the client doesn't support certain HTTP methods, like DELETE or PUT, and instead sends a POST request with the intended method specified in a `_method` field.

*Source: docs/middleware/builtin/method-override.md*

### Using methodOverride Middleware in Hono

This code snippet demonstrates how to use the `methodOverride` middleware in Hono. This middleware allows you to use HTTP verbs such as DELETE or PUT in places where the client doesn't support it.

```ts
const app = new Hono()

// If no options are specified, the value of `_method` in the form,
// e.g. DELETE, is used as the method.
app.use('/posts', methodOverride({ app }))

app.delete('/posts', (c) => {
  // ....
})
```

The `methodOverride` middleware checks for the presence of a `_method` property in the form data. If it exists, it overrides the original HTTP method with the value of `_method`. In this example, if a form submits a POST request with `_method` set to DELETE, the middleware will change the request to a DELETE request.

- The `methodOverride` middleware should be used before any middleware that needs to know the method of the request.

- [Hono documentation](https://hono.beyondco.de/docs/getting-started)

- Handling form submissions that need to use HTTP verbs other than GET and POST.

**Reasoning:** This rule is important as it demonstrates how to use the methodOverride middleware in Hono. This middleware allows you to use HTTP verbs such as DELETE or PUT in places where the client doesn't support it. This is particularly useful when dealing with HTML forms, which only support GET and POST methods.

*Source: docs/middleware/builtin/method-override.md*

### Using Method Override in Hono

Since HTML forms cannot send a DELETE method, you can put the value `DELETE` in the property named `_method` and send it. And the handler for `app.delete()` will be executed.

Here is an example of how to do it:

```html
<form action="/posts" method="POST">
  <input type="hidden" name="_method" value="DELETE" />
  <input type="text" name="id" />
</form>
ts
import { methodOverride } from 'hono/method-override'

const app = new Hono()
app.use('/posts', methodOverride({ app }))

app.delete('/posts', () => {
  // ...
})
```

This works by using a hidden input field with the name `_method` in your HTML form. When the form is submitted, Hono will check for this field and if it exists, it will override the method of the request with its value.

This is a common use case when you need to perform actions like deleting a resource from a server, which requires a DELETE method.

References:
- [Hono Documentation](https://hono.bouzuya.net/)

#### Code Snippet

```typescript

And in your Hono application:

```

**Reasoning:** This rule is important as it demonstrates how to use the method override feature in Hono to handle HTTP methods like DELETE which are not supported by HTML forms. This is a common workaround in web development to overcome the limitations of HTML forms.

*Source: docs/middleware/builtin/method-override.md*

### Method Override in Hono

In Hono, you can override methods using different options. This can be useful when you want to change the default behavior of a method or use a different method based on certain conditions.

Here is a code snippet demonstrating this:

```ts
app.use('/posts', methodOverride({ app, form: '_custom_name' }))
app.use('/posts', methodOverride({ app, header: 'X-METHOD-OVERRIDE' }))
app.use('/posts', methodOverride({ app, query: '_method' }))
```

In the above code:

- `app` is the instance of `Hono` used in your application.
- `form` is an optional key with a value that overrides the default method.
- `header` is another optional key that can be used to override the method.
- `query` is yet another optional key that can be used for method overriding.

- The `app` option is required while the `form`, `header`, and `query` options are optional.
- The `form`, `header`, and `query` options can be used to customize the method overriding behavior based on your application's requirements.

- [Hono Documentation](https://hono.bespokejs.com)

- Changing the default behavior of a method based on certain conditions.
- Using a different method based on the request's form data, headers, or query parameters.

**Reasoning:** This rule is important as it demonstrates how to override methods in Hono using different options such as form, header, and query. This is useful when you want to change the default behavior of a method or use a different method based on certain conditions.

*Source: docs/middleware/builtin/method-override.md*

## Getting-started

### Creating a Basic Hono Application

This code snippet demonstrates how to create a basic 'Hello World' application using the Hono web framework.

```ts
import { Hono } from 'jsr:@hono/hono'
import { handle } from 'jsr:@hono/hono/netlify'

const app = new Hono()

app.get('/', (c) => {
  return c.text('Hello Hono!')
})

export default handle(app)
```

1. The `Hono` class is imported from the 'jsr:@hono/hono' module.
2. The `handle` function is imported from the 'jsr:@hono/hono/netlify' module.
3. A new instance of `Hono` is created.
4. A GET route for the path '/' is defined. When this route is accessed, it responds with the text 'Hello Hono!'.
5. The `handle` function is used to export the application.

- The `handle` function is specific to Netlify and is used to handle requests in a Netlify environment.

- [Hono Documentation](https://hono.dev/docs)

- Creating a basic web application with Hono.
- Defining simple routes in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono web framework. It shows how to initialize a new Hono application and define a simple route that responds with a text message. This is a fundamental pattern in Hono and most web frameworks, and understanding it is crucial for building web applications.

*Source: docs/getting-started/netlify.md*

### Setting Up a Basic Hono Application with Netlify

This code snippet demonstrates how to set up a basic Hono application with Netlify.

```ts
import { Hono } from 'jsr:@hono/hono'
import { handle } from 'jsr:@hono/hono/netlify'

const app = new Hono()

app.get('/', (c) => {
  return c.text('Hello Hono!')
})

export default handle(app)
sh
netlify dev
sh
netlify deploy --prod
ts
import { Hono } from 'jsr:@hono/hono'
import { handle } from 'jsr:@hono/hono/netlify'

const app = new Hono()

app.get('/', (c) => {
  console.log(c.env)
  return c.text('Hello Hono!')
})

export default handle(app)
```

- Make sure to install the necessary packages before running the application.
- The 'handle' function from '@hono/hono/netlify' is used to handle the Hono application.

- [Hono Documentation](https://hono.js.org/)
- [Netlify CLI Documentation](https://cli.netlify.com/)

- Creating a basic Hono application with Netlify.
- Accessing the Netlify's context in a Hono application.

#### Code Snippet

```typescript

To run the application locally, use the Netlify CLI:

```

**Reasoning:** This rule is important as it demonstrates how to set up a basic Hono application with Netlify. It shows how to import the necessary modules, create a new Hono application, define a route, and export the application to be handled by Netlify. It also explains how to run the application locally using the Netlify CLI and how to deploy it to production. Lastly, it shows how to access the Netlify's context through 'c.env'.

*Source: docs/getting-started/netlify.md*

### Deploying a Hono Application with Netlify

This code snippet demonstrates how to deploy a Hono application using Netlify.

```sh
netlify deploy --prod
```

The `netlify deploy --prod` command deploys the application to production. The `--prod` flag indicates that the deployment is for the production environment.

Ensure that you have the necessary permissions and the Netlify CLI installed before running the command.

- [Netlify CLI Documentation](https://cli.netlify.com/)

This command is typically used when you want to deploy your Hono application to the production environment.

**Reasoning:** This rule is important as it demonstrates how to deploy a Hono application using Netlify. It shows the command needed to deploy the application to production. Understanding this rule is crucial for developers to successfully deploy their Hono applications.

*Source: docs/getting-started/netlify.md*

### Accessing Netlify's Context in Hono

In Hono, you can access the Netlify's `Context` through `c.env`. This is useful when you need to use environment variables or context in your application.

Here is a code snippet demonstrating this:

```ts
import { Hono } from 'jsr:@hono/hono'
import { handle } from 'jsr:@hono/hono/netlify'

// Import the type definition
import type { Context } from 'https://edge.netlify.com/'

export type Env = {

You can access the Netlify's `Context` through `c.env`:
```

In the above code, `c.env` is used to access the Netlify's Context. This allows you to use environment variables and context in your Hono application.

Ensure that you have imported the necessary modules and type definitions before trying to access the `Context`.

- Hono Documentation
- Netlify Documentation

This is commonly used when you need to use environment variables or context in your Hono application.

**Reasoning:** This rule is important as it demonstrates how to access the Netlify's Context through `c.env` in Hono. Understanding this rule allows developers to effectively use the environment variables and context in their Hono applications.

*Source: docs/getting-started/netlify.md*

### Creating a New Project with Bun and Hono

This code snippet demonstrates how to create a new project using the Bun framework and Hono.

```sh
bun create hono@latest my-app
cd my-app
bun install
```

1. The `bun create hono@latest my-app` command creates a new project named 'my-app' with the latest version of Hono.
2. The `cd my-app` command navigates into the newly created project directory.
3. The `bun install` command installs the necessary dependencies for the project.

- Ensure that Bun is installed and updated to its latest version before running these commands.

- Official Bun website: https://bun.sh

- Setting up a new project with Bun and Hono.

**Reasoning:** This rule is important as it demonstrates how to create a new project using the Bun framework and Hono. It shows the command necessary to initialize a new project with the latest version of Hono, and how to navigate into the project directory and install the necessary dependencies. Understanding this rule is crucial for setting up a new project correctly and efficiently.

*Source: docs/getting-started/bun.md*

### Creating and Setting Up a Hono Project with Bun

This guide demonstrates how to create a new project with Hono using Bun, how to set up an existing project with Hono, and how to install the necessary dependencies.

To create a new project with Hono, use the `bun create` command followed by `hono@latest` and your desired project name.

```sh
bun create hono@latest my-app
sh
cd my-app
bun install
sh
bun add hono
```

- Ensure that Bun is properly installed and updated to the latest version before creating or setting up a project with Hono.

- [Bun Documentation](https://bun.js.org/)
- [Hono Documentation](https://hono.eclipse.org/)

- Starting a new project with Hono and Bun.
- Adding Hono to an existing Bun project.

#### Code Snippet

```typescript

Next, navigate into your new project directory and install the dependencies with `bun install`.

```

**Reasoning:** This rule is important as it demonstrates how to create a new project with Hono using Bun, how to set up an existing project with Hono, and how to install the necessary dependencies. Understanding this rule is crucial for developers to get started with Hono and Bun.

*Source: docs/getting-started/bun.md*

### Installing Hono Dependencies with Bun and Creating a Simple Hono Application

This code snippet demonstrates how to install Hono dependencies in an existing project using Bun, a package manager for Deno. It also shows how to create a simple 'Hello World' application using Hono.

```sh
bun add hono
ts
import { Hono } from 'hono'

const app = new Hono()
app.get('/', (c) => c.text('Hello Bun!'))
```

1. Navigate to the project directory (`cd my-app`)
2. Install the dependencies using Bun (`bun install`)
3. Add Hono dependencies to the project (`bun add hono`)
4. Import the Hono module and create a new Hono application
5. Define a GET route for the application that responds with 'Hello Bun!'

- Bun is a package manager for Deno, and it's used to manage and install dependencies for your Deno projects.
- Hono is a web framework for Deno.

- [Bun Package Manager](https://github.com/erfanium/bun)
- [Hono Web Framework](https://github.com/honots/hono)

- Setting up a new Hono project
- Adding Hono dependencies to an existing project
- Creating a simple Hono application

**Reasoning:** This rule is important as it demonstrates how to set up an existing project with Hono dependencies using Bun, a package manager for Deno. It also shows how to create a simple 'Hello World' application using Hono.

*Source: docs/getting-started/bun.md*

### Creating, Running, and Changing Port of a Basic Hono Application

This code snippet demonstrates how to create a basic Hono application, run it, and change the port number.

```ts
import { Hono } from 'hono'

const app = new Hono()
app.get('/', (c) => c.text('Hello Bun!'))

export default app
```

To run the application, use the command `bun run dev`. Then, access `http://localhost:3000` in your browser.

You can specify the port number with exporting the `port`.

1. The `Hono` class is imported from the `hono` package.
2. An instance of `Hono` is created.
3. The `get` method of the `Hono` instance is used to handle HTTP GET requests to the root URL ('/'). The callback function takes a context object `c` and sends a text response 'Hello Bun!'.
4. The `Hono` instance is exported.

- The `Hono` class is the main class for creating Hono applications.
- The `get` method is used to handle HTTP GET requests.
- The context object `c` represents the HTTP request and response.

- [Hono documentation](https://hono.bun.dev/)

- Creating a basic Hono application
- Handling HTTP GET requests
- Changing the port number of a Hono application

**Reasoning:** This rule is important as it demonstrates how to create a basic Hono application, run it, and change the port number. It shows the basic structure of a Hono application and how to handle HTTP GET requests.

*Source: docs/getting-started/bun.md*

### Setting Up and Running a Basic Hono Application

This code snippet demonstrates how to set up a basic Hono application, run it, and change the port number.

```ts
import { Hono } from 'hono'

const app = new Hono()
app.get('/', (c) => c.text('Hello Bun!'))

export default app
sh
bun run dev
```

Then, access `http://localhost:3000` in your browser.

To change the port number, you can specify it with exporting the `port`.

The `Hono` class is imported from the `hono` package. An instance of `Hono` is created and a GET route is set up for the root URL (`/`). The route returns the text 'Hello Bun!'. The application is then exported for use elsewhere.

The `bun run dev` command is used to start the application in development mode.

- The default port for Hono applications is 3000. To use a different port, you need to specify it when running the application.

- [Hono Documentation](https://hono.bun.dev/docs)

- Setting up a basic Hono application for development.
- Changing the port number for a Hono application.

#### Code Snippet

```typescript

To run the application, use the command:

```

**Reasoning:** This rule is important as it demonstrates how to set up a basic Hono application, run it, and change the port number. Understanding this is fundamental to getting started with the Hono web framework.

*Source: docs/getting-started/bun.md*

### Changing the Default Port Number in Hono

In Hono, the default port number can be changed by exporting an object with the 'port' property. Here is a code snippet demonstrating this:

```ts
import { Hono } from 'hono'

const app = new Hono()
app.get('/', (c) => c.text('Hello Bun!'))

export default app // [!code --]
export default { // [!code ++]
  port: 3000, // [!code ++]
  fetch: app.fetch, // [!code ++]
} // [!code ++]
```

1. Import the Hono framework.
2. Create a new Hono application.
3. Define a route.
4. Instead of exporting the app directly, export an object with the 'port' property set to the desired port number.

- The 'port' property should be a number.
- The 'fetch' property should be set to 'app.fetch'.

- [Hono Documentation](https://hono.bun.dev/)

- Running the application in different environments with different port numbers.

**Reasoning:** This rule is important as it demonstrates how to change the default port number in a Hono application. By exporting an object with the 'port' property, developers can specify the port number their application should run on. This is crucial for configuring the application to run in different environments.

*Source: docs/getting-started/bun.md*

### Serving Static Files in Hono

This code snippet demonstrates how to serve static files using Hono web framework.

```ts
import { serveStatic } from 'hono/bun'

const app = new Hono()

app.use('/static/*', serveStatic({ root: './' }))
app.use('/favicon.ico', serveStatic({ path: './favicon.ico' }))
app.get('/', (c) => c.text('You can access: /static/hello.txt'))
app.get('*', serveStatic({ path: './static/fallback.txt' }))
```

1. The `serveStatic` function from `hono/bun` is imported.
2. A new instance of Hono is created.
3. The `app.use` function is used to specify the path for serving static files. The `serveStatic` function is used with a configuration object that specifies the root directory for the static files.
4. The `app.get` function is used to define routes and their handlers. In this case, the root route (`/`) returns a text message, and all other routes (`*`) serve a fallback static file.

- The `serveStatic` function takes a configuration object that can have `root` or `path` properties. The `root` property specifies the root directory for the static files, and the `path` property specifies the path to a specific static file.

- [Hono Documentation](https://hono.bun.dev/)

- Serving static assets like images, scripts, and stylesheets in a web application.
- Serving a default file for non-existing routes.

**Reasoning:** This rule is important as it demonstrates how to serve static files using Hono web framework. Serving static files is a common requirement in many web applications, and understanding how to do this in Hono is crucial for developers.

*Source: docs/getting-started/bun.md*

### Serving Static Files and Rewriting Request Paths in Hono

In Hono, you can serve static files and rewrite request paths using the `serveStatic` and `rewriteRequestPath` options respectively. This is useful for managing static assets such as images, CSS files, and JavaScript files.

Here's an example of how to serve a static file:

```ts
app.get('*', serveStatic({ path: './static/fallback.txt' }))
ts
app.get(
  '/static/*',
  serveStatic({
    root: './statics',
    rewriteRequestPath: (req, res) => {
      return req.path.replace('/static', '');
    },
  }),
);
```

In this example, any GET request to `http://localhost:3000/static/*` will be served with the corresponding file from the `./statics` directory.

- The `serveStatic` option serves static files from a specified directory.
- The `rewriteRequestPath` option rewrites request paths based on a specified function.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Serving static assets in a Hono application.
- Rewriting request paths in a Hono application.

#### Code Snippet

```typescript

In this example, any GET request will be served with the `fallback.txt` file from the `./static` directory.

If you want to map `http://localhost:3000/static/*` to `./statics`, you can use the `rewriteRequestPath` option:

```

**Reasoning:** This rule is important as it demonstrates how to serve static files in a Hono application and how to rewrite request paths. Understanding this rule is crucial for managing static assets such as images, CSS files, and JavaScript files in a Hono application.

*Source: docs/getting-started/bun.md*

### Using 'rewriteRequestPath' to Map URL Paths to Local Directories in Hono

This rule demonstrates how to use the 'rewriteRequestPath' option in Hono to map a URL path to a local directory. This is useful when you want to serve static files from a specific directory in your project.

```ts
app.get(
  '/static/*',
  serveStatic({
    root: './',
    rewriteRequestPath: (path) =>
      path.replace(/^\/static/, '/statics'),
  })
)
```

The 'rewriteRequestPath' function takes a path as an argument and returns a new path. In this case, it's replacing '/static' with '/statics'. This means that any request to 'http://localhost:3000/static/*' will be served from the './statics' directory.

- The 'rewriteRequestPath' function is a powerful tool that allows you to customize how your server responds to different URL paths.

- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)

- Serving static files from a specific directory in your project.
- Mapping URL paths to local directories for better organization of your project.

**Reasoning:** This rule is important as it demonstrates how to use the 'rewriteRequestPath' option in Hono to map a URL path to a local directory. This is useful when you want to serve static files from a specific directory in your project.

*Source: docs/getting-started/bun.md*

### Handling Static Files in Hono

This code snippet demonstrates how to serve static files in Hono and handle different scenarios.

```ts
app.get(
  '/static/*',
  serveStatic({
    mimes: {
      m3u8: 'application/vnd.apple.mpegurl',
      ts: 'video/mp2t',
    },
    onFound: (_path, c) => {
      c.header('Cache-Control', `public, immutable, max-age=31536000`)
    },
    onNotFound: (path, c) => {
      console.log(`${path} not found`)
    },
  })
)
```

1. The `app.get` method is used to define a route for serving static files.
2. The `serveStatic` function is used to serve static files. It takes an options object as an argument.
3. The `mimes` option is used to specify custom MIME types.
4. The `onFound` option is used to specify handling when the requested file is found. In this case, it sets the 'Cache-Control' header.
5. The `onNotFound` option is used to specify handling when the requested file is not found. In this case, it logs a message.

- The `onFound` and `onNotFound` options are optional. If not provided, Hono will use default handling.

- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)

- Serving static files such as images, CSS files, and JavaScript files.
- Setting custom MIME types for certain file extensions.
- Customizing response headers for static files.
- Customizing error handling for not found static files.

**Reasoning:** This rule is important as it demonstrates how to handle different scenarios when serving static files in Hono. It shows how to set custom MIME types, how to handle the scenario when a requested file is found, and how to handle the scenario when a requested file is not found. Understanding these patterns is crucial for building robust web applications with Hono.

*Source: docs/getting-started/bun.md*

### Handling Not Found Errors in Hono

This code snippet demonstrates how to handle not found errors in Hono framework. It uses the 'onNotFound' option in the 'serveStatic' method to specify a custom error handling function when the requested file is not found.

```ts
app.get(
  '/static/*',
  serveStatic({
    onNotFound: (path, c) => {
      console.log(`${path} is not found, you access ${c.req.path}`)
    },
  })
)
```

When a request is made to a path that does not exist, the function specified in the 'onNotFound' option is called. This function takes two arguments: the path that was not found and the context object 'c'. In this example, a message is logged to the console indicating the path that was not found and the path that was accessed.

- The 'onNotFound' option is only called when the requested file is not found. If the file exists, this function is not called.

- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)

- Custom error handling when a file is not found
- Logging for debugging purposes

**Reasoning:** This rule is important as it demonstrates how to handle not found errors in Hono framework. It shows how to use the 'onNotFound' option in the 'serveStatic' method to specify a custom error handling function when the requested file is not found.

*Source: docs/getting-started/bun.md*

### Serving Static Files with Precompression in Hono

This code snippet demonstrates how to serve static files with precompression in Hono framework.

```ts
app.get(
  '/static/*',
  serveStatic({
    precompressed: true,
  })
)
```

The 'serveStatic' middleware is used with the 'precompressed' option set to true. This means that if precompressed versions of the files with extensions like `.br` or `.gz` are available, they will be served based on the `Accept-Encoding` header. The middleware prioritizes Brotli, then Zstd, and Gzip. If none are available, it serves the original file.

- The static files need to be precompressed and available in the same directory as the original files.
- The 'Accept-Encoding' header of the request is used to determine which precompressed version of the file to serve.

- [Hono serveStatic middleware documentation](https://hono.bun.dev/middlewares/serveStatic)

- Serving static assets like CSS, JavaScript, and image files in a web application.

**Reasoning:** This rule is important as it demonstrates how to serve static files with precompression in Hono framework. It shows the usage of the 'serveStatic' middleware with the 'precompressed' option set to true. This can significantly improve the performance of a web application by reducing the size of the files that need to be transferred over the network.

*Source: docs/getting-started/bun.md*

### Serving Static Files with Precompression and Testing Server Response in Hono

This code demonstrates how to serve static files with precompression in Hono and how to test the server response using the Bun testing framework.

```ts
app.get(
  '/static/*',
  serveStatic({
    precompressed: true,
  })
)
ts
import { describe, expect, it } from 'bun:test'
import app from '.'

describe('My first test', () => {
  it('Should return 200 Response', async () => {
    const req = new Request('http://localhost/')
    const res = await app.fetch(req)
    expect(res.status).toBe(200)
  })
})
```

In this test, a new request is created and sent to the server using `app.fetch`. The response status is then checked to be 200, indicating a successful request.

- Ensure that precompressed versions of the files are available when using the `precompressed` option.
- Always validate server responses during development to ensure correct server behavior.

- [Hono Documentation](https://hono.bun.dev/)
- [Bun Testing Framework](https://bun.dev/docs/testing)

- Serving static files in a web application.
- Testing server responses during development.

#### Code Snippet

```typescript

In the above snippet, `app.get` is used to handle GET requests to any route that matches '/static/*'. The `serveStatic` function is used with the `precompressed` option set to true, which means that it will serve precompressed versions of the files if they are available.

To test the server response, the Bun testing framework is used as shown below:

```

**Reasoning:** This rule is important as it demonstrates how to serve static files with precompression and how to test the server response using the Bun testing framework. Understanding this rule ensures efficient delivery of static content and helps in validating server responses during development.

*Source: docs/getting-started/bun.md*

### Writing and Running Basic Tests in Hono

This rule demonstrates how to write a basic test in Hono and run it using the 'bun test' command.

```sh
'Should return 200 Response', async () => {
    const req = new Request('http://localhost/')
    const res = await app.fetch(req)
    expect(res.status).toBe(200)
  })
})
sh
bun test index.test.ts
```

1. A new Request object is created with the URL of the local server.
2. The 'fetch' method of the 'app' object is used to send the request and the response is awaited.
3. The 'expect' function is used to assert that the status code of the response is 200.
4. The test is run using the 'bun test' command, specifying the test file to run.

- The 'fetch' method returns a Promise that resolves to the Response to that request, whether it is successful or not.

- [Hono Documentation](https://www.eclipse.org/hono/)

- Testing the response of a server to a certain request.
- Checking the status code of a response to ensure it is as expected.

#### Code Snippet

```typescript

Then, run the command.

```

**Reasoning:** This rule is important as it demonstrates how to write and execute a basic test in Hono. Testing is a crucial part of software development to ensure the code behaves as expected. This rule shows how to create a simple test that checks if a request to the local server returns a 200 status code, indicating a successful HTTP request. The test is then run using the 'bun test' command.

*Source: docs/getting-started/bun.md*

### Creating a New Hono Application and Selecting a Template

This code snippet demonstrates how to create a new Hono application and select a template for the application.

```sh
yarn create hono my-app
sh
pnpm create hono@latest my-app
sh
bun create hono@latest my-app
sh
deno init --npm hono@latest my-app

? Which template do you want to use?
    aws-lambda
    bun
    cloudflare-pages
❯   cloudflare-workers
    deno
    fastly
    nextjs
    nodejs
    vercel
```

The `create` command initializes a new Hono application in the directory specified (in this case, 'my-app'). The `@latest` flag ensures you are using the latest version of Hono. After initialization, you are prompted to select a template for your application. The template you choose will shape the structure and functionality of your application.

- Ensure you have the necessary package manager (yarn, pnpm, bun, or deno) installed before running the `create` command.

- [Hono Documentation](https://hono.bun.dev/)

- Initializing a new Hono application
- Selecting a template for a new Hono application

#### Code Snippet

```typescript

or

```

**Reasoning:** This rule is important as it demonstrates how to create a new Hono application and select a template for the application. This is a fundamental step in getting started with the Hono framework.

*Source: docs/getting-started/basic.md*

### Navigating to Project Directory and Installing Dependencies in Hono

After selecting the template for your Hono project, the next step is to navigate to the project directory and install the necessary dependencies. This can be done using various package managers like npm, yarn, pnpm, or bun.

Here is the code snippet demonstrating this:

```sh

cd my-app
npm i

cd my-app
yarn

cd my-app
pnpm i

cd my-app
bun i
```

1. `cd my-app` - This command navigates to the `my-app` directory.
2. `npm i`, `yarn`, `pnpm i`, `bun i` - These commands install the dependencies listed in the `package.json` file.

- Make sure to use the correct command for the package manager you are using.
- The dependencies must be installed before you can start working on the project.

- [Hono Documentation](https://hono.bun.dev/)

- Setting up a new Hono project
- Installing additional dependencies in an existing Hono project

**Reasoning:** This rule is important as it demonstrates how to navigate to the project directory and install the dependencies in a Hono project. It is a fundamental step in setting up a new project, regardless of the package manager being used.

*Source: docs/getting-started/basic.md*

### Navigating to Application Directory, Installing Dependencies, and Starting a Local Server in Hono

The code snippet demonstrates how to navigate to the application directory (`my-app`) and install dependencies using different package managers (`npm`, `yarn`, `pnpm`, `bun`).

```sh

cd my-app
npm i

cd my-app
yarn

cd my-app
pnpm i

cd my-app
bun i
sh

npm run dev

yarn dev

pnpm dev

bun run dev
```

The `cd` command is used to navigate to the application directory. The `i` or `install` command is used to install the dependencies listed in the `package.json` file. The `run dev` command is used to start a local server.

- Ensure that the correct package manager is used for installing dependencies and starting the server.

- [npm documentation](https://docs.npmjs.com/)
- [yarn documentation](https://yarnpkg.com/getting-started)
- [pnpm documentation](https://pnpm.io/)
- [bun documentation](https://bun.js.org/)

- Setting up a new Hono application
- Running a Hono application locally

#### Code Snippet

```typescript

## Starting a Local Server

Once the package installation is complete, the following commands can be used to start a local server.

```

**Reasoning:** This rule is important as it demonstrates how to navigate to the application directory and install dependencies using different package managers. It also shows how to start a local server. Understanding this is crucial for setting up and running a Hono application.

*Source: docs/getting-started/basic.md*

### Creating a Basic Hono Application

This code snippet demonstrates how to create a basic Hono application.

```ts
import { Hono } from 'hono'

const app = new Hono()

app.get('/', (c) => {
  return c.text('Hello Hono!')
})

export default app
```

1. The Hono module is imported.
2. A new instance of Hono is created.
3. A GET route is defined on the root path ('/'). When this route is hit, it returns a text response 'Hello Hono!'.
4. The Hono application is exported.

The `import` and the final `export default` parts may vary from runtime to runtime, but all of the application code will run the same code everywhere.

- [Hono Documentation](https://hono.bun.dev/)

- Creating a new Hono application
- Defining routes in a Hono application

**Reasoning:** This rule is important as it demonstrates how to create a basic Hono application. It shows how to import the Hono module, instantiate it, define a route, and export the application. This is a fundamental pattern in Hono framework usage that every developer should understand.

*Source: docs/getting-started/basic.md*

### Basic Setup and Usage of Hono Web Framework

This code demonstrates the basic setup and usage of the Hono web framework.

```ts
import { Hono } from 'hono'

const app = new Hono()

app.get('/', (c) => {
  return c.text('Hello Hono!')
})

export default app
sh
npm run dev
sh
yarn dev
sh
pnpm dev
sh
bun run dev
```

Then, access `http://localhost:8787` with your browser.

1. The `Hono` class is imported from the 'hono' module.
2. A new instance of `Hono` is created and assigned to the `app` variable.
3. The `get` method of the `app` object is used to define a route that responds to HTTP GET requests at the root URL ('/'). The route handler function takes a context object `c` and returns a text response 'Hello Hono!'.
4. The `app` object is exported for use in other modules.

- The route handler function can return a response in different formats, such as text, HTML, or JSON, using the appropriate methods of the context object.

- [Hono documentation](https://hono.bun.dev/)

- Building a simple web server with Hono
- Defining routes and route handlers in a Hono application

#### Code Snippet

```typescript

To start the development server, use one of the following commands based on your package manager:

```

**Reasoning:** This rule is important as it demonstrates the basic setup and usage of the Hono web framework. It shows how to create a new Hono application, define a simple GET route, and start the development server. Understanding this basic pattern is crucial for building applications with Hono.

*Source: docs/getting-started/basic.md*

### Handling GET Requests and Returning JSON Response in Hono

This code snippet demonstrates how to handle a GET request and return a JSON response in the Hono framework.

```ts
app.get('/api/hello', (c) => {
  return c.json({
    ok: true,
    message: 'Hello Hono!',
  })
})
```

In this code snippet, `app.get` is used to handle a GET request to the `/api/hello` endpoint. The callback function takes a context object `c` as an argument, which is used to return a JSON response using `c.json` method.

The `c.json` method sets the Content-Type header to `application/json` and sends the response.

- [Hono Documentation](https://hono.bayrell.org/en/)

This pattern is commonly used when building APIs that need to return JSON data.

**Reasoning:** This rule is important as it demonstrates how to handle a GET request and return a JSON response in the Hono framework. Understanding this rule is crucial for building APIs that return JSON data.

*Source: docs/getting-started/basic.md*

### Handling GET Requests and Manipulating Responses in Hono

The following code snippets demonstrate how to handle GET requests and manipulate responses in Hono.

To handle a GET request to `/api/hello` and return a JSON response, you can use the `get` method of the `app` object and the `json` method of the context `c`:

```ts
app.get('/api/hello', (c) => {
  return c.json({
    ok: true,
    message: 'Hello Hono!',
  })
})
ts
app.get('/posts/:id', (c) => {
  const page = c.req.query('page')
  const id = c.req.param('id')
  c.header('X-Message', 'Hi!')
  return c.text(`You want to see ${page} of ${id}`)
})
```

In Hono, the `app.get` method is used to handle GET requests. The first argument is the path, and the second argument is a callback function that takes a context `c` as its argument. The context `c` has several methods to manipulate the request and the response. The `req.query` method is used to get a URL query value, the `req.param` method is used to get a path parameter, and the `header` method is used to append a response header.

- The `req.query` and `req.param` methods return `undefined` if the specified query or parameter does not exist.
- The `header` method does not return anything.

- [Hono Documentation](https://hono.boutell.com/)

- Building APIs that handle GET requests.
- Building APIs that need to extract path parameters and query values.
- Building APIs that need to manipulate response headers.

#### Code Snippet

```typescript

To get a path parameter, a URL query value, and append a response header, you can use the `req` and `header` methods of the context `c`:

```

**Reasoning:** This rule is important as it demonstrates how to handle GET requests, extract path parameters and query values, and append response headers in Hono. Understanding this rule is crucial for building APIs with Hono as it forms the basis of request-response handling.

*Source: docs/getting-started/basic.md*

### Handling Different HTTP Methods and Responses in Hono

This code snippet demonstrates how to handle different HTTP methods such as GET, POST, DELETE in Hono framework. It also shows how to extract parameters from the request and how to set headers and return responses in different formats.

```ts
app.get('/posts/:id', (c) => {
  const page = c.req.query('page')
  const id = c.req.param('id')
  c.header('X-Message', 'Hi!')
  return c.text(`You want to see ${page} of ${id}`)
})

app.post('/posts', (c) => c.text('Created!', 201))
app.delete('/posts/:id', (c) =>
  c.text(`${c.req.param('id')} is deleted!`)
)
```

1. `app.get`, `app.post`, `app.delete` are used to handle GET, POST, DELETE requests respectively.
2. `c.req.query` is used to get query parameters from the request.
3. `c.req.param` is used to get route parameters from the request.
4. `c.header` is used to set response headers.
5. `c.text` is used to return a text response.

- Make sure to return a response in the handler function, otherwise the request will hang.

- [Hono Documentation](https://hono.boutell.com/)

- Building RESTful APIs with different HTTP methods.
- Returning different types of responses based on the request.

**Reasoning:** This rule is important as it demonstrates how to handle different HTTP methods such as GET, POST, DELETE in Hono framework. It also shows how to extract parameters from the request and how to set headers and return responses in different formats.

*Source: docs/getting-started/basic.md*

### Handling HTTP Methods and Returning HTML in Hono

This code snippet demonstrates how to handle different HTTP methods and return HTML or JSX in a Hono application.

```ts
app.post('/posts', (c) => c.text('Created!', 201))
app.delete('/posts/:id', (c) =>
  c.text(`${c.req.param('id')} is deleted!`)
)
tsx
const View = () => {
  return (
    <html>
      <body>
        <h1>Hello Hono!</h1>
      </body>
    </html>
  )
}

app.get('/page', (c) => {
  return c.html(<View />)
})
```
In the above code, we define a GET route that returns an HTML response. The HTML is defined using JSX syntax.

- To use JSX, rename the file to `src/index.tsx` and configure it. The configuration may vary depending on the runtime.
- You can also write HTML using the html Helper.

- [Hono Documentation](https://hono.boutell.com/)

- Building RESTful APIs with different HTTP methods.
- Returning HTML or JSX from a Hono application.

#### Code Snippet

```typescript
In the above code, we define routes for POST and DELETE methods. The POST route creates a new post and returns a text response with status code 201. The DELETE route deletes a post with a specific id and returns a text response.

```

**Reasoning:** This rule is important as it demonstrates how to handle different HTTP methods such as POST, DELETE and GET in Hono, and how to return HTML or JSX from a Hono application. Understanding these patterns is crucial for building web applications using the Hono framework.

*Source: docs/getting-started/basic.md*

### Creating a Basic Hono Application, Returning Raw Responses and Using Middleware

This rule demonstrates how to create a basic Hono application, return raw responses and use middleware for tasks like authentication.

```tsx
const View = () => {
  return (
    <html>
      <body>
        <h1>Hello Hono!</h1>
      </body>
    </html>
  )
}

app.get('/page', (c) => {
  return c.html(<View />)
})
ts
app.get('/', () => {
  return new Response('Good morning!')
})
ts
import { basicAuth
```

1. The `View` function returns a JSX component which is rendered as HTML.
2. The `app.get` function sets up a route handler for the '/page' route, which returns the rendered HTML.
3. The raw Response can be returned directly from the route handler.
4. Middleware functions can be imported and used to handle common tasks like authentication.

- JSX components must be transpiled to JavaScript before they can be used in a Hono application.
- Middleware functions are executed in the order they are defined.

- [Hono Documentation](https://hono.bayfront.cloud/)
- [MDN Response Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Response)

- Building a simple web page with Hono
- Returning raw responses for simple text responses
- Using middleware for authentication

#### Code Snippet

```typescript

You can also return the raw Response.

```

**Reasoning:** This rule is important as it demonstrates how to create a basic Hono application, return raw responses and use middleware for tasks like authentication. Understanding these concepts is crucial for building and managing applications using the Hono framework.

*Source: docs/getting-started/basic.md*

### Using Middleware for Basic Authentication in Hono

This code snippet demonstrates how to use middleware in Hono to add Basic Authentication to a route.

```ts
import { basicAuth } from 'hono/basic-auth'

// ...

app.use(
  '/admin/*',
  basicAuth({
    username: 'admin',
    password: 'secret',
  })
)

app.get('/admin', (c) => {
  return c.text('You are authenticated!')
})
```

The `app.use` function is used to apply middleware to routes. The first argument is the route pattern, and the second argument is the middleware function. In this case, the `basicAuth` middleware is used, which requires a username and password.

- Middleware functions are executed in the order they are added.
- Middleware can be applied to specific routes or to all routes.

- [Hono Documentation](https://hono.beyondnlp.com/)

- Protecting routes with Basic Authentication
- Applying logging or error handling middleware to all routes

**Reasoning:** This rule is important as it demonstrates how to use middleware in Hono for adding Basic Authentication to routes. Middleware can handle complex tasks and improve code reusability and organization. In this case, the basicAuth middleware is used to protect the '/admin/*' route by requiring a username and password.

*Source: docs/getting-started/basic.md*

### Using Middleware and Adapters in Hono

This code snippet demonstrates the use of built-in and third-party middleware in Hono, as well as handling platform-dependent functions using Adapters.

```text
There are useful built-in middleware including Bearer and authentication using JWT, CORS and ETag.
Hono also provides third-party middleware using external libraries such as GraphQL Server and Firebase Auth.
And, you can make your own middleware.

There are Adapters for platform-dependent functions, e.g., handling static files or WebSocket.
For example, to handle WebSocket in Cloudflare Workers, import `hono/cloudflare-workers`.
```

Middleware in Hono can be used to handle requests and responses. Built-in middleware includes Bearer and JWT authentication, CORS, and ETag. Hono also supports third-party middleware from external libraries such as GraphQL Server and Firebase Auth. You can also create custom middleware.

Adapters in Hono are used for platform-dependent functions, such as handling static files or WebSocket. For instance, to handle WebSocket in Cloudflare Workers, you can import the `hono/cloudflare-workers` Adapter.

- Middleware is crucial for handling requests and responses in Hono.
- Adapters allow for platform-specific functionality in Hono.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Using built-in middleware for authentication, CORS, and ETag.
- Using third-party middleware from external libraries.
- Handling platform-dependent functions using Adapters.

**Reasoning:** This rule is important as it demonstrates how to use built-in and third-party middleware in Hono, and how to handle platform-dependent functions using Adapters. Middleware is crucial for handling requests and responses, while Adapters allow for platform-specific functionality.

*Source: docs/getting-started/basic.md*

### Creating a New Project Directory in Vite

This code snippet demonstrates how to create a new project directory when starting a new Vite project.

```sh
mkdir my-app
cd my-app
```

1. `mkdir my-app`: This command creates a new directory named 'my-app'.
2. `cd my-app`: This command changes the current working directory to 'my-app'.

- Ensure you have the necessary permissions to create and access the directory.

- [Vite Documentation](https://vitejs.dev/guide/)

- Starting a new Vite project
- Creating a new directory for any project

**Reasoning:** This rule is important as it demonstrates the initial steps to create a new project directory for a Vite project. Understanding these steps is crucial for setting up the project structure correctly.

*Source: docs/getting-started/service-worker.md*

### Creating a Basic package.json File in Hono

The following code snippet demonstrates how to create a basic `package.json` file for a new project in Hono:

```json
{
  "name": "my-app",
  "private": true,
  "scripts": {
    "dev": "vite dev"
  },
  "type": "module"
}
```

1. `name`: This is the name of your application. It should be lowercase and one word, but hyphens and underscores can be used.
2. `private`: This is a safety measure to prevent accidental publication of private repositories. When set to true, this option prevents the package from being accidentally published on npm.
3. `scripts`: This is where you can define script commands that are part of your application's lifecycle. In this case, the `dev` command is used to start the development server.
4. `type`: This field signifies that the code should be treated as ECMAScript modules.

- The `package.json` file is a crucial part of any Node.js project and should be set up correctly.

- [npm documentation on package.json](https://docs.npmjs.com/cli/v7/configuring-npm/package-json)

- Setting up a new Node.js project
- Defining project metadata and configuration

**Reasoning:** This rule is important as it demonstrates how to set up a basic package.json file for a new project in Hono. The package.json file is a crucial part of any Node.js project as it holds various metadata relevant to the project. This file is used to give information to npm that allows it to identify the project as well as handle the project's dependencies. It can also contain other metadata such as a project description, the version of the project in a particular distribution, license information, even configuration data - all of which can be vital to both npm and to the end users of the package.

*Source: docs/getting-started/service-worker.md*

### Setting up a new Hono project

When starting a new Hono project, it's necessary to create a `package.json` and a `tsconfig.json` file with the appropriate configurations.

The `package.json` file should look like this:

```json
{
  "name": "my-app",
  "private": true,
  "scripts": {
    "dev": "vite dev"
  },
  "type": "module"
}
json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "WebWorker"],
    "moduleResolution": "bundler"
  },
  "include": ["./"],
  "exclude": ["node_modules"]
}
sh
npm i hono
npm i -D vite
sh
yarn add hono
yarn add -D vite
sh
pnpm add hono
pnpm add -D vite
```

This setup is crucial for the proper functioning of a Hono project.

#### Code Snippet

```typescript

The `tsconfig.json` file should look like this:

```

**Reasoning:** This rule is important as it demonstrates how to set up a new Hono project with the necessary configuration files and dependencies. The `package.json` file is used to define the project and its scripts, while the `tsconfig.json` file is used to specify the TypeScript compiler options. The installation commands show how to add the Hono and Vite packages to the project.

*Source: docs/getting-started/service-worker.md*

### Installing Hono and Setting Up a Basic Page

This code snippet demonstrates how to install the Hono framework and its dependencies using different package managers, and how to set up a basic 'Hello World' page.

```sh
npm i hono
npm i -D vite
sh
yarn add hono
yarn add -D vite
sh
pnpm add hono
pnpm add -D vite
sh
bun add hono
bun add -D vite
html
<!doctype html>
<html>
  <body>
    <a href="/sw">Hello World by Service Worker</a>
    <script type="module" src="/main.ts"></script>
  </body>
</html>
```

The first part of the code installs Hono and its dependencies using npm, yarn, pnpm, or bun. The `-D` flag in the installation command is used to save the package for development purpose only.

The second part of the code sets up a basic 'Hello World' page. The `index.html` file is edited to include a link that displays 'Hello World by Service Worker' and a script tag that links to `main.ts`.

- Make sure to install the correct version of Hono and its dependencies.
- The `main.ts` file should be properly set up for the script tag in `index.html` to work correctly.

- [Hono Documentation](https://hono.bike/docs)

- Setting up a new Hono project
- Installing dependencies for a Hono project

#### Code Snippet

```typescript

or

```

**Reasoning:** This rule is important as it demonstrates how to install the Hono framework and its dependencies using different package managers, and how to set up a basic 'Hello World' page using Hono. Understanding this rule is crucial for developers to get started with Hono and to understand the basic structure of a Hono application.

*Source: docs/getting-started/service-worker.md*

### Registering a Hono Application to the Fetch Event with Service Worker Adapter's Handle Function

This code snippet demonstrates how to create an application using Hono and register it to the `fetch` event with the Service Worker adapter’s `handle` function. This allows the Hono application to intercept access to `/sw`.

```ts
// To support types
// https://github.com/microsoft/TypeScript/issues/14877
declare const self: ServiceWorkerGlobalScope

import { Hono } from 'hono'
import { handle } from 'hono/service-worker'
```

1. The `declare const self: ServiceWorkerGlobalScope` line is used to support types in TypeScript.
2. The `Hono` and `handle` functions are imported from the `hono` and `hono/service-worker` modules respectively.
3. The `handle` function is used to register the Hono application to the `fetch` event. This allows the application to intercept access to `/sw`.

- This setup is necessary for applications that need to use service workers for tasks like caching, offline functionality, etc.

- [TypeScript Issue #14877](https://github.com/microsoft/TypeScript/issues/14877)

- Caching assets for offline use
- Intercepting and modifying requests
- Background data synchronization

**Reasoning:** This rule is important as it demonstrates how to create an application using Hono and register it to the `fetch` event with the Service Worker adapter’s `handle` function. This is crucial for intercepting access to certain routes in the application, in this case `/sw`, which can be useful for caching strategies, offline functionality, or other service worker use cases.

*Source: docs/getting-started/service-worker.md*

### Setting Up a Basic Service Worker and Running the Development Server in Hono

This code snippet demonstrates how to set up a basic service worker using the Hono framework, and how to start the development server.

```text
import { Hono } from 'hono'
import { handle } from 'hono/service-worker'

const app = new Hono().basePath('/sw')
app.get('/', (c) => c.text('Hello World'))

self.addEventListener('fetch', handle(app))
sh
npm run dev
sh
yarn dev
sh
pnpm run dev
sh
bun run dev
```

By default, the development server will run on port `5173`.

The `Hono` class is imported from the 'hono' module, and the `handle` function is imported from 'hono/service-worker'. A new instance of `Hono` is created, with the base path set to '/sw'. A GET request handler is set up for the root path ('/'), which responds with the text 'Hello World'. The `fetch` event listener is added to the service worker, which uses the `handle` function to handle requests.

The development server is started using one of the provided commands, depending on the package manager being used.

- The `handle` function is a key part of setting up a service worker in Hono, as it handles incoming requests.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Setting up a basic service worker for a web application.
- Starting the development server for a web application.

#### Code Snippet

```typescript

To run the development server, use the following commands:

```

**Reasoning:** This rule is important as it demonstrates how to set up a basic service worker using the Hono framework, and how to start the development server. Understanding this is crucial for developers as service workers are a key component in creating reliable, fast web pages, and running the development server is a fundamental step in the development process.

*Source: docs/getting-started/service-worker.md*

### Initializing a Hono Project with Deno

This code snippet demonstrates how to initialize a new Hono project using Deno.

```sh
deno init --npm hono my-app
```

The `deno init --npm hono my-app` command initializes a new Hono project in a directory named `my-app`. This command sets up the necessary files and configurations for a Hono project.

- The `my-app` is the name of the directory that will be created for the new project. You can replace `my-app` with the name of your choice.

- For Deno, you don't have to install Hono explicitly.

- [Official Hono Documentation](https://docs.deno.com/runtime/manual/getting_started/installation)

- Setting up a new Hono project in a Deno environment.

**Reasoning:** This rule is important as it demonstrates how to initialize a new Hono project using Deno. It's a fundamental step for developers to start working with Hono in a Deno environment.

*Source: docs/getting-started/deno.md*

### Creating a Basic Hono Application in Deno

This code snippet demonstrates how to create a basic 'Hello World' application using the Hono framework in Deno.

```ts
import { Hono } from 'hono'

const app = new Hono()

app.get('/', (c) => c.text('Hello Deno!'))

Deno.serve(app.fetch)
```

1. The Hono module is imported.
2. A new Hono application is created.
3. A route is defined for the root URL ('/') that responds with the text 'Hello Deno!'.
4. The application is served using Deno's built-in server.

- For Deno, you don't have to install Hono explicitly.
- You can change the port number by updating the arguments of `Deno.serve`.

- [Hono Documentation](https://hono.bayrell.org/en/)
- [Deno Documentation](https://deno.land/manual)

- Creating a basic web application.
- Learning the structure of a Hono application.

**Reasoning:** This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono framework in Deno. It shows how to import the Hono module, create a new Hono application, define a route, and serve the application. Understanding this basic structure is crucial for building more complex applications using Hono.

*Source: docs/getting-started/deno.md*

### Creating, Running and Changing Port of a Hono Application

This code demonstrates how to create a basic Hono application, run it, and change the port number.

```ts
import { Hono } from 'hono'

const app = new Hono()

app.get('/', (c) => c.text('Hello Deno!'))

Deno.serve(app.fetch)
sh
deno task start
ts
Deno.serve(app.fetch) // default port
Deno.serve({ port: 8787 }, app.fetch) // custom port
```

1. The Hono application is created and a GET route is defined.
2. The application is served using Deno's built-in server.
3. The `deno task start` command is used to run the application.
4. The port number can be changed by passing an options object to `Deno.serve`.

- The `app.fetch` method is used to handle HTTP requests and responses.
- The `deno task start` command requires the `--allow-net` flag to allow network access.

- [Hono Documentation](https://hono.land)
- [Deno Documentation](https://deno.land)

- Creating a basic web server with Hono and Deno.
- Changing the port number of a Hono application.

#### Code Snippet

```typescript

To run the application, use the command:

```

**Reasoning:** This rule is important as it demonstrates how to create a basic Hono application, run it, and change the port number. Understanding this is fundamental to getting started with the Hono web framework in Deno.

*Source: docs/getting-started/deno.md*

### Serving an Application and Changing the Port Number in Hono using Deno

This code snippet demonstrates how to serve an application and change the port number in Hono using Deno. It also shows how to serve static files.

```ts
Deno.serve(app.fetch)
Deno.serve({ port: 8787 }, app.fetch)
```

The `Deno.serve` function is used to serve the application. The first argument can be an object that specifies the port number. If no port number is specified, the default port number is used.

To serve static files, the `serveStatic` function imported from `hono/middleware.ts` is used.

- The port number must be a number and not a string.
- The `serveStatic` function can only serve static files. It cannot be used to serve dynamic content.

- [Hono Documentation](https://hono.beyondnlp.com/docs)

- Serving a web application on a specific port number
- Serving static files in a web application

**Reasoning:** This rule is important as it demonstrates how to serve an application and change the port number in Hono using Deno. It also shows how to serve static files, which is a common requirement in web development. Understanding how to configure the port number and serve static files is crucial for setting up and managing a web server.

*Source: docs/getting-started/deno.md*

### Serving Static Files in Hono

This code demonstrates how to serve static files using the Hono web framework in Deno.

```ts
import { Hono } from 'hono'
import { serveStatic } from 'hono/deno'

const app = new Hono()

app.use('/static/*', serveStatic({ root: './' }))
app.use('/favicon.ico', serveStatic({ path: './favicon.ico' }))
app.get('/', (c) => c.text('You can access: /static/hello.txt'))
app.get('*', serveStatic({ path: './static/fallback.txt' }))

Deno.serve(app.fetch)
```

The `serveStatic` function from `hono/deno` is used to serve static files. The `app.use` and `app.get` methods are used to define routes and their corresponding handlers. The `serveStatic` function is used as a handler for these routes, and it takes an object as an argument that specifies the root directory or path of the static file to be served.

- The `serveStatic` function serves files from the specified root directory or path.
- The `app.use` method is used to define middleware functions that have access to the request object, the response object, and the next function in the application’s request-response cycle.

- [Hono Documentation](https://hono.land)

- Serving static assets like images, CSS files, and JavaScript files.
- Serving a default file as a fallback when no routes match.

**Reasoning:** This rule is important as it demonstrates how to serve static files using the Hono web framework in Deno. Serving static files is a common requirement in many web applications, and understanding how to do this in Hono can help developers build more efficient and performant applications.

*Source: docs/getting-started/deno.md*

### Serving Static Files and Handling Fallbacks in Hono

In Hono, you can serve static files from a directory and set a fallback file for any unmatched routes. Here is a code snippet that demonstrates this:

```ts
app.get('*', serveStatic({ path: './static/hello.txt' }))
app.get('*', serveStatic({ path: './static/fallback.txt' }))

Deno.serve(app.fetch)

./
├── favicon.ico
├── index.ts
└── static
    ├── demo
    │   └── index.html
    ├── fallback.txt
    ├── hello.txt
    └── images
        └── dinotocat.png
ts
app.get(
  '/static/*',
  serveStatic({
    root: '.
```

The `serveStatic` function serves static files from the specified path. If a route does not match any file, the fallback file is served.

The `rewriteRequestPath` option allows you to map a request path to a different directory structure.

- The `serveStatic` function and the `rewriteRequestPath` option are part of the Hono framework.
- The fallback file is served for any unmatched routes.

- [Hono Documentation](https://hono.bryntum.com/docs)

- Serving static resources like images, CSS files, and JavaScript files.
- Setting a default file to be served when no routes match.

#### Code Snippet

```typescript

This code will work well with the following directory structure:

```

**Reasoning:** This rule is important as it demonstrates how to serve static files and handle fallbacks in Hono. It also shows how to rewrite request paths to map to a different directory structure. Understanding this rule is crucial for managing static resources in a Hono application.

*Source: docs/getting-started/deno.md*

### Rewriting Request Paths in Hono

This code snippet demonstrates how to rewrite request paths in Hono. This is useful when you want to serve static files from a different directory than the one specified in the URL.

```ts
app.get(
  '/static/*',
  serveStatic({
    root: './',
    rewriteRequestPath: (path) =>
      path.replace(/^\/static/, '/statics'),
  })
)
```

The `rewriteRequestPath` option is a function that takes the request path as an argument and returns the new path. In this case, it replaces `/static` with `/statics` in the request path.

- The `rewriteRequestPath` function is called for every request, so it should be as efficient as possible.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Serving static files from a different directory than the one specified in the URL.

**Reasoning:** This rule is important as it demonstrates how to rewrite request paths in Hono. It shows how to map a URL pattern to a different directory in the server. This is useful when you want to serve static files from a different directory than the one specified in the URL.

*Source: docs/getting-started/deno.md*

### Serving Static Files and Adding MIME Types in Hono

This code snippet demonstrates how to serve static files and add MIME types in Hono framework.

```ts
app.get(
  '/static/*',
  serveStatic({
    root: './',
    rewriteRequestPath: (path) =>
      path.replace(/^\/static/, '/statics'),
  })
)
ts
app.get(
  '/static/*',
  serveStatic({
    mimes: {
      m3u8: 'application/vnd.apple.mpegurl',
      ts: 'video/mp2t',
    },
  })
)
```

In this code, MIME types for 'm3u8' and 'ts' files are added. This is important for the browser to handle the received content correctly.

- The `serveStatic` function is used to serve static files in Hono.
- The `rewriteRequestPath` function can be used to rewrite the request path.
- You can add MIME types using the `mimes` option.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Serving static files in a web application.
- Adding MIME types for specific file types.

#### Code Snippet

```typescript

In the above code, `app.get` is used to handle GET requests to the '/static/*' path. The `serveStatic` function is used to serve static files from the root directory. The `rewriteRequestPath` function is used to rewrite the request path by replacing '/static' with '/statics'.

You can also add MIME types with `mimes`:

```

**Reasoning:** This rule is important as it demonstrates how to serve static files and add MIME types in Hono framework. MIME types are essential for browsers to handle the received content correctly. The rule also shows how to rewrite the request path, which can be useful for redirecting requests or handling them differently based on the path.

*Source: docs/getting-started/deno.md*

### Handling Static Files in Hono

This code snippet demonstrates how to handle different scenarios when serving static files in Hono.

```ts
app.get(
  '/static/*',
  serveStatic({
    // ...
    onFound: (_path, c) => {
      c.header('Cache-Control', `public, immutable, max-age=31536000`)
    },
  })
)
```

In this example, the `onFound` handler is used to set a custom 'Cache-Control' header when a file is found. This can be useful for controlling how client browsers cache the static files.

It's also possible to define an `onNotFound` handler to handle situations when a file is not found. This could be used to log the event or return a custom error message.

- The `onFound` and `onNotFound` handlers provide a way to customize the behavior of the server when serving static files.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Serving static files such as images, stylesheets, and scripts in a web application.
- Setting custom headers for caching or other purposes.
- Customizing the error handling when a file is not found.

**Reasoning:** This rule is important as it demonstrates how to handle different scenarios when serving static files in Hono. It shows how to set custom headers when a file is found and how to handle situations when a file is not found. Understanding these handlers is crucial for building robust applications with proper error handling and response management.

*Source: docs/getting-started/deno.md*

### Handling File Not Found in Hono Framework

This code snippet demonstrates how to handle scenarios when a requested file is not found in Hono framework. It uses the 'onNotFound' option in 'serveStatic' method to log the path that was not found and the path that was accessed.

```ts
app.get(
  '/static/*',
  serveStatic({
    onNotFound: (path, c) => {
      console.log(`${path} is not found, you access ${c.req.path}`)
    },
  })
)
```

When a file is not found at the specified path, the 'onNotFound' function is triggered. This function takes two parameters - the path that was not found and the context 'c'. It then logs a message indicating the path that was not found and the path that was accessed.

- The 'onNotFound' option is a part of the 'serveStatic' method in Hono framework.
- The 'serveStatic' method is used to serve static files.

- [Hono Documentation](https://hono.bayrell.org/en)

- Logging file not found errors in a web application.

**Reasoning:** This rule is important as it demonstrates how to handle scenarios when a requested file is not found in Hono framework. It also shows how to use the 'onNotFound' option in 'serveStatic' method to log the path that was not found and the path that was accessed.

*Source: docs/getting-started/deno.md*

### Serving Static Files with Precompression in Hono

This code snippet demonstrates how to serve static files with precompression enabled in Hono.

```ts
app.get(
  '/static/*',
  serveStatic({
    precompressed: true,
  })
)
```

The `serveStatic` function is used with the `precompressed` option set to `true`. This tells Hono to check if precompressed versions of the files with extensions like `.br` or `.gz` are available and serve them based on the `Accept-Encoding` header. Hono prioritizes Brotli, then Zstd, and Gzip. If none are available, it serves the original file.

- The `precompressed` option should be used when you have precompressed versions of your static files available.
- The path '/static/*' is a wildcard path that matches any path starting with '/static/'. You can replace this with the path to your static files.

- [Hono Official Documentation](https://hono.boutell.com/)

- Serving static files such as images, stylesheets, and scripts in a web application.

**Reasoning:** This rule is important as it demonstrates how to serve static files in Hono with precompression enabled. Precompression can significantly reduce the size of the files being served, leading to faster load times and a better user experience. It also shows how Hono prioritizes different compression methods based on the 'Accept-Encoding' header.

*Source: docs/getting-started/deno.md*

### Adding a Dependency and Writing a Test in Hono

This code demonstrates how to add a dependency in Deno and how to write a basic test using the Hono framework.

First, add the `@std/assert` module using the `deno add` command:

```sh
deno add jsr:@std/assert
ts
import { Hono } from 'hono'
import { assertEquals } from '@std/assert'

Deno.test('Hello World', async () => {
  const app = new Hono()
  app.get('/', (c) => c.text('Please test me'))

  const
```

The `deno add` command adds the `@std/assert` module to your project. The `Deno.test` function is used to define a test, and the `assertEquals` function is used to assert that two values are equal.

- The `Deno.test` function is asynchronous, so you need to use the `await` keyword when calling it.

- [Deno Documentation](https://docs.deno.com/deploy/manual/)
- [Hono Documentation](https://hono.com)

- Writing tests for your Hono application

#### Code Snippet

```typescript

Then, write a test using the `Deno.test` function and the `assertEquals` function from the `@std/assert` module:

```

**Reasoning:** This rule is important as it demonstrates how to add a dependency in Deno and how to write a basic test using the Hono framework. It shows the usage of the `Deno.test` function and the `assertEquals` function from the `@std/assert` module. Understanding this rule is crucial for setting up tests for your Hono application.

*Source: docs/getting-started/deno.md*

### Writing and Running Tests in Deno using Hono and @std/assert

The following code snippet demonstrates how to write a simple test in Deno using the Hono framework and the assertEquals function from the @std/assert library.

```ts
import { Hono } from 'hono'
import { assertEquals } from '@std/assert'

Deno.test('Hello World', async () => {
  const app = new Hono()
  app.get('/', (c) => c.text('Please test me'))

  const res = await app.request('http://localhost/')
  assertEquals(res.status, 200)
})
sh
deno test hello.ts
```

1. The Hono framework is imported to create a new Hono application.
2. The assertEquals function from the @std/assert library is imported to assert that the response status is 200.
3. A new test is defined using the `Deno.test` function. The test creates a new Hono application, sets up a GET route, and makes a request to that route.
4. The assertEquals function is used to assert that the response status is 200, indicating a successful request.

- The @std/assert library provides a set of assertion functions for use in tests.
- The `Deno.test` function is used to define a test.

- [Deno Testing Documentation](https://deno.land/manual/testing)
- [Hono Documentation](https://hono.land/)

- Writing tests for a Hono application.
- Asserting that a request to a Hono application returns a successful response.

#### Code Snippet

```typescript

To run the test, use the `deno test` command followed by the filename.

```

**Reasoning:** This rule is important as it demonstrates how to write and run tests in Deno using the Hono framework and the assertEquals function from the @std/assert library. It is crucial to write tests for your application to ensure it behaves as expected.

*Source: docs/getting-started/deno.md*

### Creating and Testing a Basic Hono Application and Importing npm Packages in Deno

This code snippet demonstrates how to create a basic Hono application, handle a GET request, and test the application using Deno. It also shows how to import the Hono module using the `npm:` specifier in `deno.json`.

```sh
const app = new Hono()
app.get('/', (c) => c.text('Please test me'))

const res = await app.request('http://localhost/')
assertEquals(res.status, 200)
sh
deno test hello.ts
json
{
  "imports": {
    "hono": "npm:hono"
  }
}
```

1. A new Hono application is created.
2. A GET request handler is set up for the root URL ('/'). The handler sends a text response 'Please test me'.
3. The application is tested by sending a request to 'http://localhost/' and asserting that the response status is 200.
4. The `npm:` specifier is used to import the Hono module in `deno.json`.

- The `npm:` specifier allows you to import npm packages in Deno.

- [Hono Documentation](https://hono.bayrell.org/)
- [Deno Documentation](https://deno.land/)

- Creating a basic web application with Hono
- Testing a Hono application with Deno
- Importing npm packages in Deno

#### Code Snippet

```typescript

Then run the command:

```

**Reasoning:** This rule is important as it demonstrates how to create a basic Hono application, how to handle a GET request, and how to test the application using Deno. It also shows how to import the Hono module using the `npm:` specifier in `deno.json`.

*Source: docs/getting-started/deno.md*

### Importing Hono in a Deno Project

This code snippet demonstrates how to import the Hono library in a Deno project. You can use either the 'npm:' or 'jsr:' specifiers to import the library.

```json
{
  "imports": {
    "hono": "jsr:@hono/hono" // [!code --]
    "hono": "npm:hono" // [!code ++]
  }
}
```

In the 'deno.json' file, you specify the source of the Hono library. The 'npm:' specifier imports the library from the npm registry, while the 'jsr:' specifier imports it from the jsr registry.

- You can only use one specifier at a time. If you want to switch between specifiers, you need to comment out the current one and uncomment the other.
- If you want to use third-party middleware with TypeScript type inferences, you need to use the 'npm:' specifier.

- [Deno Manual - Import Maps](https://deno.land/manual/linking_to_external_code/import_maps)

- Setting up a new Deno project with Hono
- Switching between different versions or sources of the Hono library

**Reasoning:** This rule is important as it demonstrates how to import the Hono library in a Deno project using either the 'npm:' or 'jsr:' specifiers. This is crucial for setting up a project with Hono and understanding how to switch between different versions or sources of the library.

*Source: docs/getting-started/deno.md*

### Importing Third-Party Middleware in Hono

This code snippet demonstrates how to import third-party middleware in Hono using the `npm:` specifier.

```json
{
  "imports": {
    "hono": "npm:hono",
    "zod": "npm:zod",
    "@hono/zod-validator": "npm:@hono/zod-validator"
  }
}
```

In the `imports` object, each key represents the name of the module you want to import, and the value is the specifier that tells Hono where to find the module. In this case, we're using the `npm:` specifier to tell Hono to look for these modules in the npm registry.

- When using third-party middleware with TypeScript Type inferences, you need to use the `npm:` specifier.

- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)

- Importing validation libraries like `@hono/zod-validator` for input validation in your Hono applications.

**Reasoning:** This rule is important as it demonstrates how to import third-party middleware in Hono using the `npm:` specifier. This is crucial for leveraging external libraries and tools, such as the `@hono/zod-validator`, in your Hono projects.

*Source: docs/getting-started/deno.md*

### Creating a new Hono application and installing dependencies

This code snippet demonstrates how to create a new Hono application and install its dependencies using different package managers.

```sh
yarn create hono my-app
sh
pnpm create hono my-app
sh
bun create hono@latest my-app
sh
deno init --npm hono my-app
sh
cd my-app
npm i
sh
cd my-app
yarn
sh
cd my-app
pnpm i
sh
cd my-app
bun i
```

The `create` command is used to create a new Hono application. The `cd` command is used to move into the application directory. The `i` or `install` command is used to install the dependencies of the application.

Different package managers require slightly different commands to create a new application and install its dependencies.

- [Hono documentation](https://hono.bun.dev/)

- Starting a new Hono project
- Installing dependencies for a Hono project

**Reasoning:** This rule is important as it demonstrates how to create a new Hono application and install its dependencies using different package managers. Understanding this is fundamental to getting started with the Hono framework.

*Source: docs/getting-started/vercel.md*

### Setting Up a Basic Route and Installing Dependencies in Hono

This rule demonstrates how to set up a basic 'Hello World' route using the Hono framework in a Vercel environment. It also shows how to install dependencies in different environments (npm, yarn, pnpm, bun).

```ts
import { Hono } from 'hono'
import { handle } from 'hono/vercel'

export const runtime = 'edge'

const app = new Hono().basePath('/api')

app.get('/hello', (c) => {
  return c.json({
    message: 'Hello World'
  })
})
```

1. Import the necessary modules from Hono and Vercel.
2. Set the runtime to 'edge'.
3. Create a new Hono instance and set the base path to '/api'.
4. Define a GET route '/hello' that returns a JSON object with a 'Hello World' message.

- Ensure that the necessary dependencies are installed in your environment. You can do this by moving into your app directory and running the install command for your environment (npm i, yarn, pnpm i, bun i).

- [Supported HTTP Methods](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#supported-http-methods)

- Setting up basic routes in a Hono application.
- Installing dependencies in different environments.

**Reasoning:** This rule is important as it demonstrates how to set up a basic 'Hello World' route using the Hono framework in a Vercel environment. It also shows how to install dependencies in different environments (npm, yarn, pnpm, bun). Understanding this rule is crucial for developers to get started with creating and handling routes in Hono.

*Source: docs/getting-started/vercel.md*

### Setting up a Basic Hono Application with Vercel and Next.js

This code snippet demonstrates how to set up a basic Hono application with Vercel and Next.js.

```javascript
const app = new Hono().basePath('/api')

app.get('/hello', (c) => {
  return c.json({
    message: 'Hello Next.js!',
  })
})

export const GET = handle(app)
export const POST = handle(app)
typescript
import { Hono } from 'hono'
import { handle } from 'hono/vercel'
import type { PageConfig } from 'next'

export const config: PageConfig = {
  runtime: 'edge',
}

const app = new Hono().basePath('/api')
```

1. A new Hono application is created with the base path set to '/api'.
2. A GET route '/hello' is defined that returns a JSON response.
3. The handlers for GET and POST requests are exported.
4. In the `pages/api/[[...route]].ts` file, the runtime for the application is configured to 'edge'.

- The `basePath` method is used to set the base path for the application.
- The `get` method is used to define a GET route.
- The `handle` function from 'hono/vercel' is used to create the handlers for GET and POST requests.

- [Hono Documentation](https://hono.bayfront.cloud/)
- [Vercel Documentation](https://vercel.com/docs)
- [Next.js Documentation](https://nextjs.org/docs)

- Creating a basic Hono application with Vercel and Next.js.
- Defining routes and handlers for GET and POST requests.

#### Code Snippet

```typescript

In the `pages/api/[[...route]].ts` file, you can configure the runtime for the application.

```

**Reasoning:** This rule is important as it demonstrates how to set up a basic Hono application with Vercel and Next.js. It shows how to define the base path, create a simple GET route, and export the handlers for GET and POST requests. It also shows how to configure the runtime for the application in the `pages/api/[[...route]].ts` file.

*Source: docs/getting-started/vercel.md*

### Defining a GET Endpoint and Running the Server Locally in Hono

This code snippet demonstrates how to define a simple GET endpoint in Hono and how to run the development server locally.

```javascript
const app = new Hono().basePath('/api')

app.get('/hello', (c) => {
  return c.json({
    message: 'Hello Next.js!',
  })
})

export default handle(app)
sh
npm run dev
sh
yarn dev
sh
pnpm dev
sh
bun run dev
```

After running the server, you can access `http://localhost:3000` in your web browser. The `/api/hello` endpoint will return a JSON response with the message 'Hello Next.js!'.

- The `basePath` method is used to set the base path for all routes.
- The `get` method is used to define a GET endpoint.
- The `json` method is used to return a JSON response.

- [Hono Documentation](https://hono.bun.dev/)

- Defining endpoints for a REST API
- Returning JSON responses from endpoints

#### Code Snippet

```typescript

To run the development server locally, use one of the following commands:

```

**Reasoning:** This rule is important as it demonstrates how to define a simple GET endpoint using the Hono web framework and how to run the development server locally. It also shows how to return a JSON response from the endpoint, which is a common requirement in web development.

*Source: docs/getting-started/vercel.md*

### Running and Deploying a Hono Application

This code snippet demonstrates how to run a Hono application locally, deploy it using Vercel, and set the runtime to Node.js.

```text
:::

Now, `/api/hello` just returns JSON, but if you build React UIs, you can create a full-stack application with Hono.

If you have a Vercel account, you can deploy by linking the Git repository.

You can also run Hono on Next.js running on the Node.js runtime.

For the App Router, you can simply set the runtime to `nodejs` in your route handler:
```

1. Run the Hono application locally using the command `npm run dev`, `yarn dev`, `pnpm dev`, or `bun run dev`.
2. Access the application in your web browser at `http://localhost:3000`.
3. To deploy the application, link the Git repository to your Vercel account.
4. To run Hono on Next.js with the Node.js runtime, set the runtime to `nodejs` in your route handler.

- Ensure that you have installed the required dependencies before running the application locally.
- You need a Vercel account to deploy the application.

- [Hono documentation](https://hono.dev/docs/getting-started)

- Developing and deploying full-stack applications using Hono and Vercel.
- Running Hono on Next.js with the Node.js runtime.

**Reasoning:** This rule is important as it demonstrates how to set up and run a Hono application locally, deploy it using Vercel, and how to set the runtime to Node.js. Understanding this process is crucial for developers to effectively use the Hono framework and deploy their applications.

*Source: docs/getting-started/vercel.md*

### Defining a Basic Hono Application and Installing Node.js Adapter for Pages Router

This code snippet demonstrates how to define a basic Hono application with a single route and how to handle GET and POST requests. It also shows the necessity of installing the Node.js adapter for the Pages Router in Hono.

```javascript
const app = new Hono().basePath('/api')

app.get('/hello', (c) => {
  return c.json({
    message: 'Hello from Hono!',
  })
})

export const GET = handle(app)
export const POST = handle(app)
```

1. A new Hono application is created with a base path of '/api'.
2. A GET route '/hello' is defined which returns a JSON response with a message.
3. The GET and POST handlers for the application are exported.

- The Node.js adapter needs to be installed for the Pages Router in Hono. This can be done using npm, yarn, pnpm, or bun.

- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)

- Defining basic routes in a Hono application.
- Handling different types of HTTP requests in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to define a basic Hono application with a single route and how to handle GET and POST requests. It also shows the necessity of installing the Node.js adapter for the Pages Router in Hono.

*Source: docs/getting-started/vercel.md*

### Installing Hono Node Server and Utilizing the Handle Function

This code snippet demonstrates how to install the Hono node server using different package managers and how to import and utilize the 'handle' function from '@hono/node-server/vercel'.

```sh
npm i @hono/node-server
sh
yarn add @hono/node-server
sh
pnpm add @hono/node-server
sh
bun add @hono/node-server
ts
import { Hono } from 'hono'
import { handle } from '@hono/node-server/vercel'
import type { PageConfig } from 'next'

export const config: PageConfig = {
  api: {
    bodyParser: false,
  },
}
```

The 'handle' function is a utility function provided by the Hono node server for handling requests and responses in a serverless function environment.

Ensure that the Hono node server is installed before attempting to import and use the 'handle' function.

- Hono Documentation: https://hono.io/docs/getting-started

- Setting up a Hono server
- Handling requests and responses in a serverless function environment

**Reasoning:** This rule is important as it demonstrates how to install the Hono node server using different package managers and how to import and utilize the 'handle' function from '@hono/node-server/vercel'. This is a fundamental step in setting up a Hono server and utilizing its functionalities.

*Source: docs/getting-started/vercel.md*

### Disabling Vercel Node.js Helpers for Hono

In this code snippet, we are disabling Vercel Node.js helpers to ensure Hono works correctly with the Pages Router. This is done by setting up an environment variable in your project dashboard or in your `.env` file.

```text
NODEJS_HELPERS=0
```

By setting the `NODEJS_HELPERS` environment variable to `0`, we are disabling Vercel Node.js helpers. This is necessary because Hono might not function correctly with these helpers enabled.

Ensure to set this environment variable in your project dashboard or in your `.env` file.

- Hono documentation
- Vercel documentation

This is commonly used when you are using Hono with the Pages Router and you are deploying your application on Vercel.

**Reasoning:** This rule is important as it demonstrates how to disable Vercel Node.js helpers for Hono to work with the Pages Router. This is crucial because Hono might not function correctly with the Vercel Node.js helpers enabled.

*Source: docs/getting-started/vercel.md*

### Creating a Basic 'Hello World' Application with Hono on Lambda@Edge

This code demonstrates how to create a basic 'Hello World' application using the Hono framework on Lambda@Edge.

```sh
mkdir my-app
cd my-app
cdk init app -l typescript
pnpm add hono
mkdir lambda
ts
import { Hono } from 'hono'
import { handle } from 'hono/lambda-edge'

const app = new Hono()

app.get('/', (c) => c.text('Hello Hono on Lambda@Edge!'))

export const handler = handle(app)
```

1. A new Hono application is created.
2. A GET route is defined on the root path ('/'). When this route is accessed, it responds with the text 'Hello Hono on Lambda@Edge!'.
3. The application is exported as a handler that can be used by AWS Lambda.

- Ensure that Hono is added to the project using `pnpm add hono` or `bun add hono`.
- The lambda directory must be created in the project root.

- [Hono Documentation](https://hono.bun.dev/)

- Creating a basic web application with Hono.
- Setting up a serverless application with AWS Lambda.

#### Code Snippet

```typescript

After setting up the application and adding Hono, a lambda directory is created. Then, a simple GET route is defined in `lambda/index_edge.ts`.

```

**Reasoning:** This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono framework on Lambda@Edge. It shows the process of setting up the application, adding Hono, creating a lambda directory, and defining a simple GET route. This is a fundamental pattern in Hono framework usage.

*Source: docs/getting-started/lambda-edge.md*

### Creating and Deploying a Basic Hono Application with AWS Lambda@Edge

This code demonstrates how to set up a basic Hono application and deploy it using AWS Lambda@Edge.

```ts
import { Hono } from 'hono'
import { handle } from 'hono/lambda-edge'

const app = new Hono()

app.get('/', (c) => c.text('Hello Hono on Lambda@Edge!'))

export const handler = handle(app)
ts

import 'source-map-support/register'
import * as cdk from 'aws-cdk-lib'
import { MyAppStack } from '../lib/my-app-stack'

const app = new cdk.App()
new MyAppStack(app, 'MyAppStack')
```

1. A new instance of Hono is created.
2. A GET route is defined on the root path ('/') of the application. When this route is hit, it returns the text 'Hello Hono on Lambda@Edge!'.
3. The handler for the Hono application is exported using the `handle` function from 'hono/lambda-edge'. This handler can be used by AWS Lambda@Edge to handle incoming requests.
4. To deploy the application, a new AWS CDK App is created and a new instance of `MyAppStack` is added to the app.

- The `handle` function from 'hono/lambda-edge' is used to create a handler for AWS Lambda@Edge.

- [Hono Documentation](https://hono.boutique/docs/)

- Creating serverless applications with Hono and AWS Lambda@Edge.

#### Code Snippet

```typescript

To deploy the application, edit `bin/my-app.ts`.

```

**Reasoning:** This rule is important as it demonstrates how to set up a basic Hono application and deploy it using AWS Lambda@Edge. It shows the process of creating a Hono instance, defining a simple GET route, and exporting the handler for AWS Lambda@Edge to use. This is a fundamental pattern in serverless applications using the Hono framework.

*Source: docs/getting-started/lambda-edge.md*

### Initializing a New Application Stack in Hono

This code snippet demonstrates how to initialize a new application stack in Hono using the AWS CDK.

```ts
import { MyAppStack } from '../lib/my-app-stack'

const app = new cdk.App()
new MyAppStack(app, 'MyAppStack', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: 'us-east-1',
  },
})
```

1. Import the `MyAppStack` class from the `lib` directory.
2. Create a new instance of the `cdk.App` class.
3. Create a new instance of the `MyAppStack` class, passing in the `app` instance, a name for the stack, and an object containing the environment variables for the AWS account and region.

- The `CDK_DEFAULT_ACCOUNT` environment variable should be set to your AWS account ID.
- The region is set to 'us-east-1', but this can be changed to any valid AWS region.

- [AWS CDK Documentation](https://docs.aws.amazon.com/cdk/latest/guide/home.html)

- Initializing a new application stack in Hono.

**Reasoning:** This rule is important as it demonstrates how to initialize a new application stack in Hono using the AWS CDK (Cloud Development Kit). It shows how to set the environment variables for the AWS account and region. This is a fundamental step in setting up an application in Hono, as it sets up the basic infrastructure for the application.

*Source: docs/getting-started/lambda-edge.md*

### Deploying Edge Lambda Function and Using Callback in Hono Framework

This code snippet demonstrates how to deploy an edge lambda function using the Hono framework and the Cloud Development Kit (CDK). It also shows how to use the callback function for Basic Auth and request processing after verification.

```text
edgeLambdas: [
  {
    functionVersion: edgeFn.currentVersion,
    eventType: cloudfront.LambdaEdgeEventType.VIEWER_REQUEST,
  },
],
},
})
}
}
sh
cdk deploy
ts
import { Hono } from 'hono'
import { basicA
```

The `edgeLambdas` array contains the configuration for the edge lambda function. The `functionVersion` is the current version of the function, and the `eventType` is the type of event that triggers the function. The `cdk deploy` command deploys the function.

The `c.env.callback()` function is used for Basic Auth and to continue with request processing after verification.

Ensure that the `functionVersion` and `eventType` are correctly set in the `edgeLambdas` array. Also, make sure to import the necessary modules before using the `c.env.callback()` function.

- [Hono Documentation](https://hono.bike/docs)

This pattern is commonly used when deploying edge lambda functions and implementing Basic Auth in applications using the Hono framework.

#### Code Snippet

```typescript

To deploy the function, run the following command:

```

**Reasoning:** This rule is important as it demonstrates how to deploy an edge lambda function using the Hono framework and the Cloud Development Kit (CDK). It also shows how to use the callback function for Basic Auth and request processing after verification.

*Source: docs/getting-started/lambda-edge.md*

### Using Callback in Hono for Basic Auth and Request Processing

In Hono, you can use the `c.env.callback()` function to add Basic Auth and continue with request processing after verification. This is a common pattern in Hono where the callback function is used to continue the execution of the application after a certain operation has been completed.

Here is a code snippet demonstrating this:

```ts
import { Hono } from 'hono'
import { basicAuth } from 'hono/basic-auth'
import type { Callback, CloudFrontRequest } from 'hono/lambda-edge'
import { handle } from 'hono/lambda-edge'

type Bindings 
```

The `c.env.callback()` function is called after the Basic Auth operation has been completed. This function then continues the execution of the application.

- The `c.env.callback()` function is a part of the Hono framework and is used to continue the execution of the application after a certain operation has been completed.

- Hono Documentation

- Adding Basic Auth to an application and continuing with request processing after verification.

**Reasoning:** This rule is important as it demonstrates how to use the callback function in Hono to add Basic Auth and continue with request processing after verification. This is a common pattern in Hono where the callback function is used to continue the execution of the application after a certain operation has been completed.

*Source: docs/getting-started/lambda-edge.md*

### Creating a Basic Hono Application for AWS Lambda

This code snippet demonstrates how to create a basic 'Hello World' application using the Hono framework in an AWS Lambda environment.

```ts
import { Hono } from 'hono'
import { handle } from 'hono/aws-lambda'

const app = new Hono()

app.get('/', (c) => c.text('Hello Hono!'))

export const handler = handle(app)
```

1. The Hono and handle modules from 'hono/aws-lambda' are imported.
2. A new Hono application is created.
3. A route handler for the root path ('/') is defined. This handler simply returns the text 'Hello Hono!'.
4. The handler is exported for AWS Lambda to use.

- The 'handle' function from 'hono/aws-lambda' is used to create a handler that AWS Lambda can use to handle incoming requests.

- [Hono Documentation](https://hono.bun.dev/)

- Creating a basic serverless application using Hono and AWS Lambda.

**Reasoning:** This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono framework in an AWS Lambda environment. It shows how to initialize a new Hono application, define a route handler for the root path ('/') and export the handler for AWS Lambda to use.

*Source: docs/getting-started/aws-lambda.md*

### Setting Up and Deploying a Hono Application with AWS Lambda

This code snippet demonstrates how to set up a basic Hono application and deploy it using AWS Lambda.

```ts
import { Hono } from 'hono'
import { handle } from 'hono/aws-lambda'

const app = new Hono()

app.get('/', (c) => c.text('Hello Hono!'))

export const handler = handle(app)
```

1. Import the `Hono` class from the `hono` package and the `handle` function from `hono/aws-lambda`.
2. Create a new instance of `Hono`.
3. Define a GET route for the root URL (`/`) that responds with 'Hello Hono!'.
4. Export a handler for AWS Lambda using the `handle` function, passing the Hono application instance as an argument.

- The `handle` function is specifically designed for AWS Lambda and helps to adapt the Hono application to the AWS Lambda environment.

- [Hono Documentation](https://hono.bayfront.cloud/)
- [AWS Lambda Documentation](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)

- Creating serverless applications with Hono and AWS Lambda.
- Deploying Hono applications to AWS Lambda.

**Reasoning:** This rule is important as it demonstrates how to set up a basic Hono application and deploy it using AWS Lambda. It shows how to create a Hono application, define a simple GET route, and export a handler for AWS Lambda. This is a fundamental pattern in serverless applications development using Hono and AWS Lambda.

*Source: docs/getting-started/aws-lambda.md*

### Deploying AWS Lambda Function with Hono

This code snippet demonstrates how to deploy an AWS Lambda function using the Hono framework. It also shows how to add a function URL and create a REST API for the function.

```text
untime: lambda.Runtime.NODEJS_20_X,
})
fn.addFunctionUrl({
  authType: lambda.FunctionUrlAuthType.NONE,
})
new apigw.LambdaRestApi(this, 'myapi', {
  handler: fn,
})
}
sh
cdk deploy
```

1. The `lambda.Runtime.NODEJS_20_X` specifies the runtime environment for the Lambda function.
2. The `addFunctionUrl` method is used to add a URL for the function. The `authType` is set to `NONE`, meaning no authentication is required to access the function.
3. The `LambdaRestApi` class is used to create a REST API for the function.
4. The `cdk deploy` command is used to deploy the function.

- Make sure to replace `'myapi'` with the actual name of your API.
- The `cdk deploy` command should be run in the root directory of your project.

- [AWS CDK Documentation](https://docs.aws.amazon.com/cdk/latest/guide/home.html)

- Deploying serverless applications using AWS Lambda and Hono.

#### Code Snippet

```typescript

To deploy the function, run the command:

```

**Reasoning:** This rule is important as it demonstrates how to deploy an AWS Lambda function using the Hono framework. It also shows how to add a function URL and create a REST API for the function. Understanding this rule is crucial for developers who want to deploy serverless applications using Hono and AWS Lambda.

*Source: docs/getting-started/aws-lambda.md*

### Serving Binary Data in Hono using AWS Lambda

Hono supports binary data as a response. In AWS Lambda, base64 encoding is required to return binary data. Once binary type is set to `Content-Type` header, Hono automatically encodes data to base64.

```ts
app.get('/binary', async (c) => {
  // ...
  c.status(200)
  c.header('Content-Type', 'image/png') // means binary data
  return c.body(buffer) // supports `ArrayBufferLike` type, encoded to base64
```

1. Define a route using `app.get()`.
2. Set the status code to 200 using `c.status(200)`.
3. Set the `Content-Type` header to the type of binary data you are serving using `c.header('Content-Type', 'image/png')`.
4. Return the binary data as the response body using `return c.body(buffer)`. Hono will automatically encode the `ArrayBufferLike` type data to base64.

- Hono automatically handles the base64 encoding once the `Content-Type` header is set to a binary type.

- [Hono Documentation](https://hono.bevry.me/)

- Serving images or other binary data from a Hono application using AWS Lambda.

**Reasoning:** This rule is important as it demonstrates how to serve binary data in Hono using AWS Lambda. It shows that base64 encoding is required to return binary data in Lambda and once the binary type is set to `Content-Type` header, Hono automatically encodes the data to base64.

*Source: docs/getting-started/aws-lambda.md*

### Handling Binary Data in Hono

In Hono, you can handle binary data by setting the status and content type of the response, and returning the binary data in the response body.

```ts
p.get('/binary', async (c) => {
  // ...
  c.status(200)
  c.header('Content-Type', 'image/png') // means binary data
  return c.body(buffer) // supports `ArrayBufferLike` type, encoded to base64.
})
```

1. `c.status(200)`: This sets the HTTP status code of the response to 200.
2. `c.header('Content-Type', 'image/png')`: This sets the content type of the response to 'image/png', indicating that the response contains binary data.
3. `return c.body(buffer)`: This returns the binary data in the response body. The `body` method supports `ArrayBufferLike` type, which is encoded to base64.

- The `body` method supports `ArrayBufferLike` type, which is encoded to base64. This means that you can return binary data in the response body.

- [Hono documentation](https://hono.bayrell.org/en/)

- Returning images or other binary data in the response body.

**Reasoning:** This rule is important as it demonstrates how to handle binary data in Hono. It shows how to set the status and content type of the response, and how to return binary data in the response body.

*Source: docs/getting-started/aws-lambda.md*

### Accessing AWS Lambda RequestContext in Hono

In Hono, you can access the AWS Lambda request context by binding the `LambdaEvent` type and using `c.env.event.requestContext`.

```ts
import { Hono } from 'hono'
import type { LambdaEvent } from 'hono/aws-lambda'
import { handle } from 'hono/aws-lambda'

type Bindings = {
  event: LambdaEvent
}

const app = new Hono<{ Bindings: Bindings }>()

app.get('/aws-lambda-info/', (c) => {
  return c.json({
    isBase64Encoded: c.env.event.isBase64Encoded,
    awsRequestId: c.env.lambdaContext.awsRequestId,
  })
})

export const handler = handle(app)
```

1. Import the necessary modules from Hono and AWS Lambda.
2. Define the bindings for the AWS Lambda event.
3. Create a new Hono application with the defined bindings.
4. Define a GET route that returns a JSON response with specific information from the AWS Lambda request context.
5. Export the handler function that handles the Hono application.

- The `LambdaEvent` type provides access to the AWS Lambda request context.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Retrieving specific information from the AWS Lambda request context for processing in your application.

**Reasoning:** This rule is important as it demonstrates how to access the AWS Lambda request context in Hono. Understanding this is crucial for developers who need to interact with AWS Lambda functions and retrieve specific information from the request context.

*Source: docs/getting-started/aws-lambda.md*

### Accessing AWS Lambda Request Context in Hono (Before v3.10.0)

This code snippet demonstrates how to access the AWS Lambda request context in Hono before version 3.10.0. This is done by binding the `ApiGatewayRequestContext` type and using `c.env.`.

```text
import { Hono } from 'hono'
import type { ApiGatewayRequestContext } from 'hono/aws-lambda'
import { handle } from 'hono/aws-lambda'

type Bindings = {
  requestContext: ApiGatewayRequestContext
}

app.get('/custom-context/', (c) => {
  const lambdaContext = c.env.event.requestContext
  return c.json(lambdaContext)
})

export const handler = handle(app)
```

1. The `ApiGatewayRequestContext` type is imported from `hono/aws-lambda`.
2. A new Hono app is created with the `Bindings` type, which includes `requestContext` of type `ApiGatewayRequestContext`.
3. In the route handler for '/custom-context/', the AWS Lambda request context is accessed through `c.env.event.requestContext`.
4. The request context is then returned as a JSON response.

- This method is deprecated in Hono version 3.10.0 and later.

- Hono documentation: [https://hono.bayfront.io/](https://hono.bayfront.io/)

- Accessing the AWS Lambda request context to get information about the request, such as the HTTP method, path, headers, and more.

**Reasoning:** This rule is important as it demonstrates how to access the AWS Lambda request context in Hono before version 3.10.0. This is crucial when developing AWS Lambda functions using Hono, as it allows developers to access and manipulate the request context, which contains useful information about the request.

*Source: docs/getting-started/aws-lambda.md*

### Achieving Streaming Response with AWS Lambda in Hono

In Hono, you can change the invocation mode of AWS Lambda to achieve a streaming response. This is done by setting the `invokeMode` property to `lambda.InvokeMode.RESPONSE_STREAM` when adding a function URL.

```diff
fn.addFunctionUrl({
  authType: lambda.FunctionUrlAuthType.NONE,
+  invokeMode: lambda.InvokeMode.RESPONSE_STREAM,
})
```

This change allows AWS Lambda to send large amounts of data in chunks rather than all at once, which can improve performance and reduce memory usage.

When you set the `invokeMode` to `RESPONSE_STREAM`, AWS Lambda will write data to a NodeJS.Writable stream. This allows the data to be sent in chunks rather than all at once.

- The `invokeMode` property is only available in the `addFunctionUrl` method.
- The `RESPONSE_STREAM` mode is best used when you need to send large amounts of data.

- [AWS Lambda Response Streaming](https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/)

- Sending large amounts of data from a Lambda function.
- Reducing memory usage when sending data from a Lambda function.

**Reasoning:** This rule is important because it demonstrates how to change the invocation mode of AWS Lambda to achieve a streaming response. This is useful when you want to send large amounts of data in chunks rather than all at once, which can improve performance and reduce memory usage.

*Source: docs/getting-started/aws-lambda.md*

### Implementing Traditional Streaming Response in Hono with AWS Lambda Adaptor

In Hono, you can achieve the traditional streaming response using AWS Lambda Adaptor's `streamHandle` instead of `handle`. This is particularly useful when you want to leverage the power of AWS Lambda functions in your Hono applications without losing the traditional streaming response functionality.

Here's how you can do it:

```ts
import { Hono } from 'hono'
import { streamHandle } from 'hono/aws-lambda'

const app = new Hono()

app.get('/stream', async (c) => {
  return streamText(c, async (stream) => {
    for (let i = 0; 
diff
fn.addFunctionUrl({
  authType: lambda.FunctionUrlAuthType.NONE,
+  invokeMode: lambda.InvokeMode.RESPONSE_STREAM,
})
```

- [AWS Lambda Response Streaming](https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/)

- Streaming large amounts of data from AWS Lambda functions
- Implementing real-time updates or notifications

#### Code Snippet

```typescript

### How it works

Typically, the implementation requires writing chunks to NodeJS.WritableStream using `awslambda.streamifyResponse`. But with the AWS Lambda Adaptor, you can achieve the traditional streaming response of Hono by using `streamHandle` instead of `handle`.

### Important notes

Make sure to set the `invokeMode` to `RESPONSE_STREAM` when adding the function URL.

```

**Reasoning:** This rule is important as it demonstrates how to achieve traditional streaming response in Hono using AWS Lambda Adaptor's streamHandle instead of handle. This is crucial for developers who want to leverage the power of AWS Lambda functions in their Hono applications without losing the traditional streaming response functionality.

*Source: docs/getting-started/aws-lambda.md*

### Creating a Basic Hono Application

This code snippet demonstrates how to create a basic 'Hello World' application using the Hono framework and the hono-alibaba-cloud-fc3-adapter.

```ts
import { Hono } from 'hono'
import { handle } from 'hono-alibaba-cloud-fc3-adapter'

const app = new Hono()

app.get('/', (c) => c.text('Hello Hono!'))

export const handler = handle(app)
```

1. The `Hono` and `handle` modules are imported from 'hono' and 'hono-alibaba-cloud-fc3-adapter' respectively.
2. A new instance of `Hono` is created and assigned to the `app` variable.
3. A GET route is defined on the root path ('/') of the application. When this route is hit, it responds with the text 'Hello Hono!'.
4. The `handle` function is used to create a handler for the `app` and this handler is exported.

- The `handle` function from 'hono-alibaba-cloud-fc3-adapter' is used to create a handler for the Hono application. This is necessary for the application to work with Alibaba Cloud Function Compute.

- [Hono Documentation](https://hono.bun.dev/)

- This pattern is commonly used when creating a basic Hono application for Alibaba Cloud Function Compute.

**Reasoning:** This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono framework and the hono-alibaba-cloud-fc3-adapter. It shows how to set up the project, import necessary modules, create a new Hono instance, define a route, and export the handler function.

*Source: docs/getting-started/ali-function-compute.md*

### Setting Up a Basic Hono Application and Integrating with Alibaba Cloud Function Compute

This code snippet demonstrates how to set up a basic Hono application and integrate it with Alibaba Cloud Function Compute using the Hono Alibaba Cloud FC3 adapter. It also shows how to use the serverless-devs tool to manage serverless applications.

```ts
import { Hono } from 'hono'
import { handle } from 'hono-alibaba-cloud-fc3-adapter'

const app = new Hono()

app.get('/', (c) => c.text('Hello Hono!'))

export const handler = handle(app)
```

1. Import the necessary modules from Hono and the Hono Alibaba Cloud FC3 adapter.
2. Create a new Hono application.
3. Define a GET route that responds with 'Hello Hono!'.
4. Export a handler function that wraps the Hono application with the Alibaba Cloud FC3 adapter.

- The handler function is what Alibaba Cloud Function Compute will use to handle incoming requests.

- [Hono](https://github.com/hono-xx/hono)
- [Hono Alibaba Cloud FC3 Adapter](https://github.com/hono-xx/hono-alibaba-cloud-fc3-adapter)
- [Serverless Devs](https://github.com/Serverless-Devs/Serverless-Devs)

- Creating serverless applications that run on Alibaba Cloud Function Compute.

**Reasoning:** This rule is important as it demonstrates how to set up a basic Hono application and integrate it with Alibaba Cloud Function Compute using the Hono Alibaba Cloud FC3 adapter. It also shows how to use the serverless-devs tool to manage serverless applications.

*Source: docs/getting-started/ali-function-compute.md*

### Configuring Alibaba Cloud AccessKeyID & AccessKeySecret and Basic Serverless Application Setup in Hono

This code snippet demonstrates how to add the Alibaba Cloud AccessKeyID & AccessKeySecret and how to set up a basic serverless application configuration in Hono using the 's.yaml' file.

```sh
npx s config add

yaml
edition: 3.0.0
name: my-app
access: 'default'

vars:
  region: 'us-west-1'

resources:
  my-app:
    component: fc3
    props:
      region: ${vars.region}
      functionName: 'my-app'
      desc
```

1. The 'npx s config add' command is used to add the Alibaba Cloud AccessKeyID & AccessKeySecret.
2. The 's.yaml' file is a serverless application model file in Hono. It defines the serverless application.

- The 'access' field in the 's.yaml' file should match the name you used when you configured your Alibaba Cloud credentials.
- The 'region' is a variable that is defined under the 'vars' field and is used in the 'props' field.

- [Hono Documentation](https://www.hono.io/)

- Setting up a serverless application on Alibaba Cloud using Hono.

#### Code Snippet

```typescript

After adding the AccessKeyID & AccessKeySecret, you need to edit the 's.yaml' file as follows:

```

**Reasoning:** This rule is important as it demonstrates how to configure Alibaba Cloud AccessKeyID & AccessKeySecret and how to set up a basic serverless application configuration in Hono using the 's.yaml' file. This is a crucial step in deploying serverless applications on Alibaba Cloud using Hono.

*Source: docs/getting-started/ali-function-compute.md*

### Configuring Build and Deploy Scripts in package.json for Hono Applications

This code snippet demonstrates how to configure the build and deploy scripts in the package.json file for a Hono application.

```json
{
  "scripts": {
    "build": "esbuild --bundle --outfile=./dist/index.js --platform=node --target=node20 ./src/index.ts",
    "deploy": "s deploy -y"
  }
}
```

1. The `build` script uses esbuild to bundle the TypeScript source code into a single JavaScript file, which is output to the ./dist directory.
2. The `deploy` script uses the Serverless Framework's deploy command to deploy the application.

- The `--platform=node` and `--target=node20` options in the `build` script specify that the code should be bundled for the Node.js 20 runtime.
- The `-y` option in the `deploy` script automatically confirms any prompts that may appear during the deployment process.

- [esbuild documentation](https://esbuild.github.io/getting-started/)
- [Serverless Framework documentation](https://www.serverless.com/framework/docs/)

- Automating the build and deployment process of a Hono application

**Reasoning:** This rule is important as it demonstrates how to configure the build and deploy scripts in the package.json file for a Hono application. This is a crucial step in automating the build and deployment process of the application.

*Source: docs/getting-started/ali-function-compute.md*

### Deploying a Function to Alibaba Cloud Function Compute with npm Scripts

This code snippet demonstrates how to deploy a function to Alibaba Cloud Function Compute using npm scripts.

```json
{
  "scripts": {
    "build": "esbuild --bundle --outfile=./dist/index.js --platform=node --target=node20 ./src/index.ts",
    "deploy": "s deploy -y"
  }
}
sh
npm run build # Compile the TypeScript code to JavaScript
npm run deploy # Deploy the function to Alibaba Cloud Function Compute
```

1. The `build` script uses esbuild to compile the TypeScript code to JavaScript, targeting Node.js 20 and outputting the result to `./dist/index.js`.
2. The `deploy` script uses the Serverless Framework's `s` command to deploy the function, with the `-y` flag automatically confirming any prompts.

- Ensure that you have the necessary permissions to deploy to Alibaba Cloud Function Compute.
- Make sure that your function's dependencies are correctly installed and that your TypeScript code compiles without errors before attempting to deploy.

- [Alibaba Cloud Function Compute Documentation](https://www.alibabacloud.com/help/product/50980.htm)
- [Serverless Framework Documentation](https://www.serverless.com/framework/docs/)

- Deploying serverless functions to Alibaba Cloud Function Compute
- Automating deployment processes with npm scripts

#### Code Snippet

```typescript

To deploy, run the following commands:

```

**Reasoning:** This rule is important as it demonstrates how to deploy a function to Alibaba Cloud Function Compute using npm scripts. It shows the correct sequence of commands to compile TypeScript code to JavaScript and then deploy the function.

*Source: docs/getting-started/ali-function-compute.md*

### Creating a new Hono application and installing dependencies

This code snippet demonstrates how to create a new Hono application and install its dependencies using different package managers.

```sh
yarn create hono my-app
sh
pnpm create hono my-app
sh
bun create hono@latest my-app
sh
deno init --npm hono my-app
sh
cd my-app
npm i
sh
cd my-app
yarn
sh
cd my-app
pnpm i
sh
cd my-app
bun i
```

The `create` command is used to create a new Hono application. The `cd` command is used to move to the application directory. The `i` or `install` command is used to install the dependencies of the application.

- Make sure to use the correct command for your package manager.
- The `@latest` tag can be used to create an application with the latest version of Hono.

- [Hono documentation](https://hono.bun.dev/)

- Setting up a new Hono project

**Reasoning:** This rule is important as it demonstrates how to create a new Hono application and install its dependencies using different package managers. Understanding this rule is crucial for setting up a new Hono project correctly.

*Source: docs/getting-started/cloudflare-workers.md*

### Creating a Basic Hono Application

This code snippet demonstrates how to create a basic 'Hello World' application using the Hono framework.

```ts
import { Hono } from 'hono'
const app = new Hono()

app.get('/', (c) => c.text('Hello Cloudflare Workers!'))

export default app
```

1. The Hono framework is imported.
2. A new Hono application is created.
3. A GET route is defined for the root URL ('/'). The response is a simple text message.
4. The application is exported for use elsewhere.

- This is a very basic example of a Hono application. Real-world applications will typically have more complex routing and response logic.

- [Hono Documentation](https://hono.bun.dev/)

- Creating a simple serverless application with Hono and Cloudflare Workers.

**Reasoning:** This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono framework. It shows the basic structure of a Hono application, including how to define routes and responses.

*Source: docs/getting-started/cloudflare-workers.md*

### Running a Hono Application Locally

This code snippet demonstrates how to run a Hono application on your local machine using different package managers.

```sh
npm run dev
sh
yarn dev
sh
pnpm dev
sh
bun run dev
```

After running one of these commands, you can access the application by opening `http://localhost:8787` in your web browser.

These commands start the development server for your Hono application. The server listens on port 8787 and serves the application.

- Ensure that the specified port is not being used by another service.

- [Hono Documentation](https://hono.bun.dev/)

- Running the application for testing during development.

**Reasoning:** This rule is important as it demonstrates how to run a Hono application locally using different package managers. It shows the command to start the development server and how to access the application in a web browser. Understanding this rule is crucial for testing and debugging during development.

*Source: docs/getting-started/cloudflare-workers.md*

### Changing Port Number and Deploying Application in Cloudflare Workers

This rule demonstrates how to change the port number and deploy the application using different package managers in the context of Cloudflare Workers.

```text
:::

If you need to change the port number you can follow the instructions here to update `wrangler.toml` / `wrangler.json` / `wrangler.jsonc` files:
[Wrangler Configuration](https://developers.cloudflare.com/workers/wrangler/configuration/#local-development-settings)

Or, you can follow the instructions here to set CLI options:
[Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/commands/#dev)

If you have a Cloudflare account, you can deploy to Cloudflare. In `package.json`, `$npm_execpath` needs to be changed to your package manager of choice.

::: code-group
```

1. To change the port number, you can update the `wrangler.toml`, `wrangler.json`, or `wrangler.jsonc` files as per the instructions provided in the Wrangler Configuration link.
2. Alternatively, you can set CLI options as per the instructions provided in the Wrangler CLI link.
3. To deploy the application, you need to have a Cloudflare account. In the `package.json` file, you need to change `$npm_execpath` to your package manager of choice.

- Ensure to use a unique port number to avoid port conflicts.
- Choose the package manager you are most comfortable with for deploying the application.

- [Wrangler Configuration](https://developers.cloudflare.com/workers/wrangler/configuration/#local-development-settings)
- [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/commands/#dev)

- Changing the port number when the default port is already in use.
- Deploying the application using different package managers based on personal preference or project requirements.

**Reasoning:** This rule is important as it demonstrates how to change the port number and deploy the application using different package managers in the context of Cloudflare Workers. Understanding how to change the port number is crucial for avoiding port conflicts and ensuring the application runs smoothly. Moreover, knowing how to deploy the application using different package managers provides flexibility and allows developers to use the package manager they are most comfortable with.

*Source: docs/getting-started/cloudflare-workers.md*

### Using Module Worker mode and Service Worker mode in Hono

In Hono, there are two syntaxes for writing the Cloudflare Workers: _Module Worker mode_ and _Service Worker mode_.

Here is how you can write in both modes:

```ts
// Module Worker
export default app
ts
// Service Worker
app.fire()
```

While both syntaxes are supported, it is recommended to use Module Worker mode. This is because in Module Worker mode, binding variables are localized, which can help in maintaining clean and manageable code.

- While both modes are supported, Module Worker mode is recommended for better management of binding variables.

- Use Module Worker mode when you want to keep your binding variables localized.

- Use Service Worker mode when you want to fire the application immediately.

**Reasoning:** This rule is important as it demonstrates the two syntaxes for writing Cloudflare Workers in Hono: Module Worker mode and Service Worker mode. It also highlights the recommendation to use Module Worker mode for localized binding variables, which can be crucial for maintaining clean and manageable code.

*Source: docs/getting-started/cloudflare-workers.md*

### Integrating Hono with Other Event Handlers in Module Worker Mode

In Hono, you can integrate with other event handlers (such as `scheduled`) in Module Worker mode. To do this, you need to export `app.fetch` as the module's `fetch` handler, and then implement other handlers as needed.

Here is a code snippet demonstrating this:

```ts
const app = new Hono()

export default {
  fetch: app.fetch,
  scheduled: async (batch, env) => {},
}
```

In the above code, `app.fetch` is exported as the module's `fetch` handler. This allows Hono to handle fetch events. The `scheduled` handler is also defined, but it doesn't do anything in this example.

- The `scheduled` handler can be replaced with any other event handler as per your application's requirements.

- [Hono Documentation](https://hono.bouzuya.net/)

- Integrating Hono with a scheduling system to perform tasks at specific intervals.
- Extending the functionality of a Hono application with additional event handlers.

**Reasoning:** This rule is important as it demonstrates how to integrate Hono with other event handlers in Module Worker mode. This is crucial for developers who want to extend the functionality of their Hono applications with additional event handlers.

*Source: docs/getting-started/cloudflare-workers.md*

### Serving Static Files in Hono using Cloudflare Workers

The following code snippet demonstrates how to serve static files using the Static Assets feature of Cloudflare Workers in a Hono application. This is done by specifying the directory for the files in `wrangler.toml`:

```toml
assets = { directory = "public" }
```

After this, you need to create the `public` directory and place the files there. For instance, `./public/static/hello.txt` will be served as `/static/hello.txt`.

1. The `assets` field in the `wrangler.toml` file is used to specify the directory that contains the static files.
2. The `directory` field within the `assets` field is set to the directory that contains the static files. In this case, it is set to `public`.
3. Any file placed within the `public` directory can be accessed as a static file. For example, a file at `./public/static/hello.txt` can be accessed at the URL `/static/hello.txt`.

- The directory specified in the `directory` field must exist, otherwise, an error will occur.
- The static files feature is a part of Cloudflare Workers and may not be available in other environments.

- [Cloudflare Workers Static Assets Feature](https://developers.cloudflare.com/workers/static-assets/)

- Serving images, CSS files, JavaScript files, etc., as static files.
- Hosting a static website or a single-page application.

**Reasoning:** This rule is important as it demonstrates how to serve static files using the Static Assets feature of Cloudflare Workers in a Hono application. This is a common requirement in many web applications where static files like images, CSS, JavaScript files, etc., need to be served to the client.

*Source: docs/getting-started/cloudflare-workers.md*

### Serving Static Assets with Cloudflare Workers in Hono

In Hono, you can serve static assets using the Cloudflare Workers feature. To do this, you need to specify the directory for the static files in the `wrangler.toml` file. For instance:

```toml
assets = { directory = "public" }

.
├── package.json
├── public
│   ├── favicon.ico
│   └── static
│       └── hello.txt
├── src
│   └── index.ts
└── wrangler.toml
```

- Ensure that the directory specified in the `wrangler.toml` file exists and contains the static files you want to serve.

- [Cloudflare Workers Static Assets](https://developers.cloudflare.com/workers/static-assets/)

- Serving static files like images, CSS, and JavaScript for a web application.

#### Code Snippet

```typescript

Then, you need to create the `public` directory and place your static files there. For example, if you place a file at `./public/static/hello.txt`, it will be served at the path `/static/hello.txt`.

Your project directory should look something like this:

```

**Reasoning:** This rule is important as it demonstrates how to serve static assets using the Cloudflare Workers feature in Hono. It shows how to specify the directory for static files in the `wrangler.toml` file and how to structure the project directory for serving these files.

*Source: docs/getting-started/cloudflare-workers.md*

### Installing '@cloudflare/workers-types' for TypeScript Development in Cloudflare Workers

The code snippet demonstrates how to install the '@cloudflare/workers-types' package using different package managers. This package provides type definitions for Cloudflare Workers, which are essential for TypeScript development.

```sh
npm i --save-dev @cloudflare/workers-types
sh
yarn add -D @cloudflare/workers-types
sh
pnpm add -D @cloudflare/workers-types
```

These commands add the '@cloudflare/workers-types' package as a development dependency, meaning it will not be included in the production build of your project.

- Make sure to install the '@cloudflare/workers-types' package as a development dependency, as it is only needed during development and not in the production build.

- [Cloudflare Workers TypeScript documentation](https://developers.cloudflare.com/workers/learning/typescript)

- When setting up a new TypeScript project for Cloudflare Workers, you should install the '@cloudflare/workers-types' package to benefit from autocompletion and type checking capabilities.

**Reasoning:** This rule is important as it demonstrates how to install the '@cloudflare/workers-types' package, which provides type definitions for Cloudflare Workers. These type definitions are essential for TypeScript development, as they provide autocompletion and type checking capabilities, improving the developer experience and reducing the likelihood of runtime errors.

*Source: docs/getting-started/cloudflare-workers.md*

### Adding Development Dependencies and Setting Up Testing in Hono

This code snippet demonstrates how to add development dependencies in a Hono project using different package managers. It also shows how to set up testing using the '@cloudflare/vitest-pool-workers' package.

```sh

yarn add -D @cloudflare/workers-types

pnpm add -D @cloudflare/workers-types

bun add --dev @cloudflare/workers-types
ts
import { Hono } from 'hono'

const app = new Hono()
app.get('/', (c) => c.text('Please test me!'))
```

You can test if it returns a '_200 OK_' Response with this code.

- The '-D' flag in the commands is used to add the package as a development dependency.
- The '@cloudflare/workers-types' package provides TypeScript definitions for Cloudflare Workers.
- The '@cloudflare/vitest-pool-workers' package is recommended for testing Hono applications.

- [Hono Documentation](https://honojs.com)
- [Cloudflare Workers Types](https://www.npmjs.com/package/@cloudflare/workers-types)
- [Vitest Pool Workers](https://www.npmjs.com/package/@cloudflare/vitest-pool-workers)

- Setting up a new Hono project
- Adding development dependencies to a Hono project
- Setting up testing for a Hono application

#### Code Snippet

```typescript

For testing, we recommend using '@cloudflare/vitest-pool-workers'. You can refer to the [examples](https://github.com/honojs/examples) for setting it up.

Here is an example of a simple test case for a Hono application:

```

**Reasoning:** This rule is important as it demonstrates how to add development dependencies in a Hono project using different package managers like yarn, pnpm, and bun. It also shows how to set up testing using the '@cloudflare/vitest-pool-workers' package and provides an example of a simple test case for a Hono application.

*Source: docs/getting-started/cloudflare-workers.md*

### Testing a Basic Hono Application

This code demonstrates how to test a basic Hono application using Jest. The application is set up to respond to GET requests at the root URL ('/') with a text response.

```ts
import { Hono } from 'hono'

const app = new Hono()
app.get('/', (c) => c.text('Please test me!'))
ts
describe('Test the application', () => {
  it('Should return 200 response', async () => {
    const res = await app.request('http://localhost/')
    expect(res.status).toBe(200)
  })
})
```

This works by making a request to the application and checking the status of the response. If the status is 200, the test passes.

- The `app.request` method is a part of Hono's API that allows for making requests to the application.
- Jest's `expect` function is used to assert that the response status is 200.

- [Hono Documentation](https://honojs.com/docs)
- [Jest Documentation](https://jestjs.io/docs)

- Testing the response of different routes in your Hono application.
- Checking the status code of HTTP responses.

#### Code Snippet

```typescript

We can test if it returns a 200 OK response with this code:

```

**Reasoning:** This rule is important as it demonstrates how to test a basic Hono application using Jest. It shows how to make a request to the application and check if it returns a 200 status code, which indicates a successful HTTP request. This is a fundamental part of developing and maintaining reliable web applications.

*Source: docs/getting-started/cloudflare-workers.md*

### Binding and Accessing Environment Values in Hono

In the Cloudflare Workers, we can bind the environment values, KV namespace, R2 bucket, or Durable Object. You can access them in `c.env`. It will have the types if you pass the '_type struct_' for the bindings to the `Hono` as generics.

```ts
type Bindings = {
  MY_BUCKET: R2Bucket
  USERNAME: string
  PASSWORD: string
}

const app = new Hono<{ Bindings: Bindings }>()
```

1. Define a type for the bindings.
2. Pass this type as a generic parameter when creating a new Hono instance.
3. Access the bindings in `c.env`.

- The bindings are available in `c.env`.
- The bindings have types if you pass the '_type struct_' for the bindings to the `Hono` as generics.

- [Hono documentation](https://hono.beyondco.de/docs/getting-started)

- Binding environment values in Cloudflare Workers
- Accessing KV namespace, R2 bucket, or Durable Object in Cloudflare Workers

**Reasoning:** This rule is important as it demonstrates how to bind environment values, KV namespace, R2 bucket, or Durable Object in Cloudflare Workers using Hono. It also shows how to access these bindings in `c.env` and how to pass the '_type struct_' for the bindings to the `Hono` as generics, which provides type safety.

*Source: docs/getting-started/cloudflare-workers.md*

### Using Environment Variables in Hono Middleware

In Hono, if you need to use environment variables or secret variables in middleware, such as 'username' or 'password' in Basic Authentication Middleware, you can do so as shown in the following code snippet.

```ts
import { basicAuth } from 'hono/basic-auth'

type Bindings = {
  USERNAME: string
  PASSWORD: string
}

const app = new Hono<{ Bindings: Bindings }>()

//...

app.use('/auth/*', async (c, next) =>
```

This is particularly useful when you need to use sensitive data like usernames or passwords in your middleware, which should not be hard-coded for security reasons. Instead, these values can be stored in environment variables and accessed as shown.

- This is the only case for Module Worker mode.
- Always ensure to keep your environment variables secure and do not expose them in your code or version control systems.

- [Hono Documentation](https://hono.boutell.com/)

- Using environment variables for sensitive data in middleware
- Implementing Basic Authentication using environment variables

**Reasoning:** This rule is important as it demonstrates how to use environment variables in Hono middleware. This is particularly useful when you need to use sensitive data like usernames or passwords in your middleware, which should not be hard-coded for security reasons.

*Source: docs/getting-started/cloudflare-workers.md*

### Setting up Authentication Middleware and Deploying Hono Project to Cloudflare using GitHub Actions

This code snippet demonstrates how to set up basic authentication middleware in a Hono application. The same process can be applied to other types of authentication middleware such as Bearer Authentication Middleware, JWT Authentication, etc.

```text
app.use('/auth/*', async (c, next) => {
  const auth = basicAuth({
    username: c.env.USERNAME,
    password: c.env.PASSWORD,
  })
  return auth(c, next)
})
```

The snippet also shows how to deploy a Hono project to Cloudflare using GitHub Actions. Before deploying, you need a Cloudflare token which can be managed from User API Tokens. If it's a newly created token, select the Edit Cloudflare Workers template. If you already have another token, make sure the token has the corresponding permissions.

Add a new secret with the name CLOUDFLARE_API_TOKEN in your GitHub repository settings dashboard. Then create .github/workflows/deploy.yml in your Hono project root folder and paste the deployment code.

The authentication middleware intercepts requests to '/auth/*' paths and checks if the provided username and password match the ones in the environment variables. If they match, the request is allowed to proceed, otherwise, it's rejected.

The deployment process is triggered whenever you push to the main branch of your repository. GitHub Actions checks out your code and deploys it to Cloudflare using the provided API token.

- Make sure to keep your Cloudflare API token secret to prevent unauthorized access to your Cloudflare account.

- [Hono Documentation](https://hono.boutell.com/)
- [Cloudflare Workers Documentation](https://developers.cloudflare.com/workers/)
- [GitHub Actions Documentation](https://docs.github.com/en/actions)

- Securing routes in your Hono application
- Automating the deployment of your Hono application to Cloudflare

**Reasoning:** This rule is important as it demonstrates how to set up authentication middleware in Hono and how to deploy a Hono project to Cloudflare using GitHub Actions. Understanding this rule is crucial for securing your Hono applications and for automating the deployment process.

*Source: docs/getting-started/cloudflare-workers.md*

### Configuring the 'wrangler.toml' file for Cloudflare Workers deployment

This code snippet demonstrates how to configure the 'wrangler.toml' file when deploying a Cloudflare Workers application.

```toml
main = "src/index.ts"
minify = true
```

After the `compatibility_date` line in the 'wrangler.toml' file, add the above lines. The `main` line specifies the main entry point for the application, which in this case is 'src/index.ts'. The `minify` line enables minification for the deployed code, which can help reduce the size of the deployed code and improve performance.

- The 'wrangler.toml' file is a configuration file used by the Wrangler CLI, which is a tool for deploying Cloudflare Workers applications.
- The `main` and `minify` options should be configured according to the specific needs of your application.

- [Wrangler CLI Documentation](https://developers.cloudflare.com/workers/cli-wrangler/configuration)

- Configuring the 'wrangler.toml' file for a Cloudflare Workers deployment

**Reasoning:** This rule is important as it demonstrates how to configure the 'wrangler.toml' file for a Cloudflare Workers deployment. It shows how to specify the main entry point for the application and enable minification for the deployed code.

*Source: docs/getting-started/cloudflare-workers.md*

### Configuring Environment Variables for Local Development in Cloudflare Worker Project

This code snippet demonstrates how to configure environment variables for local development in a Cloudflare worker project.

```text

To configure the environment variables for local development, create the `.dev.vars` file in the root directory of the project.
Then configure your environment variables as you would with a normal env file.
```

1. Create a `.dev.vars` file in the root directory of your project.
2. Add your environment variables to this file in the format `KEY=value`.

- Keep this file out of version control to prevent sensitive data from being exposed. Add `.dev.vars` to your `.gitignore` file.

- [Cloudflare Workers Documentation](https://developers.cloudflare.com/workers/wrangler/c)

- Storing API keys, database passwords, and other sensitive data.
- Managing configurations that vary between deployment environments.

**Reasoning:** This rule is important as it demonstrates how to configure environment variables for local development in a Cloudflare worker project. Environment variables are crucial for managing configurations that vary between deployment environments (like development, staging, production). They help to keep sensitive data like API keys, database passwords, etc., out of the codebase.

*Source: docs/getting-started/cloudflare-workers.md*

### Accessing Environment Variables in Hono with Cloudflare Workers

When working with Hono and Cloudflare Workers, environment variables are accessed differently than in other Node.js environments. Instead of using `process.env`, you should use `c.env.*`.

Here's a code snippet demonstrating this:

```ts
Then we use the `c.env.*` to get the environment variables in our code.

For Cloudflare Workers, environment variables must be obtained via `c`, not via `process.env`.
```

This is due to the way Cloudflare Workers handle environment variables. For more information, refer to the [Cloudflare documentation](https://developers.cloudflare.com/workers/wrangler/configuration/#secrets).

Common use cases include accessing API keys, database credentials, or other sensitive information stored in environment variables.

**Reasoning:** This rule is important as it demonstrates how to correctly access environment variables in a Hono application when using Cloudflare Workers. It's crucial to understand that in this context, environment variables must be accessed via `c.env.*` and not `process.env` as is common in other Node.js environments. This is due to the specific way Cloudflare Workers handle environment variables.

*Source: docs/getting-started/cloudflare-workers.md*

### Creating a new Hono application and installing dependencies

This code snippet demonstrates how to create a new Hono application and install its dependencies using different package managers. 

```sh
[yarn]
yarn create hono my-app
sh
[pnpm]
pnpm create hono my-app
sh
[bun]
bun create hono@latest my-app
sh
[deno]
deno init --npm hono my-app
sh
[npm]
cd my-app
npm i
sh
[yarn]
cd my-app
yarn
sh
[pnpm]
cd my-app
pnpm i
sh
[bun]
cd my-app
bun i
```

The `create` command is used to create a new application. The `cd` command is used to move into the application directory. The `i` or `install` command is used to install the dependencies of the application.

- Different package managers have different syntax for the same operations.
- Always ensure to install the dependencies after creating a new application.

- [Hono documentation](https://hono.com/docs)

- Setting up a new Hono application

**Reasoning:** This rule is important as it demonstrates how to create a new Hono application and install its dependencies using different package managers. Understanding this is crucial for setting up a new Hono project correctly.

*Source: docs/getting-started/cloudflare-pages.md*

### Navigating into a Project Directory and Installing Dependencies in Hono

This code snippet demonstrates how to navigate into a project directory and install dependencies using different package managers. It also provides a basic directory structure for a Hono project.

```sh
[npm]
cd my-app
npm i
sh
[yarn]
cd my-app
yarn
sh
[pnpm]
cd my-app
pnpm i
sh
[bun]
cd my-app
bun i
text
./
├── package.json
├── public
│   └── static // Put your static files.
│       └── style.css // You can refer to it as `/static/style.css`.
├── src
│   ├── index.tsx // The entry point for serve
```

The `cd` command is used to navigate into the project directory. The `i` command is used to install the dependencies listed in the `package.json` file. The directory structure shows where to place static files and the entry point for the server.

Different package managers (npm, yarn, pnpm, bun) can be used to install dependencies, but the exact command may vary.

- [Hono documentation](https://hono.bun.dev/)

This is a common setup step when starting a new Hono project or when pulling an existing project from a repository.

**Reasoning:** This rule is important as it demonstrates how to navigate into a project directory and install dependencies using different package managers. It also shows the basic directory structure for a Hono project, which is crucial for understanding how to organize files and directories in such a project.

*Source: docs/getting-started/cloudflare-pages.md*

### Setting Up a Basic Hono Application and Defining Routes

This code snippet demonstrates how to set up a basic Hono application and define routes.

```tsx
import { Hono } from 'hono'
import { renderer } from './renderer'

const app = new Hono()

app.get('*', renderer)

app.get('/', (c) => {
  return c.render(<h1>Hello, Cloudflare Pages!</h1>)
})
```

1. The Hono module is imported.
2. A new Hono application is created.
3. A wildcard route (`*`) is defined, which matches any path. The `renderer` function is used as the handler for this route.
4. A root route (`/`) is defined, which returns a rendered HTML string.

- The order of route definitions matters. Hono checks routes in the order they are defined.

- [Hono documentation](https://hono.boutique/docs)

- Setting up a new Hono application
- Defining routes in a Hono application

**Reasoning:** This rule is important as it demonstrates how to set up a basic Hono application and define routes. It shows the standard way of importing the Hono module, creating a new Hono application, and defining a wildcard route and a root route. This is a fundamental pattern in Hono application development.

*Source: docs/getting-started/cloudflare-pages.md*

### Defining Routes and Rendering Responses in Hono

This code snippet demonstrates how to define routes and render responses in a Hono application. It also shows how to run the application locally and access it via a web browser.

```javascript
} from 'hono'
import { renderer } from './renderer'

const app = new Hono()

app.get('*', renderer)

app.get('/', (c) => {
  return c.render(<h1>Hello, Cloudflare Pages!</h1>)
})

export default app
```

1. The `Hono` class is instantiated to create a new Hono application.
2. The `get` method is used to define routes. The first argument is the path, and the second argument is the handler function.
3. The `renderer` function is used to render responses.
4. The application is exported for use in other modules.

- The `*` path in the `get` method matches all routes.
- The `renderer` function should be defined in the same module or imported from another module.

- [Hono Documentation](https://hono.bun.dev/)

- Defining routes and rendering responses in a Hono application.
- Running a Hono application locally.

**Reasoning:** This rule is important as it demonstrates how to define routes and render responses in a Hono application. It also shows how to run the application locally and access it via a web browser.

*Source: docs/getting-started/cloudflare-pages.md*

### Deploying a Hono Application to Cloudflare

This code snippet demonstrates how to deploy a Hono application to Cloudflare using different package managers.

```sh
::: code-group

```sh [npm]
npm run deploy
sh [yarn]
yarn deploy
sh [pnpm]
pnpm run deploy
sh [bun]
bun run deploy

1. The `run deploy` command is used to deploy the application. The command that is used depends on the package manager that you are using.
2. In `package.json`, `$npm_execpath` needs to be changed to your package manager of choice.

- Make sure that you have a Cloudflare account before attempting to deploy.
- The package manager used must be installed in your system.

- [Hono Documentation](https://hono.bouffier.dev/docs)
- [Cloudflare Documentation](https://developers.cloudflare.com/pages/)

- Deploying a Hono application to the cloud for user accessibility.

**Reasoning:** This rule is important as it demonstrates how to deploy a Hono application to Cloudflare using different package managers. It shows the necessary commands to run in the terminal for different package managers (npm, yarn, pnpm, bun) to deploy the application. This is crucial for developers to understand as it allows them to deploy their applications to the cloud, making it accessible to users.

*Source: docs/getting-started/cloudflare-pages.md*

### Deploying Hono Application via Cloudflare Dashboard with GitHub and Creating Local Bindings

This code snippet demonstrates how to deploy a Hono application via the Cloudflare dashboard with GitHub and how to create local bindings using the `wrangler.toml` file.

```text

1. Log in to the [Cloudflare dashboard](https://dash.cloudflare.com) and select your account.
2. In Account Home, select Workers & Pages > Create application > Pages > Connect to Git.
3. Authorize your GitHub account, and select the repository. In Set up builds and deployments, provide the following information:

| Configuration option | Value           |
| -------------------- | --------------- |
| Production branch    | `main`          |
| Build command        | `npm run build` |
| Build directory      | `dist`          |

You can use Cloudflare Bindings like Variables, KV, D1, and others.
In this section, let's use Variables and KV.

First, create `wrangler.toml` for local Bindings:
```

1. The Cloudflare dashboard is used to connect to a GitHub repository and set up the build and deployment settings.
2. The `wrangler.toml` file is created for local bindings. This file is used to specify variables that can be used in the Hono application.

- Make sure to replace the `main` branch, `npm run build` command, and `dist` directory with the actual values for your Hono application.
- The `wrangler.toml` file should be located in the root directory of your Hono application.

- [Cloudflare Workers Documentation](https://developers.cloudflare.com/workers/)

- Deploying a Hono application to production
- Setting up local bindings for a Hono application

**Reasoning:** This rule is important as it demonstrates how to deploy a Hono application via the Cloudflare dashboard with GitHub and how to create local bindings using the `wrangler.toml` file. Understanding this process is crucial for deploying and managing Hono applications in a production environment.

*Source: docs/getting-started/cloudflare-pages.md*

### Creating and Specifying a Variable in `wrangler.toml` File

This code snippet demonstrates how to create and specify a variable in the `wrangler.toml` file in the Hono framework.

```toml
[vars]
MY_NAME = "Hono"
```

1. The `[vars]` section in the `wrangler.toml` file is used to define environment variables.
2. The variable `MY_NAME` is defined and assigned the value `Hono`.

- Variables defined in the `wrangler.toml` file can be accessed in the application code.
- The `wrangler.toml` file is a configuration file for the Wrangler CLI, which is used to manage and deploy Workers projects.

- [Wrangler Configuration](https://developers.cloudflare.com/workers/cli-wrangler/configuration)

- Defining environment-specific variables such as API keys, database connection strings, etc.
- Managing different configurations for different environments (development, staging, production).

**Reasoning:** This rule is important as it demonstrates how to create and specify a variable in the `wrangler.toml` file in the Hono framework. Understanding how to define variables is crucial for managing and configuring the application's environment.

*Source: docs/getting-started/cloudflare-pages.md*

### Creating a Key-Value Namespace in Cloudflare Workers

This code snippet demonstrates how to create a Key-Value (KV) namespace using the `wrangler` command in Cloudflare Workers.

```sh
wrangler kv namespace create MY_KV --preview
```

The `wrangler kv namespace create` command creates a new namespace under your account. The `--preview` flag is used to create the namespace in preview mode.

After running the command, you should note down the `preview_id` from the output. This `preview_id` will be used to bind the namespace to your worker.

- [Cloudflare Workers KV](https://developers.cloudflare.com/workers/runtime-apis/kv)

This command is commonly used when setting up a new Cloudflare Worker project and you need to store data in a distributed, eventually-consistent key-value store.

**Reasoning:** This rule is important as it demonstrates how to create a Key-Value (KV) namespace using the `wrangler` command in Cloudflare Workers. KV namespaces are a feature of Cloudflare Workers that allow you to store data in a distributed, eventually-consistent key-value store. This is a fundamental step in setting up a Cloudflare Worker project.

*Source: docs/getting-started/cloudflare-pages.md*

### Creating and Binding a KV Namespace in Cloudflare

This code snippet demonstrates how to create a Key-Value (KV) namespace in Cloudflare and bind it to a specific identifier using the `wrangler` command.

```sh
wrangler kv namespace create MY_KV --preview

{ binding = "MY_KV", preview_id = "abcdef" }
toml
[[kv_namespaces]]
binding = "MY_KV"
id = "abcdef"
```

The `wrangler` command creates a new KV namespace. The `--preview` flag is used to get a `preview_id` which is then used to bind the namespace to a specific identifier.

- The `preview_id` is unique to each KV namespace and is used to identify it.
- The `binding` is the identifier to which the KV namespace is bound.

- [Cloudflare KV Namespace Documentation](https://developers.cloudflare.com/workers/runtime-apis/kv)

- Storing and retrieving data in a distributed, low-latency manner for high-performance web applications.

#### Code Snippet

```typescript

After running the command, note down the `preview_id` from the output.

```

**Reasoning:** This rule is important because it demonstrates how to create a Key-Value (KV) namespace in Cloudflare using the `wrangler` command, and how to bind it to a specific identifier. This is crucial in Hono as it allows for the storage and retrieval of data in a distributed, low-latency manner, which is essential for high-performance web applications.

*Source: docs/getting-started/cloudflare-pages.md*

### Creating and Binding a Namespace in Cloudflare Workers KV

In Cloudflare Workers, you can create a namespace in Workers KV by running the following `wrangler` command:

```sh
wrangler kv namespace create MY_KV --preview

{ binding = "MY_KV", preview_id = "abcdef" }
toml
[[kv_namespaces]]
binding = "MY_KV"
id = "abcdef"
```

The `wrangler kv namespace create` command creates a new namespace in Workers KV. The `--preview` flag ensures that the namespace is only created in the preview environment, not in the production environment.

The `preview_id` is a unique identifier for the namespace. You need to specify this ID along with the binding name in your application's configuration file to bind the namespace to your application.

- Make sure to replace `MY_KV` and `abcdef` with your actual binding name and preview ID.
- The binding name must be unique across your application.

- [Cloudflare Workers KV Documentation](https://developers.cloudflare.com/workers/runtime-apis/kv)

- Storing and retrieving data in a distributed, eventually consistent key-value store in a Cloudflare Workers application.

#### Code Snippet

```typescript

This command will output a `preview_id` that you need to note down:

```

**Reasoning:** This rule is important as it demonstrates how to create a namespace in Cloudflare Workers KV and bind it to a specific ID. This is a crucial step in setting up a Cloudflare Workers environment, as it allows the application to store and retrieve data in a distributed, eventually consistent key-value store. The rule also shows how to configure the binding in the application's configuration file.

*Source: docs/getting-started/cloudflare-pages.md*

### Editing the `vite.config.ts` File in Hono

In a Hono project, the `vite.config.ts` file is used to configure the Vite development server and build process. This file is crucial for the proper functioning of a Hono application.

Here is a code snippet demonstrating how to edit this file:

```ts

Edit the `vite.config.ts`:
```

To edit this file, you need to import the necessary modules from Hono, such as the development server and the Cloudflare adapter. Then, you can define your configuration using the `defineConfig` function from Vite.

It's important to note that the specific configuration will depend on the needs of your project. Always refer to the Hono and Vite documentation for more details on how to configure your application.

- [Hono Documentation](https://hono.dev/docs)
- [Vite Documentation](https://vitejs.dev/config/)

- Configuring the development server for a Hono application
- Setting up the build process for a Hono application

**Reasoning:** This rule is important as it demonstrates how to edit the `vite.config.ts` file in a Hono project. This file is crucial for configuring the Vite development server and build process, which are essential for the proper functioning of a Hono application.

*Source: docs/getting-started/cloudflare-pages.md*

### Using Bindings in Hono Applications

In Hono, you can use bindings to utilize variables and key-value (KV) pairs in your application. It is important to set the types for these bindings to ensure type safety and improve code readability and maintainability.

Here is a code snippet demonstrating this:

```ts
type Bindings = {
  MY_NAME: string
  MY_KV: KVNamespace
}

const app = new Hono<{ Bindings: Bindings }>()
```

In this snippet, a `Bindings` type is defined with `MY_NAME` as a string and `MY_KV` as a `KVNamespace`. Then, a new Hono application is created with these bindings.

When you define a type for your bindings, you specify the types of the variables and KV pairs you will use in your application. This helps TypeScript to understand the types of these bindings and can prevent type-related errors.

- Always define types for your bindings to ensure type safety.

- [Hono Documentation](https://hono.boutique/docs)

- Using bindings to store and retrieve application-specific data.
- Using bindings to manage environment-specific variables.

**Reasoning:** This rule is important as it demonstrates how to use bindings in a Hono application. Bindings allow you to use variables and key-value (KV) pairs in your application. By setting the types for these bindings, you ensure type safety and improve code readability and maintainability.

*Source: docs/getting-started/cloudflare-pages.md*

### Handling Different Environments in Hono

This rule demonstrates how to handle different environments in Hono, specifically for Cloudflare Pages and client-side scripts.

```text

For Cloudflare Pages, you will use `wrangler.toml` for local development, but for production, you will set up Bindings in the dashboard.

You can write client-side scripts and import them into your application using Vite's features.
If `/src/client.ts` is the entry point for the client, simply write it in the script tag.
Additionally, `import.meta.env.PROD` is useful for detecting whether it's running on a dev server or in the build phase.
```

For Cloudflare Pages, `wrangler.toml` is used for local development. For production, Bindings are set up in the dashboard. On the client-side, scripts can be written and imported into the application using Vite's features. The entry point for the client is `/src/client.ts`, which can be written in the script tag. The environment variable `import.meta.env.PROD` can be used to detect whether the application is running on a dev server or in the build phase.

It's crucial to correctly set up the environment configurations to ensure the application runs correctly in different environments.

- [Hono Documentation](https://hono.boutique/docs)

- Setting up different configurations for local development and production
- Detecting the running environment to adjust application behavior

**Reasoning:** This rule is important as it demonstrates how to handle different environments in Hono, specifically for Cloudflare Pages and client-side scripts. It shows how to use different configuration files for local development and production, and how to use environment variables to detect the running environment.

*Source: docs/getting-started/cloudflare-pages.md*

### Configuring Hono Application with vite.config.ts

The `vite.config.ts` file is used to configure your Hono application. This file is important for setting up your development environment and ensuring that your application runs correctly.

Here is an example of how to use the `vite.config.ts` file:

```ts
import pages from '@hono/vite-cloudflare-pages'
import devServer from '@hono/vite-dev-server'
import { defineConfig } from 'vite'

export default defineConfig(({ mode }) => {
  if (mode === 'client
```

In this example, we are importing the necessary modules and defining the configuration for our application. The `defineConfig` function is used to define the configuration for our application.

- The `vite.config.ts` file is crucial for setting up your development environment and ensuring that your application runs correctly.
- Make sure to import the necessary modules and define the configuration correctly.

- [Hono Documentation](https://hono.bike/docs)

- Setting up the development environment for a Hono application.

**Reasoning:** This rule is important as it demonstrates how to properly configure a Hono application using the `vite.config.ts` file. This is crucial for setting up the development environment and ensuring that the application runs correctly.

*Source: docs/getting-started/cloudflare-pages.md*

### Building Server and Client Script with Vite

This code snippet demonstrates how to use the Vite build command to compile the server and client script.

```sh
vite build --mode client && vite build
```

The `vite build --mode client` command builds the client script, while the `vite build` command builds the server script. The `&&` operator is used to run these commands sequentially.

- Ensure that Vite is installed and properly configured in your project before running these commands.

- [Vite Documentation](https://vitejs.dev/guide/build.html)

- Use this command when you want to compile your source code for production deployment.

**Reasoning:** This rule is important as it demonstrates how to build the server and client script using the Vite build command. This is a crucial step in the development process as it compiles the source code into a format that can be executed by the browser or server.

*Source: docs/getting-started/cloudflare-pages.md*

### Integrating Cloudflare Pages Middleware with Hono

Cloudflare Pages uses its own middleware system that is different from Hono's middleware. This can be enabled in a Hono application by exporting an `onRequest` function in a `_middleware.ts` file.

Here is a code snippet demonstrating this:

```ts
// functions/_middleware.ts
export async function onRequest(pagesContext) {
  console.log(`You are accessing ${pagesContext.request.url}`)
  return await pagesContext.next()
}
```

The `onRequest` function is exported from the `_middleware.ts` file. This function logs the URL being accessed and then calls the `next` function on the `pagesContext` object, allowing the request to proceed to the next middleware in the stack.

- The `_middleware.ts` file should be located in the `functions` directory of your Hono application.

- [Cloudflare Pages Middleware Documentation](https://developers.cloudflare.com/pages/functions/middleware/)

- Logging requests in a Hono application hosted on Cloudflare Pages.
- Implementing custom middleware functionality in a Hono application hosted on Cloudflare Pages.

**Reasoning:** This rule is important as it demonstrates how to integrate Cloudflare Pages middleware with Hono. It shows how to create and export an `onRequest` function in a `_middleware.ts` file, which is a key step in enabling Cloudflare Pages middleware in a Hono application.

*Source: docs/getting-started/cloudflare-pages.md*

### Using Hono's Middleware in Cloudflare Pages

This guide demonstrates how to use Hono's middleware as Cloudflare Pages middleware.

```ts
// functions/_middleware.ts
import { handleMiddleware } from 'hono/cloudflare-pages'

export const onRequest = handleMiddleware(async (c, next) => {
  console.log(`You are accessing ${c.req.url}`)
```

The `handleMiddleware` function from the 'hono/cloudflare-pages' module is imported and used to handle HTTP requests. The function logs the URL of the request.

- The `handleMiddleware` function is specific to the Hono framework and is used to handle HTTP requests in a Cloudflare Pages environment.

- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)

- Logging HTTP request URLs in a Cloudflare Pages environment using Hono's middleware.

**Reasoning:** This rule is important as it demonstrates how to use Hono's middleware as Cloudflare Pages middleware. It shows how to import and use the `handleMiddleware` function from the 'hono/cloudflare-pages' module to handle HTTP requests in a Cloudflare Pages environment.

*Source: docs/getting-started/cloudflare-pages.md*

### Using Middleware in Hono

This code snippet demonstrates how to use built-in and third-party middleware in Hono. Middleware is a crucial part of web development as it allows developers to add functionality to their applications in a modular and reusable way.

```ts
import { handleMiddleware } from 'hono/cloudflare-pages'
import { basicAuth } from 'hono/basic-auth'

export const onRequest = handleMiddleware(
  basicAuth({
    username: 'user',
    password: 'pass'
  })
)
```

In this example, we're adding Basic Authentication to our Hono application using Hono's Basic Authentication Middleware. This middleware will require a valid username and password to be provided with each request.

1. We import the `handleMiddleware` function from `hono/cloudflare-pages`.
2. We import the `basicAuth` middleware from `hono/basic-auth`.
3. We use the `handleMiddleware` function to apply the `basicAuth` middleware to our `onRequest` function.

- Middleware functions are applied in the order they are defined.
- Middleware can modify the request and response objects.

- [Hono's Basic Authentication Middleware](/docs/middleware/builtin/basic-auth)

- Adding authentication to your application.
- Logging requests.
- Handling errors.

**Reasoning:** This rule is important as it demonstrates how to use built-in and third-party middleware in Hono. Middleware is a crucial part of web development as it allows developers to add functionality to their applications in a modular and reusable way. In this case, the code shows how to add Basic Authentication to a Hono application using Hono's Basic Authentication Middleware.

*Source: docs/getting-started/cloudflare-pages.md*

### Accessing EventContext in Hono Framework

In Hono framework, you can access the `EventContext` object via `c.env` in `handleMiddleware`. This object provides information about the event that triggered the function.

Here is a code snippet demonstrating this:

```ts
// functions/_middleware.ts
import { handleMiddleware } from 'hono/cloudflare-pages'

export const onRequest = [
  handleMiddleware(async (c, next) => {
    c.env.eventContext.data.user = 'Joe'
  })
]
```

In this example, `c.env.eventContext.data.user` is being set to 'Joe'. This could be useful in scenarios where you need to modify or access event data.

- The `EventContext` object is read-only and its properties cannot be modified.

- [Cloudflare Pages API Reference](https://developers.cloudflare.com/pages/functions/api-reference/#eventcontext)

- Modifying or accessing event data
- Implementing custom logic based on event data

**Reasoning:** This rule is important as it demonstrates how to access the EventContext object in Hono framework using Cloudflare Pages. The EventContext object is a crucial part of Cloudflare Pages as it provides information about the event that triggered the function. Understanding how to access this object is key to effectively using the Hono framework with Cloudflare Pages.

*Source: docs/getting-started/cloudflare-pages.md*

### Setting and Accessing Event Context Data Using Middleware in Hono

This code demonstrates how to use middleware in Hono to set and access data in the event context. This is a common pattern in Hono and other web frameworks, allowing developers to share data across different parts of the application.

```ts
import { handleMiddleware } from 'hono/cloudflare-pages'

export const onRequest = [
  handleMiddleware(async (c, next) => {
    c.env.eventContext.data.user = 'Joe'
    await next()
  }),
]
ts
// functions/api/[[route]].ts
import type { EventContext } from 'hono/cloudflare-pages'
import { handle } from 'hono/cloudflare-pages'

// ...

type Env = {
  Bindings: {
    eventContext: EventContext
  }
}
```

The `handleMiddleware` function is used to create a middleware function that sets a user value in the event context. This middleware function is then added to the `onRequest` array, which is a list of middleware functions that are run when a request is received.

In the handler, the `EventContext` type is imported from 'hono/cloudflare-pages' and used to type the `eventContext` property of the `Env` type. The user value set in the middleware can then be accessed via `c.env.eventContext`.

- Middleware functions in Hono are asynchronous and must call the `next` function to pass control to the next middleware function in the stack.

- [Hono Documentation](https://hono.boutique/docs)

- Sharing data across different parts of the application
- Setting up context-specific data for handlers

#### Code Snippet

```typescript

Then, you can access the data value in via `c.env.eventContext` in the handler:

```

**Reasoning:** This rule is important as it demonstrates how to use middleware in Hono to set and access data in the event context. This is a common pattern in Hono and other web frameworks, allowing developers to share data across different parts of the application.

*Source: docs/getting-started/cloudflare-pages.md*

### Installing Azure Functions Core Tools on macOS

This code snippet demonstrates how to install Azure Functions Core Tools on macOS using Homebrew.

```sh
brew tap azure/functions
brew install azure-functions-core-tools@4
```

1. `brew tap azure/functions`: This command adds the Azure Functions repository to the list of formulae that brew tracks, updates, and installs from.

2. `brew install azure-functions-core-tools@4`: This command installs the Azure Functions Core Tools version 4.

- Ensure that Homebrew is installed on your macOS before running these commands.

- [Azure Functions Core Tools](https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-typescript?pivots=nodejs-model-v4#install-the-azure-functions-core-tools)

- Setting up the development environment for working with Azure Functions.

**Reasoning:** This rule is important as it demonstrates how to install Azure Functions Core Tools on macOS using Homebrew. Azure Functions Core Tools is a command line tool that allows you to create, test, run, and manage Azure Functions on your local development machine. It is a crucial step in setting up the development environment for working with Azure Functions.

*Source: docs/getting-started/azure-functions.md*

### Initializing a TypeScript Node.js V4 Project and Changing Default Route Prefix in Azure Functions

This code snippet demonstrates how to initialize a TypeScript Node.js V4 project and change the default route prefix of the host in Azure Functions.

```sh
func init --typescript
json
"extensions": {
    "http": {
        "routePrefix": ""
    }
}
```

The `func init --typescript` command initializes a new TypeScript Node.js V4 project in the current folder. The `routePrefix` property in `host.json` determines the default route prefix for all HTTP routes.

- The `routePrefix` property should be set to an empty string to remove the default route prefix.

- [Azure Functions documentation](https://docs.microsoft.com/en-us/azure/azure-functions/)

- Setting up a serverless function in Azure
- Changing the default route prefix for HTTP routes

#### Code Snippet

```typescript

After initializing the project, you can change the default route prefix of the host by adding the following property to the root json object of `host.json`:

```

**Reasoning:** This rule is important as it demonstrates how to initialize a TypeScript Node.js V4 project and how to change the default route prefix of the host in Azure Functions. This is a fundamental step in setting up a serverless function in Azure using the Hono framework.

*Source: docs/getting-started/azure-functions.md*

### Changing the Default Route Prefix in Azure Functions with Hono

This code snippet demonstrates how to change the default route prefix in Azure Functions when using the Hono framework.

```json
"extensions": {
    "http": {
        "routePrefix": ""
    }
}
```

This code should be added to the root JSON object of `host.json` in your Azure Functions project. The `routePrefix` property is set to an empty string, which removes the default '/api' prefix.

The default Azure Functions route prefix is '/api'. If you don't change it as shown above, be sure to start all your Hono routes with '/api'.

- [Azure Functions documentation](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference)

This rule is commonly used when you want to customize the route prefix in your Azure Functions project using the Hono framework.

**Reasoning:** This rule is important as it demonstrates how to change the default route prefix in Azure Functions when using the Hono framework. By default, Azure Functions uses '/api' as the route prefix. If this is not changed, all Hono routes must start with '/api'. This rule shows how to change this default setting, which can be useful in cases where a different route prefix is desired.

*Source: docs/getting-started/azure-functions.md*

### Setting Up a Basic Hono Application with Azure Functions

To start with, you need to install Hono and the Azure Functions adapter. Depending on your package manager, you can use one of the following commands:

```sh
yarn add @marplex/hono-azurefunc-adapter hono
sh
pnpm add @marplex/hono-azurefunc-adapter hono
sh
bun add @marplex/hono-azurefunc-adapter hono
ts
// src/app.ts
import { Hono } from 'hono'
const app = new Hono()

app.get('/', (c) => c.text('Hello Azure Functions!'))

export default app
```

This code creates a new Hono application and defines a GET route at the root path (`/`). When this route is accessed, it responds with the text 'Hello Azure Functions!'.

Finally, create a new file `src/functions/httpTrigger.ts` and add the necessary code to set up an Azure Functions HTTP trigger.

- Make sure to install the Azure Functions adapter alongside Hono. This adapter is necessary for Hono to work with Azure Functions.
- The `app.get` method is used to define a GET route. The first argument is the path, and the second argument is a callback function that takes a context object `c` and returns the response.

- [Hono Documentation](https://marplex.github.io/hono/)
- [Azure Functions Documentation](https://docs.microsoft.com/en-us/azure/azure-functions/)

- Setting up a basic Hono application with Azure Functions
- Defining simple routes in a Hono application

**Reasoning:** This rule is important as it demonstrates how to set up a basic Hono application with Azure Functions. It shows how to install necessary dependencies and create a simple 'Hello World' route.

*Source: docs/getting-started/azure-functions.md*

### Creating a Basic Hono Application and a HTTP Trigger Function in Azure

This code demonstrates how to set up a basic Hono application and how to create a HTTP trigger function in Azure using Hono.

```ts
// src/app.ts
import { Hono } from 'hono'
const app = new Hono()

app.get('/', (c) => c.text('Hello Azure Functions!'))

export default app
ts
// src/functions/httpTrigger.ts
import { app } from '@azure/functions'
import { azureHonoHandler } from '@marplex/hono-azurefunc-adapter'
import honoApp from '../app'

app.http('httpTrigger', {
  m
```

1. The first code snippet creates a new Hono application and sets up a route handler for GET requests at the root URL (`/`). The handler simply returns a text response.

2. The second code snippet imports the Hono application and sets up a HTTP trigger function in Azure. The `httpTrigger` function is configured to use the Hono application.

- The `azureHonoHandler` function from the `@marplex/hono-azurefunc-adapter` package is used to adapt the Hono application to work with Azure Functions.

- [Hono documentation](https://hono.marplex.net/)

- Setting up a basic Hono application
- Creating a HTTP trigger function in Azure using Hono

**Reasoning:** This rule is important as it demonstrates how to set up a basic Hono application and how to create a HTTP trigger function in Azure using Hono. Understanding this rule is crucial for developers who want to use Hono with Azure Functions.

*Source: docs/getting-started/azure-functions.md*

### Defining Supported HTTP Methods and Running a Hono Application

This code snippet demonstrates how to define the HTTP methods supported by your Hono application and how to run the development server locally.

```text
ds: [
    //Add all your supported HTTP methods here
    'GET',
    'POST',
    'DELETE',
    'PUT',
],
authLevel: 'anonymous',
route: '{*proxy}',
handler: azureHonoHandler(honoApp.fetch),
})
text
npm run start
text
yarn start
text
pnpm start
text
bun run start
```

The `ds` array is where you define all the HTTP methods your application supports. The `authLevel` is set to 'anonymous', which means no authentication is required. The `route` is set to '{*proxy}', which means all routes are handled by the specified handler.

The `npm run start` command starts the development server locally. You can access the application in your web browser at `http://localhost:7071`.

Make sure to define all the HTTP methods your application supports in the `ds` array. If a method is not defined, the application will not respond to requests using that method.

- [Hono documentation](https://www.eclipse.org/hono/docs/)

- Setting up and running a Hono application
- Defining supported HTTP methods

#### Code Snippet

```typescript

To run the development server locally, use the following command:

```

**Reasoning:** This rule is important as it demonstrates how to define HTTP methods supported by the Hono application, how to run the development server locally, and how to start the application using different package managers. Understanding this rule is crucial for setting up and running a Hono application.

*Source: docs/getting-started/azure-functions.md*

### Preparing a Project for Deployment to Azure

This code snippet demonstrates how to prepare a project for deployment to Azure. It involves building the project using different package managers such as npm, yarn, pnpm, and bun.

```text
:::

::: info
Before you can deploy to Azure, you need to create some resources in your cloud infrastructure. Please visit the Microsoft documentation on [Create supporting Azure resources for your function](https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-typescript?pivots=nodejs-model-v4&tabs=windows%2Cazure-cli%2Cbrowser#create-supporting-azure-resources-for-your-function)
:::

Build the project for deployment:

::: code-group
```

Before deploying a project to Azure, it's necessary to build the project. This can be done using the `build` command of the package manager that's being used. The `build` command compiles the source code into a format that can be run on the server.

- Before deploying to Azure, it's necessary to create some resources in the cloud infrastructure. This can be done by following the provided Microsoft documentation link.

- [Microsoft Documentation: Create supporting Azure resources for your function](https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-typescript?pivots=nodejs-model-v4&tabs=windows%2Cazure-cli%2Cbrowser#create-supporting-azure-resources-for-your-function)

- Preparing a project for deployment to Azure
- Building a project using different package managers

**Reasoning:** This rule is important as it demonstrates how to prepare a project for deployment to Azure using different package managers. It highlights the necessary steps to build the project before deploying it to the cloud infrastructure.

*Source: docs/getting-started/azure-functions.md*

### Deploying a Hono Project to Azure Cloud

This code snippet demonstrates how to deploy a Hono project to the Azure Cloud.

```sh
func azure functionapp publish <YourFunctionAppName>
```

The `func azure functionapp publish` command is used to deploy your project to the function app in Azure Cloud. You need to replace `<YourFunctionAppName>` with the name of your app.

- Ensure that you have the Azure Functions Core Tools installed on your machine.

- You need to be logged in to your Azure account in the terminal or command prompt from which you are running the command.

- [Azure Functions Core Tools](https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=windows%2Ccsharp%2Cbash)

- Deploying a Hono project to Azure Cloud for hosting.

- Updating a Hono project that is already hosted on Azure Cloud.

**Reasoning:** This rule is important as it demonstrates how to deploy a Hono project to the Azure Cloud. Understanding this process is crucial for developers who want to host their applications on the Azure platform.

*Source: docs/getting-started/azure-functions.md*

### Creating a New Hono Application and Installing Dependencies

This code snippet demonstrates how to create a new Hono application and install its dependencies using different package managers.

```sh
yarn create hono my-app
sh
pnpm create hono my-app
sh
bun create hono@latest my-app
sh
deno init --npm hono my-app
sh
cd my-app
npm i
sh
cd my-app
yarn
sh
cd my-app
pnpm i
sh
cd my-app
bun i
```

The `create` command is used to create a new application. The `cd` command is used to move to the application directory. The `i` or `install` command is used to install the dependencies.

- Ensure that you have the package manager installed on your system before running these commands.

- Hono Documentation

- Setting up a new Hono project

**Reasoning:** This rule is important as it demonstrates how to create a new Hono application and install its dependencies using different package managers. Understanding this rule is crucial for setting up a new Hono project correctly.

*Source: docs/getting-started/nodejs.md*

### Creating a Basic Hono Application

This code snippet demonstrates how to create a basic 'Hello World' application using the Hono web framework.

```ts
import { serve } from '@hono/node-server'
import { Hono } from 'hono'

const app = new Hono()
app.get('/', (c) => c.text('Hello Node.js!'))

serve(app)
```

1. The necessary modules are imported.
2. A new Hono application is created.
3. A route is defined for the root URL ('/') that responds with the text 'Hello Node.js!'.
4. The application is served using the 'serve' function.

- The 'serve' function starts the server and listens for requests.
- The 'get' method is used to define a route for HTTP GET requests.

- Hono documentation: https://hono.beyondco.de/docs/getting-started

- Creating a simple web server with Hono.
- Defining routes and handling requests in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono web framework. It shows how to import the necessary modules, create a new Hono application, define a route, and serve the application.

*Source: docs/getting-started/nodejs.md*

### Running a Hono Application Locally

This code snippet demonstrates how to run a Hono application on your local machine for development and testing purposes.

```text

Run the development server locally. Then, access `http://localhost:3000` in your Web browser.

::: code-group
```

1. The `npm run dev`, `yarn dev`, or `pnpm dev` command starts the development server.
2. Once the server is running, you can access the application by navigating to `http://localhost:3000` in your web browser.

- Make sure to install the necessary dependencies before running the server.
- Ensure that the port 3000 is not being used by another service.

- [Hono Documentation](https://hono.boutique/docs/)

- Running the application for local development and testing.
- Debugging the application in a local environment.

**Reasoning:** This rule is important as it demonstrates how to run a Hono application locally. It shows the commands to start the development server using different package managers like npm, yarn, and pnpm. Understanding how to run the server is crucial for local development and testing.

*Source: docs/getting-started/nodejs.md*

### Changing the Port Number in Hono

In Hono, you can specify the port number with the `port` option when calling the `serve` function. This is useful when you need to run your application on a different port than the default one.

Here is a code snippet demonstrating this:

```ts
serve({
  fetch: app.fetch,
  port: 8787,
})
```

In this example, the Hono application will run on port 8787.

The `serve` function takes an options object as its argument. One of the options you can specify is `port`, which determines the port number the application will run on.

- The `port` option only changes the port number for the current run of the application. If you want to permanently change the port number, you should set it in your application's configuration.

- [Hono API Documentation](https://hono.beyondnlp.com/api)

- Running your application on a different port in a development environment.
- Temporarily changing the port number for testing purposes.

**Reasoning:** This rule is important as it demonstrates how to change the port number in a Hono application. This is a common requirement in web development, as different environments may require the application to run on different ports.

*Source: docs/getting-started/nodejs.md*

### Accessing Raw Node.js APIs in Hono

In Hono, you can access the raw Node.js APIs from `c.env.incoming` and `c.env.outgoing`. This can be useful when you need to use specific Node.js features that are not directly exposed by Hono.

Here is a code snippet demonstrating this:

```ts
import { Hono } from 'hono'
import { serve, type HttpBindings } from '@hono/node-server'

// or `Http2Bindings` if you use HTTP2
type Bindings = HttpBindings & {
  /* ... */
}

const app = new Hono
```

The `c.env.incoming` and `c.env.outgoing` are properties of the context object `c` in Hono. They provide access to the raw incoming and outgoing Node.js APIs respectively.

- Be careful when using the raw Node.js APIs as they may not be compatible with the rest of your Hono application.

- [Hono documentation](https://hono.beyondco.de/docs/getting-started)

- When you need to use specific Node.js features that are not directly exposed by Hono.

**Reasoning:** This rule is important as it demonstrates how to access the raw Node.js APIs from within the Hono framework. This can be useful when developers need to use specific Node.js features that are not directly exposed by Hono.

*Source: docs/getting-started/nodejs.md*

### Creating a Basic HTTP Server and Serving Static Files with Hono

In Hono, you can create a basic HTTP server and serve static files from the local file system. The code snippet below demonstrates this:

```javascript
const app = new Hono<{ Bindings: Bindings }>()

app.get('/', (c) => {
  return c.json({
    remoteAddress: c.env.incoming.socket.remoteAddress,
  })
})

serve(app)
```

In this example, an instance of Hono is created and a GET route is defined for the root URL (`/`). The callback function for this route returns a JSON response containing the remote address of the client.

To serve static files, you can use the `serveStatic` function. For example, if a request to the path `/static/*` comes in and you want to return a file under `./static`, you can use `serveStatic` to achieve this.

- The `serveStatic` function is not shown in the code snippet but is mentioned in the text. It's a common function used in many web frameworks to serve static files.

- Hono documentation: https://hono.bike/

- Serving static files like images, CSS, and JavaScript in a web application.
- Creating a basic HTTP server.

**Reasoning:** This rule is important as it demonstrates how to create a basic HTTP server using Hono and how to serve static files from the local file system. Serving static files is a common requirement in many web applications, and understanding how to do this in Hono is crucial.

*Source: docs/getting-started/nodejs.md*

### Serving Static Files in Hono

This code demonstrates how to serve static files from a local file system using Hono web framework.

```ts
import { serveStatic } from '@hono/node-server/serve-static'

app.use('/static/*', serveStatic({ root: './' }))
```

When a request to the path `/static/*` comes in, Hono will return a file under `./static` directory.

The `serveStatic` function from `@hono/node-server/serve-static` is used as a middleware in the application. This function takes an options object where `root` property specifies the root directory from which to serve static assets.

- The path `/static/*` is a wildcard path that matches any path starting with `/static/`.
- The `root` option in `serveStatic` function specifies the root directory from which to serve static assets.

- [Hono documentation](https://hono.bevry.me/)

- Serving images, CSS, and JavaScript files in a web application.

**Reasoning:** This rule is important as it demonstrates how to serve static files from a local file system using Hono web framework. It shows how to handle incoming requests to a specific path and return a file from a specified directory. This is a common requirement in many web applications where static resources like images, CSS, and JavaScript files are served from the server.

*Source: docs/getting-started/nodejs.md*

### Serving Static Files in Specific Paths with Hono

In Hono, you can serve static files in specific paths using the 'serveStatic' function from '@hono/node-server/serve-static'. Here's an example of how to serve a 'favicon.ico' file in the directory root:

```ts
app.use('/favicon.ico', serveStatic({ path: './favicon.ico' }))
```

In this code snippet, 'app.use' is used to define a middleware function to be used for requests to the '/favicon.ico' path. The 'serveStatic' function is then used with the 'path' option set to './favicon.ico', which means that requests to '/favicon.ico' will be served the 'favicon.ico' file in the directory root.

- The 'serveStatic' function can be used to serve any static file, not just 'favicon.ico'.
- The path provided to 'serveStatic' should be relative to the directory where your server script is running.

- [Hono Documentation](https://hono.bike/docs)

- Serving a custom 404 page
- Serving images, stylesheets, and scripts for a website

**Reasoning:** This rule is important as it demonstrates how to serve static files in a specific path using the Hono web framework. It shows how to use the 'serveStatic' function from '@hono/node-server/serve-static' to serve a specific file (in this case, 'favicon.ico') in the directory root. This is a common requirement in web development, where certain files need to be served statically and at specific paths.

*Source: docs/getting-started/nodejs.md*

### Serving Static Files with Hono

In Hono, you can serve static files from different directories by mapping requests to specific paths to the corresponding static files in the server's file system. This is done using the `serveStatic` function and specifying the `root` or `path` option.

Here is an example of how to serve all files in the root directory when a request to the path `/static/*` comes in:

```ts
app.use('/static/*', serveStatic({ root: './' }))
ts
app.use('/favicon.ico', serveStatic({ path: './favicon.ico' }))
ts
app.use('*', serveStatic({ root: './static' }))
```

- The `serveStatic` function is part of the Hono framework and is used to serve static files.
- The `root` option specifies the root directory from which to serve static files.
- The `path` option specifies the path to a specific file to serve.

- [Hono Documentation](https://hono.bevry.me/)

- Serving static files like images, CSS, and JavaScript in a web application.
- Serving a favicon for a website.
- Serving files from different directories based on the request path.

#### Code Snippet

```typescript

If you want to serve a specific file, like `favicon.ico`, from the root directory, you can do it like this:

```

**Reasoning:** This rule is important as it demonstrates how to serve static files in different directories using Hono. It shows how to map requests to specific paths to the corresponding static files in the server's file system. This is a common requirement in web development, and understanding how to do it efficiently can greatly improve the performance and responsiveness of a web application.

*Source: docs/getting-started/nodejs.md*

### Using 'rewriteRequestPath' to Map URL Paths to Different Directories in Hono

In Hono, you can use the 'rewriteRequestPath' option to map a specific URL path to a different directory. This is particularly useful when you want to serve static files from a directory that is different from the one specified in the URL.

Here is a code snippet demonstrating this:

```ts
app.get(
  '/static/*',
  serveStatic({
    root: './',
    rewriteRequestPath: (path) =>
      path.replace(/^\/static/, '/statics'),
  })
)
```

In this example, any request to 'http://localhost:3000/static/*' will be mapped to the './statics' directory instead of the './static' directory.

The 'rewriteRequestPath' option takes a function that modifies the request path. In this case, the function replaces '/static' with '/statics' in the request path.

- The 'rewriteRequestPath' option only modifies the request path for the purpose of serving static files. It does not change the actual URL of the request.

- [Hono Documentation](https://hono.bevry.me/)

- Serving static files from a different directory than the one specified in the URL.
- Redirecting requests to a different directory based on certain conditions.

**Reasoning:** This rule is important as it demonstrates how to use the 'rewriteRequestPath' option in Hono to map a specific URL path to a different directory. This is useful in cases where you want to serve static files from a different directory than the one specified in the URL.

*Source: docs/getting-started/nodejs.md*

### Running Hono on a Node.js http2 Server

This code snippet demonstrates how to run Hono on a Node.js http2 Server.

```ts
import { createServer } from 'node:http2'

const server = serve({
  fetch: app.fetch,
  createServer,
})
```

1. The `createServer` function from the `node:http2` module is imported.
2. The `serve` function is called with an object that includes the `fetch` method from the Hono application and the `createServer` function.

- This setup is for an unencrypted http2 server. For an encrypted server, you would need to use the `createSecureServer` function from the `node:http2` module.

- [Node.js http2 Server](https://nodejs.org/api/http2.html)

- When you want to leverage the benefits of http2 in your Hono application.

**Reasoning:** This rule is important as it demonstrates how to run Hono on a Node.js http2 Server. It shows the basic setup for an unencrypted http2 server, which is crucial for developers who want to leverage the benefits of http2, such as server push, header compression, and full request and response multiplexing.

*Source: docs/getting-started/nodejs.md*

### Setting Up Unencrypted and Encrypted HTTP2 Servers in Node.js with Hono

This guide demonstrates how to set up both unencrypted and encrypted http2 servers in Node.js using the Hono framework.

```ts
import { createServer } from 'node:http2'

const server = serve({
  fetch: app.fetch,
  createServer,
})
ts
import { createSecureServer } from 'node:http2'
import { readFileSync } from 'node:fs'

const server = serve({
  fetch: app.fetch,
  createServer: createSecureServer,
  serverOptions: {
    key: readFileSync('path/to/key'),
    cert: readFileSync('path/to/cert')
  }
})
```

In the unencrypted server setup, the `createServer` function from the `node:http2` module is used. In the encrypted server setup, the `createSecureServer` function is used instead, along with server options for the SSL key and certificate.

**Important Notes:**

- Ensure that the paths to your SSL key and certificate are correct in the encrypted server setup.

**References:**

- [Node.js http2 Server](https://nodejs.org/api/http2.html)

**Common Use Cases:**

- Setting up a basic http2 server for a web application.
- Setting up a secure http2 server for a web application that handles sensitive data.

#### Code Snippet

```typescript

### Encrypted HTTP2 Server

```

**Reasoning:** This rule is important as it demonstrates how to set up both unencrypted and encrypted http2 servers in Node.js using the Hono framework. Understanding how to correctly implement these servers is crucial for ensuring the security and functionality of your web application.

*Source: docs/getting-started/nodejs.md*

### Building and Deploying a Hono Application

This code snippet demonstrates the necessary steps to build and deploy a Hono application.

```text
1. Add "outDir": "./dist" to the `compilerOptions` section `tsconfig.json`.
2. Add "exclude": ["node_modules"] to `tsconfig.json`.
3. Add "build": "tsc" to `script` section of `package.json`.
4. Run `npm install typescript --save-dev`.
5. Add "type": "module" to `package.json`.
6. Run `npm run build`!
Dockerfile
FROM node:20-alpine AS base

FROM base AS builder

RUN apk add --no-cache gcompat
WORKDIR /app

COPY package*json tsconfig.json src ./

RUN npm ci && \
    npm run build && \
    npm prune
```

The steps configure TypeScript and package.json for the application, install TypeScript as a development dependency, and build the application. The Dockerfile then creates a Docker image of the application, which can be deployed to any environment that supports Docker.

- The Dockerfile assumes that the application's source code is in a directory named 'src'. If your application's source code is in a different directory, you will need to modify the Dockerfile accordingly.

- [Hono's Vite plugins](https://github.com/honojs/vite-plugins)

- Building and deploying a Hono application
- Containerizing a Hono application for deployment

#### Code Snippet

```typescript

After these steps, a Dockerfile is provided for building a Docker image of the application.

```

**Reasoning:** This rule is important as it demonstrates the process of building and deploying a Hono application. It covers the necessary steps to configure TypeScript and package.json, install necessary dependencies, and build the application. It also provides an example of a Dockerfile for containerizing the application, which is a common practice for deploying web applications.

*Source: docs/getting-started/nodejs.md*

### Initializing a New Supabase Project

This code snippet demonstrates how to initialize a new Supabase project in the current directory.

```bash
supabase init
```

The `supabase init` command initializes a new Supabase project in the current directory. This is the first step in creating a new project with Supabase.

- Ensure that you have Supabase CLI installed on your machine before running this command.
- This command should be run in the directory where you want to create your new Supabase project.

- [Supabase CLI Documentation](https://supabase.io/docs/guides/cli)

- Starting a new project with Supabase.

**Reasoning:** This rule is important as it demonstrates the initialization of a new Supabase project, which is a fundamental step in starting any project with Supabase. Understanding this command is crucial for developers to get started with their projects.

*Source: docs/getting-started/supabase-functions.md*

### Creating a New Edge Function in Supabase

This guide demonstrates how to create a new Edge Function in a Supabase project using the Hono framework.

```bash
supabase functions new hello-world
```

The `supabase functions new` command is used to create a new Edge Function in your Supabase project. The `hello-world` argument specifies the name of the new function.

- The new function is created in the `supabase/functions` directory of your project.
- The function name should be unique within your project.

- [Supabase Documentation](https://supabase.io/docs)

- Adding new functionalities to your Supabase project.
- Creating a function to handle specific tasks in your application.

**Reasoning:** This rule is important as it demonstrates how to create a new Edge Function in a Supabase project using the Hono framework. Understanding this rule allows developers to effectively add new functionalities to their Supabase projects.

*Source: docs/getting-started/supabase-functions.md*

### Creating a Basic Function in Hono

This code snippet demonstrates how to create a basic 'Hello World' function using the Hono framework.

```ts
import { Hono } from 'jsr:@hono/hono'

// change this to your function name
const functionName = 'hello-world'
const app = new Hono().basePath(`/${functionName}`)

app.get('/hello', (c) => c.text('Hello from hono-server!'))

Deno.serve(app.fetch)
```

1. The Hono module is imported.
2. A constant `functionName` is defined with the name of the function.
3. A new Hono instance is created and the base path for the function is set using the `basePath` method.
4. A GET request handler for the '/hello' path is defined using the `get` method. The handler sends a text response 'Hello from hono-server!'.
5. The function is served using the `Deno.serve` method and the `fetch` method of the Hono instance.

- The function name should be unique within the project.
- The `basePath` method sets the base URL path for all routes of the Hono instance.

- Hono documentation: https://hono.bayrell.org/

- Creating a basic web server
- Defining request handlers for specific paths

**Reasoning:** This rule is important as it demonstrates how to create a basic 'Hello World' function using the Hono framework. It shows how to import the Hono module, define a function name, set a base path for the function, define a GET request handler for the '/hello' path, and serve the function using Deno. Understanding this pattern is crucial for developers to get started with creating web applications using the Hono framework.

*Source: docs/getting-started/supabase-functions.md*

### Starting Supabase Stack and Serving Functions Locally

This code snippet demonstrates how to start a Supabase stack and serve a function locally using Hono. It also shows how to bypass JWT verification during local development.

```bash
supabase start # start the supabase stack
supabase functions serve --no-verify-jwt # start the Functions watcher
```

1. `supabase start` command is used to start the Supabase stack.
2. `supabase functions serve --no-verify-jwt` command is used to start the Functions watcher. The `--no-verify-jwt` flag allows you to bypass JWT verification during local development.

- The `--no-verify-jwt` flag should only be used during local development and should not be used in a production environment.

- [Supabase Documentation](https://supabase.io/docs)

- Starting a Supabase stack and serving functions locally for testing and debugging purposes.

**Reasoning:** This rule is important as it demonstrates how to start a Supabase stack and serve a function locally using Hono. It also shows how to bypass JWT verification during local development, which can be useful for testing and debugging.

*Source: docs/getting-started/supabase-functions.md*

### Making GET Requests and Deploying Functions in Hono

This guide demonstrates how to make a GET request to a Hono server and how to deploy all Edge Functions in Supabase with a single command.

```bash
curl  --location  'http://127.0.0.1:54321/functions/v1/hello-world/hello'
bash
supabase functions deploy
```

The `--no-verify-jwt` flag allows you to bypass JWT verification during local development.

- [Hono Documentation](https://hono.eclipse.org/)
- [Supabase Documentation](https://supabase.io/docs)

These commands are commonly used during local development and deployment of applications using the Hono framework.

#### Code Snippet

```typescript

### How it Works

The `curl` command is used to make a GET request to the specified URL. The `--location` flag tells curl to handle redirects.

To deploy all your Edge Functions in Supabase, use the command:

```

**Reasoning:** This rule is important as it demonstrates how to make a GET request to a Hono server and how to deploy all Edge Functions in Supabase with a single command. Understanding these commands is crucial for local development and deployment of applications using the Hono framework.

*Source: docs/getting-started/supabase-functions.md*

### Deploying Functions in Supabase with Hono

This code snippet demonstrates how to deploy functions in Supabase using Hono.

To deploy all of your Edge Functions in Supabase, use the following command:

```bash
supabase functions deploy
bash
supabase functions deploy hello-world
```

The `supabase functions deploy` command deploys all the Edge Functions in your Supabase project. If you want to deploy a specific function, you can specify the function name after the `deploy` keyword.

- Make sure you have the necessary permissions to deploy functions in your Supabase project.

- [Supabase Functions Documentation](https://supabase.io/docs/guides/database)

- Deploying changes to your functions in a Supabase project.
- Deploying a specific function after making changes to it.

#### Code Snippet

```typescript

Alternatively, you can deploy individual Edge Functions by specifying the name of the function in the deploy command:

```

**Reasoning:** This rule is important as it demonstrates how to deploy functions in Supabase using Hono. It shows both the method to deploy all functions at once and the method to deploy a specific function. Understanding this rule is crucial for managing and deploying functions in a Supabase project.

*Source: docs/getting-started/supabase-functions.md*

### Deploying Functions in Supabase

This code snippet demonstrates how to deploy functions in Supabase. You can either deploy all functions at once or deploy individual functions by specifying the function name.

```bash
supabase functions deploy
bash
supabase functions deploy hello-world
```

The `supabase functions deploy` command deploys all the functions in your Supabase project. If you want to deploy a specific function, you can do so by specifying the function name after the deploy command.

- Make sure you have the correct permissions to deploy functions.
- Ensure your function is working correctly before deploying to avoid breaking changes.

- [Supabase Documentation](https://supabase.com/docs/guides/functions/deploy)

- Deploying changes to a function in production
- Deploying all functions after a major update

#### Code Snippet

```typescript

To deploy an individual function, specify the function name in the deploy command:

```

**Reasoning:** This rule is important as it demonstrates how to deploy functions in Supabase, either all at once or individually. Understanding how to deploy functions is crucial for the development and production process, as it allows changes to be pushed live.

*Source: docs/getting-started/supabase-functions.md*

### Creating a new Hono application and installing dependencies

The following code snippets demonstrate how to create a new Hono application and install its dependencies using different package managers.

```sh
yarn create hono my-app
sh
pnpm create hono my-app
sh
bun create hono@latest my-app
sh
deno init --npm hono my-app
sh
cd my-app
npm i
sh
cd my-app
yarn
sh
cd my-app
pnpm i
sh
cd my-app
bun i
```

The `create` command is used to create a new Hono application. The `cd` command is used to move to the application directory. The `i` or `install` command is used to install the dependencies of the application.

- Make sure to use the correct command for your package manager.
- The `@latest` tag can be used to create an application with the latest version of Hono.

- [Hono documentation](https://hono.bun.dev/)

- Setting up a new Hono project

**Reasoning:** This rule is important as it demonstrates how to create a new Hono application and install its dependencies using different package managers. Understanding this rule is crucial for setting up a new Hono project correctly.

*Source: docs/getting-started/fastly.md*

### Creating a Basic 'Hello World' Application in Hono

This code snippet demonstrates how to create a basic 'Hello World' application using the Hono web framework.

```ts
// src/index.ts
import { Hono } from 'hono'
const app = new Hono()

app.get('/', (c) => c.text('Hello Fastly!'))

app.fire()
```

1. Import the Hono web framework.
2. Create a new instance of Hono.
3. Define a GET route for the root URL ('/') that sends the text 'Hello Fastly!' as a response.
4. Start the Hono application with the `fire` method.

- The `c.text` method sends a text response to the client.
- The `fire` method starts the Hono application and begins listening for incoming requests.

- [Hono Documentation](https://hono.bun.dev/)

- Creating a basic web application with Hono.
- Defining routes and sending responses in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to create a basic 'Hello World' application using the Hono web framework. It shows the basic structure of a Hono application, how to define a route, and how to send a response from the server to the client.

*Source: docs/getting-started/fastly.md*

### Running a Hono Application Locally

This code snippet demonstrates how to run a Hono application locally. After setting up your application, you can start the development server and access your application via `http://localhost:7676` in your web browser.

```sh
npm run start
sh
yarn start
sh
pnpm run start
sh
bun run start
```

These commands start the development server for your Hono application. Depending on the package manager you're using, you can use either `npm`, `yarn`, `pnpm`, or `bun` to start the server.

Ensure that you have installed all the necessary dependencies before running these commands. If you encounter any errors, they are likely due to missing dependencies or configuration issues.

- [Hono Documentation](https://hono.dev/docs/getting-started)

This is a common step that you'll perform regularly during the development process. It's typically done after making changes to your code to test and debug your application.

**Reasoning:** This rule is important as it demonstrates how to run a Hono application locally. Running the application locally is a crucial step in the development process as it allows developers to test and debug their application before deploying it to a live environment.

*Source: docs/getting-started/fastly.md*

### Deploying an Application to Fastly

This code snippet demonstrates how to deploy an application to Fastly using different package managers like npm, yarn, pnpm, and bun.

```text
:::

To build and deploy your application to your Fastly account, type the following command. The first time you deploy the application, you will be prompted to create a new service in your account.

If you don't have an account yet, you must [create your Fastly account](https://www.fastly.com/signup/).

::: code-group
```

1. The command `npm run deploy`, `yarn deploy`, `pnpm run deploy`, or `bun run deploy` is used to build and deploy the application.
2. If it's the first time deploying the application, you will be prompted to create a new service in your Fastly account.

- You must have a Fastly account to deploy the application. If you don't have one, you can create it [here](https://www.fastly.com/signup/).

- [Fastly Documentation](https://docs.fastly.com/)

- Deploying an application to Fastly for the first time.
- Updating an existing application on Fastly.

**Reasoning:** This rule is important as it demonstrates how to deploy an application to Fastly using different package managers. It shows the commands needed to build and deploy the application, which is a crucial step in the development process.

*Source: docs/getting-started/fastly.md*

## Docs

### Creating a Basic Hono Application and Starting a New Project

This code snippet demonstrates how to create a basic Hono application and how to start a new Hono project using different package managers.

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()

app.get('/', (c) => c.text('Hono!'))

export default app
sh [npm]
npm create hono@latest
sh [yarn]
yarn create hono
sh [pnpm]
pnpm create hono@latest
sh [bun]
bun create hono@latest
sh [deno]
deno init --npm hono@latest
```

The `Hono` class is imported from the `hono` package. An instance of `Hono` is created and a GET route is defined for the root URL (`/`). The route handler function takes a context object `c` and sends a text response 'Hono!'.

To start a new project, the `create` command is used with the package manager. This command creates a new Hono project with the latest version.

- The `create` command may vary depending on the package manager.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Creating a basic Hono application
- Starting a new Hono project

#### Code Snippet

```typescript

To start a new Hono project, you can use the following commands depending on the package manager you are using:

```

**Reasoning:** This rule is important as it demonstrates how to create a basic Hono application and how to start a new Hono project using different package managers. Understanding this rule is crucial for developers to get started with Hono.

*Source: docs/index.md*

### Creating a new Hono project and understanding its features, use-cases, and who is using it

You can create a new Hono project using different package managers. Here are the commands for npm, yarn, pnpm, bun, and deno:

```sh
npm create hono@latest
sh
yarn create hono
sh
pnpm create hono@latest
sh
bun create hono@latest
sh
deno init --npm hono@latest
```

Hono is a simple web application framework that is ultrafast, lightweight, and works on multiple runtimes. It has built-in middleware, custom middleware, third-party middleware, and helpers. It also has first-class TypeScript support.

Hono can be used for building Web APIs, proxy of backend servers, front of CDN, edge application, base server for a library, and full-stack application.

Hono is used by various projects such as cdnjs, Cloudflare D1, Cloudflare Workers KV, BaseAI, Unkey, OpenStatus, Deno Benchmarks, Clerk, Drivly, and repeat.dev.

- [Who is using Hono in production?](https://github.com/orgs/honojs/discussions/1510)

- Building Web APIs
- Proxy of backend servers
- Front of CDN
- Edge application
- Base server for a library
- Full-stack application

**Reasoning:** This rule is important as it demonstrates how to create a new Hono project using different package managers. It also provides an overview of Hono's features, use-cases, and who is using it. This information is crucial for developers who are considering using Hono for their projects.

*Source: docs/index.md*

### Understanding Hono's Lightweight Nature

This code snippet demonstrates the lightweight nature of the Hono web framework. With the `hono/tiny` preset, its size is under 14KB when minified. This is significantly smaller compared to other web frameworks like Express, which is 572KB in size. This makes Hono a more efficient choice for developers who are concerned about the performance of their web applications.

```text
See [more benchmarks](/docs/concepts/benchmarks).

**Hono is so small**. With the `hono/tiny` preset, its size is **under 14KB** when minified. There are many middleware and adapters, but they are bundled only when used. For context, the size of Express is 572KB.
```

Hono achieves its small size by only bundling middleware and adapters when they are used. This means that unused features do not contribute to the overall size of the application.

- The size of the Hono framework can vary depending on the middleware and adapters used.

- [Hono Documentation](https://hono.beyondco.de/docs)

- Building lightweight web applications
- Building web applications where performance is a key concern

**Reasoning:** This rule is important as it demonstrates the lightweight nature of the Hono web framework. It shows that Hono, when minified, is significantly smaller in size compared to other web frameworks like Express. This is crucial for developers who are concerned about the performance and efficiency of their web applications.

*Source: docs/index.md*

### Understanding Key Features of Hono Framework

This code snippet provides an overview of the key features of the Hono web framework.

```text

Hono has multiple routers. RegExpRouter is the fastest router in the JavaScript world. It matches the route using a single large Regex created before dispatch. With SmartRouter, it supports all route patterns.

LinearRouter registers the routes very quickly, so it's suitable for an environment that initializes applications every time. PatternRouter simply adds and matches the pattern, making it small.

Thanks to the use of the Web Standards, Hono works on a lot of platforms.

- Cloudflare Workers
- Cloudflare Pages
- Fastly Compute
- Deno
- Bun
- Vercel
- AWS Lambda
- Lambda@Edge
- Others

And by using a Node.js adapter, Hono works on Node.js.

Hono has many middleware and helpers. This makes 'Write Less, do more' a reality.

Out of the box, Hono provides middleware and helpers for:

- Basic Authentication
- Bearer Authentication
- Body Limit
- Cache
- Compress
- Context Storage
- Cookie
- CORS
- ETag
- html
- JSX
- JWT Authentication
- Logger
- Language
- Pretty JSON
- Secure Headers
- SSG
- Streaming
- GraphQL Server
- Firebase Authentication
- Sentry
- Others!

For example, adding ETag and request logging only takes a few lines of code with Hono:
```

Hono provides a variety of routers, each with their own strengths and use cases. It also adheres to web standards, making it compatible with a wide range of platforms. Additionally, Hono provides a multitude of middleware and helpers to streamline development.

Understanding the different routers, the platforms Hono supports, and the available middleware and helpers is crucial for effective use of the Hono framework.

- [Hono Documentation](https://honojs.com/docs)

Hono can be used in a variety of web development scenarios, from creating serverless applications to building robust APIs.

**Reasoning:** This rule is important as it demonstrates the versatility and flexibility of the Hono web framework. It shows how Hono supports multiple routers, adheres to web standards, and provides a wide range of middleware and helpers. Understanding these features allows developers to effectively use Hono in various environments and for various use cases.

*Source: docs/index.md*

## Guides

### Avoid Creating 'Ruby on Rails-like Controllers' in Hono

In Hono, it is recommended to avoid creating 'Ruby on Rails-like Controllers'. This is because the path parameter cannot be inferred in the Controller without writing complex generics, which can make the code more complicated and harder to maintain.

Here is an example of what not to do:

```ts
// 🙁
// A RoR-like Controller
const booksList = (c: Context) => {
  return c.json('list books')
}

app.get('/books', booksList)
```

In this example, the `booksList` function is a 'Ruby on Rails-like Controller'. This is not recommended in Hono because the path parameter cannot be inferred in the Controller without writing complex generics.

- Avoid creating 'Ruby on Rails-like Controllers' in Hono.
- The path parameter cannot be inferred in the Controller without writing complex generics.

- [Hono Documentation](https://hono.bike/docs/guide)

- When defining routes and their corresponding handlers in a Hono application.

**Reasoning:** This rule is important as it emphasizes the best practice of avoiding the creation of 'Ruby on Rails-like Controllers' in Hono. This is because the path parameter cannot be inferred in the Controller without writing complex generics. This rule demonstrates the incorrect way of creating a controller in Hono.

*Source: docs/guides/best-practices.md*

### Avoid RoR-like Controllers in Hono

In Hono, it's recommended to write handlers directly after path definitions. This is because the path parameter cannot be inferred in the Controller without writing complex generics. Here's an example of what not to do:

```ts
// 🙁
// A RoR-like Controller
const bookPermalink = (c: Context) => {
  const id = c.req.param('id') // Can't infer the path param
  return c.json(`get ${id}`)
}
```

In this example, the `id` parameter cannot be inferred, leading to potential issues. Instead, write the handler directly after the path definition to avoid this issue.

- [Hono Documentation](https://hono.bike/docs)

This rule is commonly used when defining routes and handlers in a Hono application.

**Reasoning:** This rule is important as it demonstrates the best practice of writing handlers directly after path definitions in Hono. This is because the path parameter cannot be inferred in the Controller without writing complex generics, which can lead to unnecessary complexity and potential errors in the code.

*Source: docs/guides/best-practices.md*

### Defining Handlers Directly After Path Definitions in Hono

In Hono, it is recommended to define handlers directly after path definitions. This allows for better inference of path parameters, leading to cleaner and more efficient code.

Here is an example of how to do this:

```ts
app.get('/books/:id', (c) => {
  const id = c.req.param('id') // Can infer the path param
  return c.json(`get ${id}`)
})
```

In this example, the handler for the GET request to '/books/:id' is defined directly after the path definition. This allows the 'id' path parameter to be easily inferred and used within the handler.

Note: If you still want to create a RoR-like Controller, you can use `factory.createHandlers()` in `hono/factory`. However, this approach may not allow for as clean inference of path parameters.

**Reasoning:** This rule is important as it demonstrates the best practice for defining handlers directly after path definitions in Hono. This approach allows for better inference of path parameters, leading to cleaner and more efficient code.

*Source: docs/guides/best-practices.md*

### Creating RoR-like Controllers with Hono's factory.createHandlers()

This code demonstrates how to create a RoR-like Controller using Hono's factory.createHandlers() method and how to use middleware in the Hono framework.

```ts
import { createFactory } from 'hono/factory'
import { logger } from 'hono/logger'

// ...

const factory = createFactory()

const middleware = factory.createMiddleware(async (c, next) => {
  c.set('foo', 'bar')
  await next()
})

const handlers = factory.createHandlers(logger(), middleware, (c) => {
  return c.json(c.var.foo)
})

app.get('/api', ...handlers)
```

1. A factory is created using the createFactory() method from 'hono/factory'.
2. Middleware is created using the factory's createMiddleware() method. This middleware sets a variable 'foo' to 'bar' and then calls the next middleware in the stack.
3. Handlers are created using the factory's createHandlers() method. These handlers use the previously created logger and middleware, and return a JSON response containing the value of 'foo'.
4. The handlers are then used in an Express.js route.

- Using factory.createHandlers() ensures that type inference works correctly in TypeScript.

- Hono factory documentation: https://hono.bespokejs.com/docs/helpers/factory

- Creating RoR-like Controllers in Hono.
- Using middleware in Hono.

**Reasoning:** This rule is important as it demonstrates how to create a RoR-like Controller using Hono's factory.createHandlers() method. It also shows how to use middleware in the Hono framework. This pattern ensures that type inference works correctly, which is crucial for maintaining type safety in TypeScript.

*Source: docs/guides/best-practices.md*

### Organizing Endpoints into Separate Files in Hono

In Hono, it's a good practice to separate different endpoints into their own files. This helps in keeping the code organized and maintainable. For instance, if your application has `/authors` and `/books` endpoints, you can create `authors.ts` and `books.ts` files.

Here is an example of how to define basic CRUD operations in `authors.ts`:

```ts
// authors.ts
import { Hono } from 'hono'

const app = new Hono()

app.get('/', (c) => c.json('list authors'))
app.post('/', (c) => c.json('create an author', 201))
app.get('/:id', (c) => c.json(`get ${c.req.param('id')}`))

export default app
```

In this code:

- We first import the Hono framework.
- We create a new Hono application.
- We define three routes: a GET route for listing authors, a POST route for creating an author, and another GET route for fetching a specific author by ID.
- Finally, we export the Hono application so it can be used in other parts of our code.

**Important notes:**

- Make sure to export the Hono application at the end of the file so it can be imported and used in other parts of your code.
- The `c.req.param('id')` in the `app.get('/:id', (c) => c.json(`get ${c.req.param('id')}`))` line is used to access route parameters.

**References:**

- [Hono Documentation](https://hono.bayfront.cloud/)

**Common use cases:**

- Structuring a large Hono application with multiple endpoints.
- Defining basic CRUD operations for a resource.

**Reasoning:** This rule is important as it demonstrates how to structure a Hono application by separating different endpoints into their own files. This is a common practice in web development to keep code organized and maintainable. It also shows how to define basic CRUD operations using Hono's routing methods.

*Source: docs/guides/best-practices.md*

### Defining and Importing Routes in Hono Framework

This code demonstrates how to define routes for different resources in separate files and then import them into a main file in the Hono framework.

```ts
// books.ts
import { Hono } from 'hono'

const app = new Hono()

app.get('/', (c) => c.json('list books'))
app.post('/', (c) => c.json('create a book', 201))
app.get('/:id', (c) => c.json(`get ${c.req.param('id')}`))

export default app
```

In the above code, we define routes for the 'books' resource. We then export the 'app' instance so that it can be imported in other files.

This approach promotes modularity and separation of concerns, making the code easier to maintain and understand. It's a common practice in web development to separate routes based on the resources they handle.

- Each route handler is a function that takes a context object 'c' and returns a response using the 'json' method of the context object.
- The 'get' and 'post' methods of the 'app' instance are used to define GET and POST routes respectively.
- The ':id' in the path of the third route is a route parameter that can be accessed using 'c.req.param('id')'.

- [Hono Documentation](https://hono.bike/)

- Defining routes for different resources in a web application.
- Separating route definitions into different files for better code organization.

**Reasoning:** This rule is important as it demonstrates how to define routes for different resources in separate files and then import them into a main file in the Hono framework. This approach promotes modularity and separation of concerns, making the code easier to maintain and understand.

*Source: docs/guides/best-practices.md*

### Route Separation and Mounting in Hono

This code snippet demonstrates how to separate routes into different modules and then import and mount them on the main application in Hono.

```ts
// index.ts
import { Hono } from 'hono'
import authors from './authors'
import books from './books'

const app = new Hono()

// 😃
app.route('/authors', authors)
app.route('/books', books)

export default app
```

1. Import the Hono module and the route modules (authors and books in this case).
2. Create a new Hono application.
3. Use the `app.route()` method to mount the imported route modules on the desired paths.

- This pattern promotes code organization and modularity.
- It's a good practice to separate different parts of the application into different modules.

- [Hono Documentation](https://hono.bike/)

- Building a large scale application with Hono where routes need to be organized in a modular way.

**Reasoning:** This rule is important as it demonstrates how to structure a Hono application by separating routes into different modules and then importing and mounting them on the main application. This promotes code organization and modularity, making the code easier to maintain and understand.

*Source: docs/guides/best-practices.md*

### Using RPC Features in Hono

The code snippet demonstrates how to use the RPC feature in Hono by chaining methods to get the correct type and passing the type of the app to the hc function.

```ts
// authors.ts
import { Hono } from 'hono'

const app = new Hono()
  .get('/', (c) => c.json('list authors'))
  .post('/', (c) => c.json('create an author', 201))
  .get('/:id', (c) => c.json(`get ${c.req.param('id')}`))

export default app
ts
import app from './authors'
import { hc } from 'hono/client'

// 😃
const client = hc<typeof app>('http://localhost')
```

The Hono framework allows you to chain methods to define routes and their handlers. When you want to use the RPC feature, you can get the correct type by chaining as shown in the code snippet. The type of the app is then passed to the hc function to get the correct type.

Ensure that you correctly chain the methods and pass the correct type to the hc function to avoid type errors and ensure correct functionality.

- Hono documentation: https://hono.bevry.me/

- When you want to use the RPC feature in Hono and need to ensure type safety.

#### Code Snippet

```typescript

To use the RPC feature, pass the type of the app to the hc function as follows:

```

**Reasoning:** This rule is important as it demonstrates how to correctly use the RPC feature in Hono. It shows how to chain methods to get the correct type and how to pass the type of the app to the hc function to get the correct type. This is crucial for ensuring type safety and correct functionality when using the RPC feature in Hono.

*Source: docs/guides/best-practices.md*

### Correctly Typing the Client in Hono Framework

In Hono framework, it's important to correctly type the client. This can be achieved by passing the type of the 'app' to 'hc'. Here is a code snippet demonstrating this:

```ts
import app from './authors'
import { hc } from 'hono/client'

// 😃
const client = hc<typeof app>('http://localhost') // Typed correctly
```

By doing this, the client gets the correct type, ensuring type safety and expected behavior.

The 'hc' function in Hono takes the type of the 'app' as an argument and returns a client of that type. This is how the client gets correctly typed.

- Always pass the type of the 'app' to 'hc' to correctly type the client.

- [Hono RPC page](/docs/guides/rpc#using-rpc-with-larger-applications)

- When you want to ensure type safety and expected behavior of the client in Hono framework.

**Reasoning:** This rule is important as it demonstrates how to correctly type the client in Hono framework. By passing the type of the 'app' to 'hc', the client gets the correct type. This is crucial for maintaining type safety and ensuring that the client behaves as expected.

*Source: docs/guides/best-practices.md*

### Sharing API Specification with the Client in Hono

In Hono, you can share the API specification with the client by exporting the type. This allows the client to import it and understand the structure of the API.

Here is a code snippet demonstrating this:

```ts
export type AppType = typeof route
ts
import type { AppType } from '.'
import { hc } from 'hono/client'
```

`hc` is a function in Hono that helps with handling client-side operations.

By doing this, you ensure that the client and server are communicating with the same API structure, reducing potential errors and misunderstandings.

#### Code Snippet

```typescript

On the client side, you can then import this type along with `hc` from Hono:

```

**Reasoning:** This rule is important as it demonstrates how to share the API specification with the client in Hono. By exporting the type, the client can import it and understand the structure of the API. This is crucial for ensuring that the client and server are communicating with the same API structure, reducing potential errors and misunderstandings.

*Source: docs/guides/rpc.md*

### Creating a Client in Hono

This guide demonstrates how to create a client in Hono.

First, import the necessary modules and types. In this case, we need `hc` from 'hono/client' and `AppType`.

```ts
import type { AppType } from '.'
import { hc } from 'hono/client'
ts
const client = hc<AppType>('http://localhost:3000')
```

The 'hc' function is used to create a client in Hono. It takes a type and a server URL as arguments. The type is used to ensure that the client and server are using the same API specification.

- Ensure that the server URL is correct. If the server is not running or the URL is incorrect, the client will not be able to communicate with the server.

- [Hono Documentation](https://hono.bike/docs/guide/)

- Setting up a client to communicate with a Hono server.

#### Code Snippet

```typescript

Then, use the 'hc' function to create a client. Pass `AppType` as Generics and specify the server URL as an argument.

```

**Reasoning:** This rule is important as it demonstrates how to create a client in Hono. It shows the process of importing the necessary modules and types, and then using the 'hc' function to create a client. This is a fundamental step in setting up communication between the client and the server in a Hono application.

*Source: docs/guides/rpc.md*

### Creating a Client and Making a POST Request in Hono

This guide demonstrates how to create a client using the Hono framework, specify the server URL, and make a POST request to the server.

Here is the code snippet:

```ts
const client = hc<AppType>('http://localhost:8787/')

const res = await client.posts.$post({
  form: {
    title: 'Hello',
    body: 'Hono is a cool project',
  },
})
```

In the above code:

1. `hc` is a function to create a client. `AppType` is passed as Generics and the server URL is specified as an argument.
2. `client.{path}.{method}` is called and the data to be sent to the server is passed as an argument. In this case, `client.posts.$post` is making a POST request to the 'posts' path.

The response (`res`) is compatible with the 'fetch' Response, and data can be retrieved from it.

- Ensure the server URL is correct when creating the client.
- The data to be sent to the server should be in the correct format.

- [Hono Documentation](https://hono.bike/docs/)

- Sending data to the server
- Making POST requests

**Reasoning:** This rule is important as it demonstrates how to create a client using the Hono framework, specify the server URL, and make a POST request to the server. Understanding this rule is crucial for developers to interact with the server and send data using the Hono framework.

*Source: docs/guides/rpc.md*

### Making a POST request and handling response in Hono

This guide demonstrates how to make a POST request using Hono and handle the response.

Here is the code snippet:

```ts
const res = await client.posts.$post({
  form: {
    title: 'Hello',
    body: 'Hono is a cool project',
  },
})

if (res.ok) {
  const data = await res.json()
  console.log(data.message)
}
```

1. We make a POST request to the 'posts' endpoint using the `$post` method. The data we wish to send to the server is passed as an argument.
2. The response (`res`) is compatible with the 'fetch' Response.
3. We check if the response is ok (status code in the range 200-299).
4. If the response is ok, we retrieve the data from the server using `res.json()`.

- Always check if the response is ok before trying to retrieve the data.

- [Hono documentation](https://hono.bayrell.org/en/)

- Sending data to the server and retrieving the response data.

**Reasoning:** This rule is important as it demonstrates how to make a POST request using Hono and how to handle the response. It shows how to send data to the server and retrieve the response data. Understanding this is crucial for any server-client communication in web development using the Hono framework.

*Source: docs/guides/rpc.md*

### Specifying Status Code in Hono

In Hono, you can explicitly specify the status code, such as `200` or `404`, in `c.json()`. This status code will be added as a type for passing to the client. This is useful in scenarios where you want to inform the client about the status of the processed request.

```text

If you explicitly specify the status code, such as `200` or `404`, in `c.json()`. It will be added as a type for passing to the client.
```

When you specify a status code in `c.json()`, Hono adds it as a type that can be passed to the client. This allows the client to understand the status of the processed request.

- Always ensure to specify the correct status code based on the result of the processed request.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Informing the client about the status of the processed request.

**Reasoning:** This rule is important as it demonstrates how to explicitly specify the status code in Hono framework. This is crucial for client-server communication as it allows the server to inform the client about the status of the processed request.

*Source: docs/guides/rpc.md*

### Handling Error Responses in Hono

This code snippet demonstrates how to handle error responses in Hono. It shows how to return different HTTP status codes and response bodies depending on the result of the operation.

```ts
if (post === undefined) {
  return c.json({ error: 'not found' }, 404)
}

return c.json({ post }, 200)
```

In this example, if the post is not found (i.e., `post === undefined`), a 404 status code along with an error message is returned. If the post is found, a 200 status code along with the post is returned.

The `c.json` function is used to send a JSON response. The first argument is the response body and the second argument is the HTTP status code.

- It's important to return appropriate HTTP status codes to indicate the result of the operation.

- [Hono Documentation](https://hono.bike/docs/)

- Returning different responses based on the result of a database query.

**Reasoning:** This rule is important as it demonstrates how to handle error responses in Hono. It shows how to return different HTTP status codes and response bodies depending on the result of the operation. This is a common pattern in web development where different status codes indicate different outcomes to the client.

*Source: docs/guides/rpc.md*

### Handling Not Found Responses in Hono

In Hono, it's important to handle 'Not Found' responses correctly. Using 'c.notFound()' can lead to incorrect inference of the data that the client gets from the server. This can lead to unexpected behavior and bugs in the application.

Here's an example of how not to handle 'Not Found' responses:

```ts

If you want to use a client, you should not use `c.notFound()` for the Not Found response. The data that the client gets from the server cannot be inferred correctly.
```

Instead, you should handle 'Not Found' responses in a way that allows the client to correctly infer the data from the server.

When a 'Not Found' response is returned, the client needs to be able to correctly infer the data from the server. Using 'c.notFound()' can interfere with this process, leading to incorrect data inference.

Always handle 'Not Found' responses in a way that allows the client to correctly infer the data from the server.

- Hono Documentation

- Handling 'Not Found' responses in a web application built with Hono.

**Reasoning:** This rule is important as it demonstrates the correct way to handle 'Not Found' responses in Hono. Using 'c.notFound()' can lead to incorrect inference of the data that the client gets from the server. This can lead to unexpected behavior and bugs in the application.

*Source: docs/guides/rpc.md*

### Handling Routes with Path Parameters in Hono

This code snippet demonstrates how to handle routes that include path parameters in Hono.

```ts
const route = app.get(
  '/posts/:id',
  zValidator(
    'query',
    z.object({
      page: z.string().optional(),
    })
  ),
  (c) => {
    // ...
    return c.json({
      title: 'Night',
```

1. The `app.get` method is used to define a GET route.
2. The route includes a path parameter `:id` which can be used to get a specific post.
3. The `zValidator` function is used to validate the query parameters. In this case, it checks if the `page` query parameter is a string and is optional.

- The `zValidator` function is part of the zod library which is a runtime validation library.

- [Hono Documentation](https://hono.bayfrontcloud.com/)

- Fetching a specific resource based on the id from the URL.
- Validating query parameters in the request.

**Reasoning:** This rule is important as it demonstrates how to handle routes that include path parameters in Hono. It shows how to define a route with a path parameter and how to use the zValidator to validate the query parameters. This is a common pattern in web development where you need to handle dynamic routes and validate the incoming request parameters.

*Source: docs/guides/rpc.md*

### Including a String in the Path with 'param' and Returning a JSON Object in Hono

This code snippet demonstrates how to include a string in the path using the 'param' keyword and how to return a JSON object from a function in Hono.

```ts
Specify the string you want to include in the path with `param`.

const res = await client.posts[':id'].$get({
  param: {
    id: '123',
  },
  query: {},
})
```

In the above code, 'param' is used to specify the string that needs to be included in the path. The 'id' is set to '123', which will be included in the URL path. The '$get' function is then called to send a GET request to the server.

- The 'param' keyword is used to include a string in the path.
- The '$get' function is used to send a GET request to the server.

- [Hono Documentation](https://hono.eclipse.org/documentation/)

- When you need to include a specific string in the URL path.
- When you need to return a JSON object from a function.

**Reasoning:** This rule is important as it demonstrates how to include a string in the path using the 'param' keyword in Hono. It also shows how to return a JSON object from a function. Understanding this rule is crucial for developers to manipulate URL parameters and handle responses in Hono.

*Source: docs/guides/rpc.md*

### Using Parameters and Headers in Hono Client Requests

In Hono, you can specify the string you want to include in the path with `param`.

```ts
const res = await client.posts[':id'].$get({
  param: {
    id: '123',
  },
  query: {},
})
ts
const res = await client.search.$get(
  {
    //...
  },
  {
    headers: {
      'X-Custom-Header': 'Here is Hono Client',
      'X-User-Agent': 'hc',
    },
  }
)
```

In the first code snippet, the `param` object is used to specify the string you want to include in the path. In this case, the `id` parameter is set to '123'.

In the second code snippet, the `headers` object is used to append headers to the request. Here, the 'X-Custom-Header' and 'X-User-Agent' headers are set to 'Here is Hono Client' and 'hc' respectively.

- The `param` and `headers` objects are optional. If not provided, Hono will use the default values.
- The `param` object should match the parameters defined in the path. If the parameters do not match, Hono will throw an error.

- [Hono Documentation](https://hono.bike/docs)

- Retrieving a specific post by its ID
- Sending custom headers with a request

#### Code Snippet

```typescript

You can also append headers to the request to provide additional information that the server needs to process the request.

```

**Reasoning:** This rule is important as it demonstrates how to use parameters and headers in Hono client requests. Parameters are used to specify the string you want to include in the path, while headers can be appended to the request to provide additional information that the server needs to process the request.

*Source: docs/guides/rpc.md*

### Adding Custom Headers to All Requests in Hono

This code snippet demonstrates how to add custom headers to all requests in Hono.

```ts
const client = hc<AppType>('/api', {
  headers: {
    Authorization: 'Bearer TOKEN',
  }
})
```

In the above code, `hc` function is used to create a Hono client. The second argument to the `hc` function is an options object where we can specify common headers for all requests.

In this case, an `Authorization` header is added with a value of 'Bearer TOKEN'. This means that all requests made using this client will include this authorization token in their headers.

- Headers are case-insensitive.
- Not all headers can be set. Some are restricted because they are controlled by the user agent.

- [Hono Documentation](https://hono.bryntum.com/docs/)

- Adding authentication tokens to all requests.
- Setting custom user-agent strings for all requests.

**Reasoning:** This rule is important as it demonstrates how to add custom headers to all requests in Hono. Headers are often used to carry information for HTTP requests and responses. In this case, the headers are used for authentication and user agent identification. Understanding how to set these headers is crucial for secure and efficient communication between the client and server.

*Source: docs/guides/rpc.md*

### Using the `init` option to customize requests in Hono

In Hono, you can pass the fetch's `RequestInit` object to the request as the `init` option. This allows you to customize the request with various options such as method, headers, body, mode, credentials, cache, redirect, referrer, integrity, and keepalive.

```ts

You can pass the fetch's `RequestInit` object to the request as the `init` option. Below is an example of aborting a Request.
```

The `init` option is passed as an argument to the Hono client function. The `RequestInit` object is a built-in fetch API object that allows you to customize the request.

- The `init` option is optional. If not provided, Hono will use the default fetch options.

- [Fetch API - RequestInit](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request)

- Aborting a request
- Customizing request headers
- Sending a request with credentials

**Reasoning:** This rule is important as it demonstrates how to pass the fetch's `RequestInit` object to the request as the `init` option in Hono. This is a key feature of Hono that allows developers to customize the request with various options such as method, headers, body, mode, credentials, cache, redirect, referrer, integrity, and keepalive.

*Source: docs/guides/rpc.md*

### Using RequestInit Object and $url() Method in Hono

In Hono, the `RequestInit` object defined by `init` takes the highest priority. It can be used to overwrite things set by other options like `body`, `method`, and `headers`.

```ts
client.api.posts.$post(
  {
    json: {
      // Request body
    },
  },
  {
    // RequestInit object
    init: {
      signal: abortController.signal,
    },
  }
)

// ...

abortController.abort()
ts
// ❌ Will throw error
const client = hc<AppType>('/')
client.api.post.$url()

// ✅ Will work as expected
const client = hc<AppType>('http://localhost:8787/')
client.api.post.$url()
```

- Always use an absolute URL with the `$url()` method to avoid errors.
- The `RequestInit` object can be used to overwrite default settings, providing flexibility in request configuration.

- [Hono Documentation](https://hono.bike/#/)

- Overwriting default request settings with the `RequestInit` object.
- Accessing the endpoint URL using the `$url()` method.

#### Code Snippet

```typescript

You can get a `URL` object for accessing the endpoint by using `$url()`. However, you must pass in an absolute URL for this to work. Passing in a relative URL `/` will result in an error.

```

**Reasoning:** This rule is important as it demonstrates how to use the `RequestInit` object and the `$url()` method in Hono. The `RequestInit` object allows users to overwrite default settings such as `body`, `method`, and `headers`. The `$url()` method is used to access the endpoint URL, but it requires an absolute URL to function correctly.

*Source: docs/guides/rpc.md*

### Uploading Files Using a Form Body in Hono

In Hono, you can upload files using a form body. This is demonstrated in the following code snippet:

```ts
// client
const res = await client.user.picture.$put({
  form: {
    file: new File([fileToUpload], filename, { type: fileToUpload.type })
  },
});
```

How it works:

1. The `$put` method is used to send a PUT request to the server.
2. The `form` object is used to send form data. In this case, it's a file.
3. The `File` constructor is used to create a new File object from the given fileToUpload, filename, and file type.

Important notes:

- Ensure that the fileToUpload, filename, and file type are correctly defined.

References:

- [Hono Documentation](https://hono.bevry.me/)

Common use cases:

- Uploading profile pictures
- Uploading documents
- Uploading media files

**Reasoning:** This rule is important as it demonstrates how to upload files using a form body in Hono. Understanding this rule is crucial for developers to handle file uploads in their applications.

*Source: docs/guides/rpc.md*

### Setting a Custom `fetch` Method in Hono

In Hono, you can set a custom `fetch` method. This is particularly useful when the default `fetch` method is not suitable or needs to be overridden for specific use cases. For instance, in a Cloudflare Worker environment, you might want to use the Service Bindings' `fetch` method instead of the default one.

Here is an example of how to do this:

```toml

services = [
  { binding = "AUTH", service = "auth-service" },
]
ts
// src/client.ts
const client = hc<CreateProfileType>('/', {
  fetch: c.env.AUTH.fetch.bind(c.env.AUTH)
```

In this example, the `fetch` method from the `AUTH` service binding is used instead of the default `fetch` method.

- The custom `fetch` method should be compatible with the Fetch API.
- Be careful when binding the context (`this`) of the `fetch` method, as it might have unintended side effects if not done correctly.

- [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)

- Overriding the default `fetch` method in a Cloudflare Worker environment.

**Reasoning:** This rule is important as it demonstrates how to set a custom `fetch` method in Hono. This is useful in scenarios where the default `fetch` method may not be suitable or needs to be overridden for specific use cases, such as in a Cloudflare Worker environment.

*Source: docs/guides/rpc.md*

### Using InferRequestType and InferResponseType in Hono

In Hono, you can use `InferRequestType` and `InferResponseType` to understand the type of object to be requested and the type of object to be returned. This is crucial in ensuring type safety and predictability in your code.

Here is a code snippet demonstrating this:

```ts
import type { InferRequestType, InferResponseType } from 'hono/client'

// InferRequestType
const $post = client.todo.$post
type ReqType = InferRequestType<typeof $post>['form']

// InferResponseType
```

In this code snippet, `InferRequestType` is used to infer the type of the request object for a POST request. Similarly, `InferResponseType` can be used to infer the type of the response object.

This is particularly useful when you want to ensure that your code is type-safe and predictable, as it allows you to know exactly what type of object you are dealing with.

References:
- [Hono Documentation](https://hono.bike/docs/client/)

Common use cases:
- When you want to ensure type safety in your code
- When you want to understand the type of object you are dealing with

**Reasoning:** This rule is important as it demonstrates how to use the InferRequestType and InferResponseType in Hono to understand the type of object to be requested and the type of object to be returned. This is crucial in ensuring type safety and predictability in your code.

*Source: docs/guides/rpc.md*

### Using SWR with Hono

This guide demonstrates how to use the SWR library with the Hono framework. SWR is a React Hooks library for remote data fetching.

Here is the code snippet:

```tsx
import useSWR from 'swr'
import { hc } from 'hono/client'
import type { InferRequestType } from 'hono/client'
import type { AppType } from '../functions/api/[[route]]'

const App = () => {
  const
```

1. First, import the `useSWR` function from the SWR library.
2. Then, import the `hc` object from the 'hono/client' module.
3. Import the `InferRequestType` type from the 'hono/client' module.
4. Import the `AppType` type from the '../functions/api/[[route]]' module.
5. Finally, use these imports in your React component.

- The SWR library is not included with Hono, so you need to install it separately.

- [SWR Documentation](https://swr.vercel.app)

- Fetching data from a remote source in a React application using the Hono framework.

**Reasoning:** This rule is important as it demonstrates how to use the SWR library with the Hono framework. SWR is a React Hooks library for remote data fetching. The rule shows how to import the SWR library and use it in a Hono application. This is a common pattern when dealing with data fetching in a React application using the Hono framework.

*Source: docs/guides/rpc.md*

### Chaining Handlers for Correct Type Inference in Larger Applications with Hono

When working with larger applications in Hono, it's important to be careful about type inference. To ensure that types are always correctly inferred, you can chain the handlers. This approach helps to maintain consistency and avoid potential type-related errors.

Here is a code snippet demonstrating this:

```ts
// authors.ts
import { Hono } from 'hono'

const app = new Hono()
  .get('/', (c) => c.json('list authors'))
  .post('/', (c) => c.json('create an author', 201))
  .get('/:id', (c) => c.json(`get author ${c.params.id}`))
```

In this example, the handlers for GET and POST requests are chained together. This ensures that the types are always inferred correctly.

- Always chain handlers in larger applications to ensure correct type inference.

- [Building a larger application](/docs/guides/best-practices#building-a-larger-application)

- Building larger applications with Hono
- Ensuring correct type inference in larger applications

**Reasoning:** This rule is important as it demonstrates how to use RPC (Remote Procedure Call) in larger applications with Hono. It emphasizes the importance of type inference and how to maintain it by chaining handlers. This is crucial in larger applications to ensure consistency and avoid potential type-related errors.

*Source: docs/guides/rpc.md*

### Defining Routes and Sub-routes in Hono

This code snippet demonstrates how to define routes and sub-routes in a Hono application.

```javascript
const app = new Hono()
  .get('/', (c) => c.json('list books'))
  .post('/', (c) => c.json('create a book', 201))
  .get('/:id', (c) => c.json(`get ${c.req.param('id')}`))

export default app
javascript
import { Hono } from 'hono'
import authors from './authors'
import books from './books'

const app = new Hono()

const routes = app.route('/authors', authors).route('/books', books)
```

Here, the 'route' method is used to define sub-routes for authors and books. The route handlers for these sub-routes are chained using the '.' operator.

- Make sure to chain the route handlers for the top level of the app.
- Export the app after defining all the routes.

- [Hono documentation](https://hono.bike/)

- Defining routes for different resources in a web application.

#### Code Snippet

```typescript

In this example, the 'get' and 'post' methods are used to handle HTTP GET and POST requests respectively. The route parameter ':id' is used to get the id from the request URL.

Sub-routers can be imported and used as shown below:

```

**Reasoning:** This rule is important as it demonstrates how to define routes and sub-routes in a Hono application. It shows how to use the 'get' and 'post' methods to handle HTTP GET and POST requests respectively, and how to use route parameters. It also shows how to chain route handlers and how to import and use sub-routers.

*Source: docs/guides/rpc.md*

### Understanding Performance Implications of RPC with Hono

When using RPC with Hono, the number of routes can impact the performance of your IDE. This is due to the fact that Hono executes a large number of type instantiations to infer the type of your app based on the routes.

Here is an example of how Hono infers the type of your app:

```ts
// app.ts
export const app = new Hono().get('foo/:id', (c) =>
  c.json({ ok: true }, 200)
)
ts
export const app = Hono<BlankEnv, BlankSchema, '/'>().get
```

The more routes you have, the slower your IDE will become. Therefore, it's important to consider the number of routes in your app and the potential performance implications.

- Hono Documentation

- Building a web app with multiple routes using Hono
- Using RPC with Hono

#### Code Snippet

```typescript

Hono will infer the type as follows:

```

**Reasoning:** This rule is important as it highlights the performance implications of using RPC with Hono and how the number of routes can impact the IDE performance. It demonstrates how Hono infers the type of your app based on the routes and the potential performance issues that can arise due to massive amounts of type instantiations.

*Source: docs/guides/rpc.md*

### Hono Type Inference Based on Route

In Hono, the type of your application is inferred based on the route. For example, if your application has a route like this:

```ts
// app.ts
export const app = new Hono().get('foo/:id', (c) =>
  c.json({ ok: true }, 200)
)
ts
export const app = Hono<BlankEnv, BlankSchema, '/'>().get<
  'foo/:id',
  'foo/:id',
  JSONRespondReturn<{ ok: boolean }, 200>,
  BlankInput,
  BlankEnv
>('foo/:id', (c) => c.json({ ok: true }, 200)
```

Hono uses the route definition to infer the type of the application. This type inference is based on the parameters and return type of the route handler function.

- The type inference is based on the route definition, so it's important to define your routes correctly.

- [Hono Documentation](https://hono.bike/docs)

- Defining routes in a Hono application
- Understanding how Hono infers the type of your application

#### Code Snippet

```typescript

Hono will infer the type as follows:

```

**Reasoning:** This rule is important as it demonstrates how Hono infers the type of your application based on the route. Understanding this inference mechanism is crucial for developers to ensure that they are defining their routes correctly and that the application behaves as expected.

*Source: docs/guides/rpc.md*

### Handling Type Instantiation in Hono

Type instantiation in Hono can be time-consuming and slow down your IDE. This is especially true when you have a lot of routes. However, there are ways to mitigate this issue.

The code snippet is a type instantiation for a single route. While the user doesn't need to write these type arguments manually, `tsserver` in your IDE does this time-consuming task every time you use the app.

1. **Hono version mismatch**: If your backend is separate from the frontend and lives in a different directory, ensure that the Hono versions match. Using different Hono versions can lead to issues such as '_Type instantiation is excessively deep and possibly infinite_'.

2. **TypeScript project references**: If your backend and frontend are separate and you want to access code from the backend on the frontend, use TypeScript's project references. This allows one TypeScript codebase to access and use code from another TypeScript codebase.

3. **Compile your code before using it**: `tsc` can do heavy tasks like type instantiation at compile time, making your IDE faster. Compiling your client including the server app gives you the best performance.

- [Hono RPC And TypeScript Project References](https://catalins.tech/hono-rpc-in-monorepos/)
- [TypeScript Project References](https://www.typescriptlang.org/docs/handbook/project-references.html)

This rule is commonly used in large projects with many routes, where type instantiation can significantly slow down the IDE.

#### Code Snippet

```typescript
export const app = Hono<BlankEnv, BlankSchema, '/'>().get<
  'foo/:id',
  'foo/:id',
  JSONRespondReturn<{ ok: boolean }, 200>,
  BlankInput,
  BlankEnv
>('foo/:id', (c) => c.json({ ok: true }, 200))
```

**Reasoning:** This rule is important as it demonstrates how to handle type instantiation in Hono, which can be time-consuming and slow down your IDE if not managed properly. It also provides tips on how to mitigate this issue, such as ensuring Hono versions match between backend and frontend, using TypeScript project references, and compiling your code before using it.

*Source: docs/guides/rpc.md*

### Using hcWithType instead of hc to get the client with the type already calculated in Hono

This guide demonstrates how to use the 'hcWithType' function instead of 'hc' to get the client with the type already calculated in Hono. This is a best practice in Hono framework usage as it simplifies the process of getting the client and improves code readability.

Here is the code snippet:

```ts
const client = hc<typeof app>('')
export type Client = typeof client

export const hcWithType = (...args: Parameters<typeof hc>): Client =>
  hc<typeof app>(...args)
ts
const client = hcWithType('http://localhost:8787/')
const res = await client.posts.$post({
  form: {
    title: 'Hello',
    body: 'Hono is a cool project',
  },
})
```

The 'hcWithType' function takes the same parameters as 'hc' and returns a client with the type already calculated. This simplifies the process of getting the client and improves code readability.

- The 'hcWithType' function is a best practice in Hono framework usage.

- [Hono Documentation](https://hono.beeceptor.com)

- When you need to get the client with the type already calculated in Hono.

#### Code Snippet

```typescript

After compiling, you can use `hcWithType` instead of `hc` to get the client with the type already calculated.

```

**Reasoning:** This rule is important as it demonstrates how to use the 'hcWithType' function instead of 'hc' to get the client with the type already calculated in Hono. This is a best practice in Hono framework usage as it simplifies the process of getting the client and improves code readability.

*Source: docs/guides/rpc.md*

### Managing Dependencies in a Monorepo and Specifying Type Arguments Manually in Hono

In a monorepo project, you can use a tool like `turborepo` to easily separate the server project and the client project and manage dependencies between them. This can lead to better integration. Here is a working example: [Hono RPC Performance Tips Example](https://github.com/m-shaka/hono-rpc-perf-tips-example).

You can also coordinate your build process manually with tools like `concurrently` or `npm-run-all`.

```text
If your project is a monorepo, this solution does fit well. Using a tool like [`turborepo`](https://turbo.build/repo/docs), you can easily separate the server project and the client project and get better integration managing dependencies between them. Here is [a working example](https://github.com/m-shaka/hono-rpc-perf-tips-example).

You can also coordinate your build process manually with tools like `concurrently` or `npm-run-all`.
ts
const app = new Hono().get<'foo/:id'>('foo/:id', (c) =>
  c.json({ ok: true }, 200)
)
```

- [TurboRepo Documentation](https://turbo.build/repo/docs)
- [Hono RPC Performance Tips Example](https://github.com/m-shaka/hono-rpc-perf-tips-example)

#### Code Snippet

```typescript

In Hono, you can specify type arguments manually to avoid type instantiation. This can be a bit cumbersome, but it can make a difference in performance.

```

**Reasoning:** This rule is important as it demonstrates how to manage dependencies in a monorepo project using Hono. It also shows how to manually specify type arguments to avoid type instantiation, which can be beneficial for performance.

*Source: docs/guides/rpc.md*

### Improving Performance by Specifying Single Type Argument and Splitting App and Client into Multiple Files in Hono

This code demonstrates how to specify a single type argument in Hono to improve performance. It also shows how to split your app and client into multiple files for better code organization and manageability.

```text
Specifying just single type argument make a difference in performance, while it may take you a lot of time and effort if you have a lot of routes.

As described in [Using RPC with larger applications](#using-rpc-with-larger-applications), you can split your app into multiple apps. You can also create a client for each app:
```

1. Specify a single type argument when defining routes in Hono. This can improve performance.
2. Split your app into multiple apps and create a client for each app. This can make the code more manageable and easier to understand.

- Specifying a single type argument can improve performance but may require more time and effort if you have many routes.
- Splitting your app and client into multiple files can make the code more manageable but requires careful organization.

- [Using RPC with larger applications](#using-rpc-with-larger-applications)

- Large applications with many routes
- Applications where performance is a concern

**Reasoning:** This rule is important as it demonstrates how to improve performance in Hono by specifying a single type argument. It also shows how to structure larger applications by splitting the app and client into multiple files. This can make the code more manageable and easier to understand.

*Source: docs/guides/rpc.md*

### Using the Cookie Helper in Hono

The following code snippet demonstrates how to use the Cookie helper in Hono to get and set cookies.

```ts
import { getCookie, setCookie } from 'hono/cookie'

const app = new Hono()

app.get('/cookie', (c) => {
  const yummyCookie = getCookie(c, 'yummy_cookie')
  // ...
  setCookie(c, 'delicious_cookie', 'macha')
  //
})
```

1. First, the `getCookie` and `setCookie` functions are imported from `hono/cookie`.
2. A new Hono application is created.
3. A GET route '/cookie' is defined. In the callback function for this route, the `getCookie` function is used to retrieve a cookie named 'yummy_cookie'. The `setCookie` function is then used to set a cookie named 'delicious_cookie' with the value 'macha'.

- The `getCookie` function takes two arguments: the context object `c` and the name of the cookie.
- The `setCookie` function takes three arguments: the context object `c`, the name of the cookie, and the value of the cookie.

- [Hono Cookie Helper Documentation](/docs/helpers/cookie)

- Retrieving user preferences stored in cookies
- Setting session cookies for user authentication

**Reasoning:** This rule is important as it demonstrates how to use the Cookie helper in Hono to get and set cookies. Cookies are often used in web development for session management, personalization, and tracking user behavior.

*Source: docs/guides/helpers.md*

### Importing and Using Validator from Hono Framework

This guide demonstrates how to import and use the validator module from the Hono framework. The validator module is used to validate incoming values in applications.

Here is the code snippet:

```ts
import { validator } from 'hono/validator'
```

1. The `import` statement is used to import the `validator` module from the `hono/validator` package.

- The `validator` module should be imported at the beginning of your script, before it's used.

- [Hono Documentation](https://hono.bosch.io/docs/)

- Validating form data: You can use the `validator` module to validate form data, ensuring that the data entered by users is in the correct format and preventing potential issues related to incorrect data.

**Reasoning:** This rule is important as it demonstrates how to import and use the validator module from the Hono framework. The validator module is crucial for validating incoming values in applications, ensuring data integrity and preventing potential issues related to incorrect or malicious data.

*Source: docs/guides/validation.md*

### Form Validation with Validator Middleware in Hono

This code snippet demonstrates how to use the 'validator' middleware in Hono to validate form data in a POST request.

```ts
app.post(
  '/posts',
  validator('form', (value, c) => {
    const body = value['body']
    if (!body || typeof body !== 'string') {
      return c.text('Invalid!', 400)
    }
    return {
      body: body,
    }
  }),
  //...
```

In the above code, 'validator' is used as a middleware for the POST '/posts' route. The first argument to 'validator' is 'form', indicating that the data to be validated is form data. The second argument is a callback function that takes the form data and a context object 'c'. The function checks if the 'body' field of the form data is a string and if it's not, it returns a 400 response with the text 'Invalid!'. If the 'body' is valid, it returns an object with the 'body'.

Within the request handler, the validated data can be accessed using `c.req.valid('form')`.

- The 'validator' middleware is a powerful tool for validating user input in Hono. It should be used whenever user input needs to be validated.

- [Hono Documentation](https://hono.bike/docs/)

- Validating form data in POST requests
- Returning custom error responses for invalid data

**Reasoning:** This rule is important as it demonstrates how to use the 'validator' middleware in Hono to validate form data in a POST request. This is a common requirement in web applications where user input needs to be validated before processing. The rule also shows how to access the validated data within the request handler.

*Source: docs/guides/validation.md*

### Validating and Extracting Data from a Request in Hono

This code snippet demonstrates how to validate and extract data from a request in the Hono framework.

```ts
, (c) => {
  const { body } = c.req.valid('form')
  // ... do something
  return c.json(
    {
      message: 'Created!',
    },
    201
  )
}
```

In this example, the 'valid' method is used to validate and extract data from the 'form' part of the request. The validated data is then used in the handler.

Validation targets can include 'json', 'query', 'header', 'param', 'cookie' in addition to 'form'. When validating 'json', it is important to ensure that the request contains a 'Content-Type: application/json'.

- Always validate and sanitize data from the request before using it.
- Ensure the correct 'Content-Type' is set when validating 'json'.

- [Hono Documentation](https://hono.bike/)

- Validating and extracting data from the request in a POST or PUT API endpoint.

**Reasoning:** This rule is important as it demonstrates how to validate and extract data from a request in the Hono framework. It shows how to use the 'valid' method to validate and extract data from different parts of the request such as 'json', 'query', 'header', 'param', 'cookie' and 'form'. It also highlights the importance of setting the correct 'Content-Type' when validating 'json'.

*Source: docs/guides/validation.md*

### Setting Content-Type Header and Using Validator Middleware in Hono

In Hono, it's important to set the `content-type` header when testing using `app.request()`. Without it, the request body will not be parsed and a warning will be issued.

Here is an example of how to use the 'validator' middleware to validate and parse incoming request bodies.

```ts
const app = new Hono()
app.post(
  '/testing',
  validator('json', (value, c) => {
    // pass-through validator
    return value
  }),
  (c) => {
    const body = c.req.valid('json')
    return c.json(body)
  }
)
```

In this code, a POST route '/testing' is defined. The 'validator' middleware is used to validate and parse the request body as JSON. The validated and parsed body is then returned in the response.

- Always set the 'content-type' header in your requests when testing using `app.request()`.
- The 'validator' middleware is a powerful tool for validating and parsing request bodies in Hono.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Validating and parsing request bodies in API endpoints.

**Reasoning:** This rule is important as it demonstrates how to correctly use the 'validator' middleware in Hono to validate and parse incoming request bodies. It also shows the importance of setting the 'content-type' header in the request, as without it, the request body will not be parsed and a warning will be issued.

*Source: docs/guides/validation.md*

### Validating JSON Data and Headers in Hono

This rule demonstrates how to correctly validate and handle JSON data in Hono. It also shows the importance of setting the correct 'Content-Type' header when sending a request, and the need to use lowercase keys when validating headers.

```ts
r('json', (value, c) => {
    // pass-through validator
    return value
  }),
  (c) => {
    const body = c.req.valid('json')
    return c.json(body)
  }
)
```

The code first defines a pass-through validator for JSON data. Then, it uses this validator to validate the JSON data in the request body. If the 'Content-Type' header is not set to 'application/json', the validation will fail.

When validating headers, you need to use lowercase keys. For example, to validate the 'Idempotency-Key' header, you need to use 'idempotency-key' as the key.

- Hono Documentation

- Validating JSON data in a request
- Sending a request with a specific 'Content-Type' header
- Validating headers in a request

**Reasoning:** This rule is important as it demonstrates how to correctly validate and handle JSON data in Hono. It also shows the importance of setting the correct 'Content-Type' header when sending a request, and the need to use lowercase keys when validating headers.

*Source: docs/guides/validation.md*

### Always Use Lowercase for Header Key in Validation

When validating headers in Hono, always use lowercase for the header key. This is because Hono converts all header keys to lowercase. If you use a non-lowercase key, it will result in an undefined value, leading to unexpected behavior.

Here is an example of how to correctly validate the `Idempotency-Key` header:

```ts
// ❌ this will not work
app.post(
  '/api',
  validator('header', (value, c) => {
    // idempotencyKey is always undefined
    // so this middleware always return 400 as not expected
    const idempotencyKey = value['Idempotency-Key']

    if (idempotencyKey == undefined || idempotencyKey === '') {
      throw HTTPException(400, {
        message: 'Idempotency-Key is required',
      })
    }
    return { idempotencyKey }
  }),
  (c) => {
    const { idempotencyKey } = c.req.valid('header')
    // ...
  }
)

// ✅ this will work
app.post(
  '/api',
  validator('header', (value, c) => {
    // can retrieve the value of the header as expected
    const idempotencyKey = value['idempotency-key']

    if (idempotencyKey == undefined || idempotencyKey === '') {
      throw HTTPException(400, {
        message: 'Idempotency-Key is required',
      })
    }
    return { idempotencyKey }
  }),
  (c) => {
    const { idempotencyKey } = c.req.valid('header')
    // ...
  }
)
```

In the incorrect example, `Idempotency-Key` is used as the key, which results in an undefined value because Hono converts all header keys to lowercase. In the correct example, `idempotency-key` is used as the key, which allows the value of the header to be retrieved as expected.

Always use lowercase for header keys when validating headers in Hono.

- [Hono Documentation](https://hono.bike/docs/guides/validation/)

This rule is commonly used when validating headers in Hono.

**Reasoning:** This rule is important as it demonstrates the correct way to validate headers in Hono. It shows that when validating headers, the key should be in lowercase. Using a non-lowercase key will result in an undefined value, leading to unexpected behavior.

*Source: docs/guides/validation.md*

### Using Multiple Validators and Third-Party Validators in Hono

In Hono, you can use multiple validators to validate different parts of a request. This is useful when you want to ensure that all parts of the request, such as parameters, query strings, and JSON body, are valid.

Here is an example of how to use multiple validators:

```ts
app.post(
  '/posts/:id',
  validator('param', ...),
  validator('query', ...),
  validator('json', ...),
  (c) => {
    //...
  }
sh [npm]
npm i zod
ts
app.post(
  '/posts/:id',
  validator('param', ...),
  validator('query', ...),
  validator('json', ...),
  (c) => {
    //...
  }
```

- Always validate the data you receive in requests to prevent potential errors or security vulnerabilities.
- You can use any third-party validator that you prefer. Zod is just one of the many options available.

- [Hono Documentation](https://hono.bayrell.org/en/)
- [Zod Documentation](https://zod.dev)

- Validating user input in a form submission
- Checking the validity of parameters in a URL
- Ensuring the JSON body of a request is as expected

#### Code Snippet

```typescript

Hono also supports the use of third-party validators like Zod. To use Zod, you need to install it from the Npm registry:

```

**Reasoning:** This rule is important as it demonstrates how to use multiple validators in Hono to validate different parts of a request. It also shows how to integrate third-party validators like Zod into the Hono framework. This is essential for ensuring that the data being received in the request is valid and as expected, thereby preventing potential errors or security vulnerabilities.

*Source: docs/guides/validation.md*

### Installing and Using Zod for Data Validation in Hono

This guide demonstrates how to install Zod, a third-party data validation library, and use it in a Hono project.

First, install Zod from the Npm registry using your preferred package manager:

```sh
npm i zod
sh
yarn add zod
sh
pnpm add zod
sh
bun add zod
ts
import { z } from 'zod'
ts
const schema = z.object({
  body: z.string(),
})
```

You can use this schema in the callback function for validation and return the validated data.

- Zod is a powerful and flexible library for data validation, but there are many others available. Choose the one that best fits your project's needs.

- [Zod Documentation](https://github.com/colinhacks/zod)

- Validating user input in a form
- Checking the format of data received from an API

**Reasoning:** This rule is important as it demonstrates how to use a third-party validator, Zod, for data validation in Hono. It shows how to install Zod using different package managers, import it into your project, and define a schema for validation. This is a common practice in web development to ensure that the data being processed meets certain criteria, thereby preventing potential errors and security vulnerabilities.

*Source: docs/guides/validation.md*

### Using Zod for Schema Validation in Hono

This guide demonstrates how to use the Zod library for schema validation in Hono.

First, install the Zod library using your preferred package manager:

```sh
npm i zod
sh
yarn add zod
sh
pnpm add zod
sh
bun add zod
ts
import { z } from 'zod'
ts
const schema = z.object({
  body: z.string(),
})
ts
const route = app.post(
  '/posts',
  val
```

Zod is a library for creating schemas that can be used to validate JavaScript and TypeScript data. In this example, we create a schema for a post object that has a `body` property of type `string`.

- Zod is a zero-dependency library, meaning it doesn't require any other packages to work.

- [Zod Documentation](https://github.com/colinhacks/zod)

- Validating API request bodies
- Validating data before saving it to a database

#### Code Snippet

```typescript

or

```

**Reasoning:** This rule is important as it demonstrates how to use the Zod library for schema validation in Hono. Schema validation is a crucial part of any application as it ensures that the data being processed adheres to a certain structure, thus preventing potential errors or security vulnerabilities.

*Source: docs/guides/validation.md*

### Using Zod for Input Validation in Hono

This rule demonstrates how to use the zod library for input validation in Hono. Zod is a JavaScript library for building schemas and validating data.

First, you need to install zod using either pnpm or bun:

```sh
pnpm add zod
sh
bun add zod
ts
import { z } from 'zod'
ts
const schema = z.object({
  body: z.string(),
})
ts
const route = app.post(
  '/posts',
  validator('form', (value, c) => {
    const parsed = schema.safeParse(value)
    if (!parsed.success) {
      return c.text('Invalid!', 401)
    }
    return parsed.data
  })
)
```

- Zod provides a variety of methods to define complex schemas.
- The 'safeParse' method is used to validate the data. It returns an object with a 'success' property that indicates whether the validation was successful.

- [Zod documentation](https://github.com/colinhacks/zod)

- Validating user input in form submissions
- Validating API request payloads

#### Code Snippet

```typescript

or

```

**Reasoning:** This rule is important as it demonstrates how to use the zod library for input validation in Hono. It shows how to define a schema and use it to validate incoming data in a route handler. This is a common pattern in web development to ensure that the data received from the client meets certain criteria before it is processed.

*Source: docs/guides/validation.md*

### Using Zod Validator Middleware in Hono

The following code snippet shows how to use the Zod Validator Middleware in the Hono framework.

```sh
npm i @hono/zod-validator
sh
yarn add @hono/zod-validator
sh
pnpm add @hono/zod-validator
sh
bun add @hono/zod-validator
```

After installing the middleware, you can import it into your application.

This middleware simplifies the process of validating data in Hono applications. It provides a set of tools for validating data of various types and formats.

- The Zod Validator Middleware is a third-party package, and you need to install it separately.

- [Zod Validator Middleware](https://github.com/honojs/middleware/tree/main/packages/zod-validator)

- Validating form data in a Hono application.
- Validating API request data in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to use the Zod Validator Middleware in the Hono framework. The Zod Validator Middleware is a tool that simplifies the process of validating data in Hono applications. This rule shows how to install and import the middleware, which is a common pattern in Hono framework usage.

*Source: docs/guides/validation.md*

### Installing and Using zod-validator in Hono

The `@hono/zod-validator` package is used for data validation in Hono. It ensures that the data received in the request matches the expected format. This is crucial for maintaining data integrity and preventing potential errors or security vulnerabilities.

First, install the package using npm, yarn, pnpm, or bun:

```sh
npm i @hono/zod-validator
sh
yarn add @hono/zod-validator
sh
pnpm add @hono/zod-validator
sh
bun add @hono/zod-validator
ts
import { zValidator } from '@hono/zod-validator'
ts
const route = app.post(
  '/posts',
  zValidator(
    'form',
    z.object({
      body: z.string(),
    })
  ),
```

- Always validate your request data to maintain data integrity and prevent potential errors or security vulnerabilities.

- [Hono Documentation](https://hono.bayrell.org/)

- Validating request data in a POST route.

**Reasoning:** This rule is important as it demonstrates how to install and use the zod-validator package in Hono. The zod-validator is used for data validation, ensuring that the data received in the request matches the expected format. This is crucial for maintaining data integrity and preventing potential errors or security vulnerabilities.

*Source: docs/guides/validation.md*

### Installing and Using zod-validator for Data Validation in Hono

First, install the zod-validator package using either pnpm or bun:

```sh
pnpm add @hono/zod-validator
sh
bun add @hono/zod-validator
ts
import { zValidator } from '@hono/zod-validator'
ts
const route = app.post(
  '/posts',
  zValidator(
    'form',
    z.object({
      body: z.string(),
    })
  ),
  (c) => {
    const validated = c.req.valid('form')
    // ... use your validated data
  }
)
```

In this example, `zValidator('form', z.object({ body: z.string() }))` is a middleware that validates the 'form' field of the request. If the validation fails, the request is rejected. If it passes, the validated data can be accessed with `c.req.valid('form')`.

- Always validate incoming data to prevent invalid or malicious data from being processed.

- [Hono Framework Documentation](https://hono.bun.dev/)

- Validating form data in POST requests.
- Validating query parameters in GET requests.

#### Code Snippet

```typescript

or

```

**Reasoning:** This rule is important as it demonstrates how to use the zod-validator in Hono framework for data validation. It shows how to install the zod-validator, import it into your project, and use it to validate incoming data in a POST request. This is crucial for ensuring data integrity and preventing invalid or malicious data from being processed by your application.

*Source: docs/guides/validation.md*

### Registering Middleware in Hono

This code snippet demonstrates how to register middleware in Hono web framework.

```ts
// match any method, all routes
app.use(logger())

// specify path
app.use('/posts/*', cors())

// specify method and path
app.post('/posts/*', basicAuth())
```

1. `app.use(logger())`: This registers a logger middleware that will be applied to all routes and methods.

2. `app.use('/posts/*', cors())`: This registers a CORS middleware that will be applied to all routes that match the pattern '/posts/*'.

3. `app.post('/posts/*', basicAuth())`: This registers a basic authentication middleware that will be applied to all POST requests that match the pattern '/posts/*'.

- Middleware functions are executed in the order they are registered.

- Middleware can be applied to specific HTTP methods by using `app.HTTP_METHOD`.

- [Hono Documentation](https://hono.boutell.com/)

- Logging requests and responses
- Enabling CORS
- Authenticating requests

**Reasoning:** This rule is important as it demonstrates how to register middleware in Hono web framework. Middleware is a crucial part of any web application as it allows you to run code before the final request handler, perform operations on the request and response objects, end the request-response cycle, or call the next middleware function in the stack. Understanding how to register middleware is essential for building robust applications with Hono.

*Source: docs/guides/middleware.md*

### Middleware Execution Order in Hono

In Hono, middleware are processed in the order they are defined. This is demonstrated in the following code snippet:

```ts
app.use('/posts/*', cors())
app.post('/posts/*', basicAuth())
app.post('/posts', (c) => c.text('Created!', 201))
ts
logger() -> cors() -> basicAuth() -> *handler*
```

This means that the logger middleware is executed first, followed by the cors middleware, then the basicAuth middleware, and finally the handler.

When a request is made to the '/posts' path, the middleware functions cors and basicAuth are executed in the order they are defined. If the handler returns `Response`, it will be used for the end-user, and stop the processing.

- The order of middleware definition matters in Hono.
- Middleware functions can either end the request-response cycle or pass control to the next middleware function.

- [Hono Documentation](https://hono.boutique/docs/)

- Use middleware for tasks such as logging, authentication, and handling CORS.

#### Code Snippet

```typescript

In this case, four middleware are processed before dispatching like this:

```

**Reasoning:** This rule is important as it demonstrates the order of execution of middleware in the Hono framework. Middleware are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. Understanding the order of execution of middleware is crucial for managing the flow of data and control in the application.

*Source: docs/guides/middleware.md*

### Understanding Middleware Execution Order in Hono

In Hono, middleware functions are executed in the order they are defined. However, due to the use of the `await next()` statement, each middleware function can perform operations both before and after the next middleware functions are run. This results in a stack-like execution order.

Consider the following code snippet:

```text
middleware 1 start
  middleware 2 start
    middleware 3 start
      handler
    middleware 3 end
  middleware 2 end
middleware 1 end
```

In this example, 'middleware 1 start' is logged first, followed by 'middleware 2 start', and then 'middleware 3 start'. After 'handler' is logged, 'middleware 3 end' is logged, followed by 'middleware 2 end', and finally 'middleware 1 end'. This demonstrates that each middleware function can perform operations before and after the next middleware functions are run.

This pattern is useful for tasks such as logging, authentication, or any other operations that need to be performed before and/or after the main handler function.

**Reasoning:** This rule is important as it demonstrates the execution order of middleware in Hono. Middleware in Hono runs in a stack-like manner, where the first middleware function can perform operations before and after the next middleware are run. This is crucial for understanding how to structure your middleware and control the flow of execution in your application.

*Source: docs/guides/middleware.md*

### Using Built-in Middleware in Hono

This code demonstrates how to use built-in middleware in Hono.

```ts
import { Hono } from 'hono'
import { poweredBy } from 'hono/powered-by'
import { logger } from 'hono/logger'
import { basicAuth } from 'hono/basic-auth'

const app = new Hono()

app.use(poweredBy())
app.use(logger())

app.use(
  '/auth/*',
  basicAuth({
    username: 'hono',
    password: 'acoolproject',
  })
)
```

In this code, we first import the necessary modules from Hono. We then create a new Hono application. After that, we use the `app.use()` function to add the `poweredBy` and `logger` middleware to our application. Finally, we add the `basicAuth` middleware to any routes that match '/auth/*'.

It's important to note that using a different version of middleware than the Hono version can lead to bugs. Therefore, it's recommended to always use the same version of middleware as the Hono version.

- [Hono Documentation](https://hono.bryntum.com/docs)

- Adding pre-processing or post-processing functionality to your Hono application.
- Adding authentication to certain routes in your Hono application.

**Reasoning:** This rule is important as it demonstrates how to use built-in middleware in Hono. Middleware is a crucial part of many web frameworks, including Hono, as it allows for pre-processing of requests and post-processing of responses. This rule also highlights the potential issues that can arise when using different versions of middleware than the Hono version, which can lead to bugs.

*Source: docs/guides/middleware.md*

### Ensure Consistent Versioning Between Hono and Middleware

In Hono, it's possible to use a different version of middleware than the Hono version. However, this can lead to bugs and inconsistencies in your application. This rule demonstrates the correct way to import and use middleware in Hono, and the potential bugs that can occur when the versions mismatch.

```ts
import { Hono } from 'jsr:@hono/hono@4.4.0'
import { upgradeWebSocket } from 'jsr:@hono/hono@4.4.5/deno'

const app = new Hono()

app.get(
  '/ws',
  upgradeWebSocket(() => ({
    // ...
  }))
)
```

In the above code snippet, the `Hono` and `upgradeWebSocket` are imported from different versions, which can lead to bugs. Always ensure that the versions of Hono and the middleware you're using are consistent.

- Hono Documentation

- When setting up a new Hono application
- When adding new middleware to your Hono application

**Reasoning:** This rule is important because it highlights the potential issues that can arise when using different versions of middleware and the Hono version. It demonstrates the correct way to import and use middleware in Hono, and the potential bugs that can occur when the versions mismatch.

*Source: docs/guides/middleware.md*

### Creating and Using Custom Middleware in Hono

This code snippet demonstrates how to create and use custom middleware in Hono. Middleware functions are used for tasks like logging, adding headers, etc.

```ts
// Custom logger
app.use(async (c, next) => {
  console.log(`[${c.req.method}] ${c.req.url}`)
  await next()
})

// Add a custom header
app.use('/message/*', async (c, next) => {
  await next()
  c.header('x-message', 'This is middleware!')
})

app.get('/message/hello', (c) => c.text('Hello Middleware!'))
```

In this example, the first middleware function logs the request method and URL. The second middleware function adds a custom header to the response for any request that matches the path '/message/*'.

1. The `app.use()` function is used to add middleware functions to the application.
2. The `next` function is called to pass control to the next middleware function. If `next` is not called, the request-response cycle will be halted.

- Middleware functions are executed in the order they are added.
- Middleware functions can end the request-response cycle by not calling `next`, or they can pass control to the next middleware function by calling `next`.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Logging
- Adding headers
- Authentication

**Reasoning:** This rule is important as it demonstrates how to create and use custom middleware in Hono. Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. They can execute any code, make changes to the request and the response objects, end the request-response cycle, and call the next middleware function in the stack.

*Source: docs/guides/middleware.md*

### Creating a Middleware in Hono

In Hono, you can create a middleware using the 'createMiddleware' function from Hono's factory. Here is an example of a simple logging middleware:

```ts
import { createMiddleware } from 'hono/factory'

const logger = createMiddleware(async (c, next) => {
  console.log(`[${c.req.method}] ${c.req.url}`)
  await next()
})
```

In this example, the middleware logs the HTTP method and URL of each request. The 'next' function is called to pass control to the next middleware function in the stack.

The 'createMiddleware' function takes a callback function as an argument. This callback function is the actual middleware function that gets executed. It has access to the context object 'c' and a 'next' function. The context object 'c' contains the request and response objects, among other things. The 'next' function is used to pass control to the next middleware function in the stack.

- Middleware functions are called in the order they are defined.
- Don't forget to call the 'next' function to avoid hanging the request-response cycle.

- [Hono Factory](https://hono.dev/docs/api/factory)
- [Hono Context](https://hono.dev/docs/api/context)

- Logging
- Authentication
- Error handling

**Reasoning:** This rule is important as it demonstrates how to create a middleware in Hono using the 'createMiddleware' function from Hono's factory. Middleware is a crucial part of any web application as it allows the execution of code, modification of request and response objects, and ending the request-response cycle. This code snippet shows how to create a simple logging middleware that logs the HTTP method and URL of each request.

*Source: docs/guides/middleware.md*

### Creating and Modifying Middleware in Hono

In Hono, you can create middleware using the 'createMiddleware' function. This function takes a callback function as an argument, which receives the context 'c' and the 'next' function. The context 'c' contains the request and response objects, and 'next' is a function that passes control to the next middleware.

Here is an example of creating a middleware that logs the request method and URL:

```ts
const logger = createMiddleware(async (c, next) => {
  console.log(`[${c.req.method}] ${c.req.url}`)
  await next()
})
ts
createMiddleware<{Bindings: Bindings}>(async (c, next) =>
ts
const stripRes = createMiddleware(async (c, next) => {
  await next()
  // modify c.res here
})
```

- Middleware functions are executed in the order they are added.
- Always call 'next' in your middleware to avoid blocking the request-response cycle.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Logging requests
- Authenticating users
- Modifying responses

#### Code Snippet

```typescript

You can also use type generics with 'createMiddleware' to specify the type of the context:

```

**Reasoning:** This rule is important as it demonstrates how to create a middleware in Hono using the 'createMiddleware' function. It also shows how to use type generics with 'createMiddleware' and how to modify responses in middleware. Understanding this rule is crucial for developers to effectively manage HTTP requests and responses in a Hono application.

*Source: docs/guides/middleware.md*

### Modifying the Response in Middleware and Accessing Context in Hono

In Hono, middleware functions can be designed to modify responses if necessary. This is typically done after the 'next' function has been called. The 'next' function passes control to the next middleware function in the stack. After it has been called, you can modify the response object.

Here is an example of how to do this:

```ts
const stripRes = createMiddleware(async (c, next) => {
  await next()
  c.res = undefined
  c.res = new Response('New Response')
})
```

In this code snippet, the response object 'c.res' is first set to undefined, then a new Response is created with the message 'New Response'.

To access the context inside middleware arguments, you can directly use the context parameter provided by 'app.use'.

- The 'next' function should be called before modifying the response object.
- The context parameter 'c' provides access to the request and response objects, among other things.

- [Hono Middleware Documentation](https://hono.bayrell.org/docs/middleware)

- Modifying the response object based on certain conditions.
- Accessing the context to get information about the request or response.

**Reasoning:** This rule is important as it demonstrates how to modify the response after the 'next' function has been called in a middleware function. It also shows how to access the context inside middleware arguments. This is a common pattern in Hono and other web frameworks, allowing developers to manipulate the response object before it is sent back to the client.

*Source: docs/guides/middleware.md*

### Context Access and Middleware Configuration in Hono

This guide demonstrates how to access and use the context inside middleware arguments in Hono. The context parameter provided by `app.use` is used to configure middleware.

Here is the code snippet:

```ts
import { cors } from 'hono/cors'

app.use('*', async (c, next) => {
  const middleware = cors({
    origin: c.env.CORS_ORIGIN,
  })
  return middleware(c, next)
})
```

In the code snippet, the cors middleware is being configured. The context `c` is used to access the environment variable `CORS_ORIGIN` which is then passed as the `origin` option to the cors middleware.

- The context `c` is a parameter provided by `app.use` and it contains useful information about the request and response, as well as any environment variables.

- Middleware in Hono is configured by passing an options object to the middleware function. The options object can use values from the context.

- [Hono documentation](https://hono.bayrell.org/en/)

- Configuring middleware based on environment variables or other context information.
- Accessing request and response information in middleware.

**Reasoning:** This rule is important as it demonstrates how to access and use the context inside middleware arguments in Hono. It shows how to use the context parameter provided by `app.use` to configure middleware, in this case, the cors middleware. Understanding this pattern is crucial for developers to effectively use and configure middleware in their Hono applications.

*Source: docs/guides/middleware.md*

### Extending Context Inside Middleware in Hono

This guide demonstrates how to extend the context inside middleware using the 'c.set' method in Hono. It also shows how to make this type-safe by passing a `{ Variables: { yourVariable: YourVariableType } }` generic argument to the `createMiddleware` function.

```ts
import { createMiddleware } from 'hono/factory'

const echoMiddleware = createMiddleware<{
  Variables: {
    echo: (str: string) => string
  }
}>(async (c, next) => {
  c.set('echo', (str) => str)
  await next()
})

app.get('/echo', echoMiddleware, (c) => {
  return c.text(c.var.echo('Hello!'))
})
```

1. The `createMiddleware` function is imported from 'hono/factory'.
2. A middleware named 'echoMiddleware' is created. This middleware is type-safe and has a variable 'echo' that is a function taking a string and returning a string.
3. Inside the middleware, the 'echo' variable is set to a function that returns the input string.
4. The middleware is then used in a GET request handler for the '/echo' route. The 'echo' function is called with the string 'Hello!' and the result is sent as a text response.

- The 'c.set' method is used to extend the context inside middleware.
- The `{ Variables: { yourVariable: YourVariableType } }` generic argument is used to make the middleware type-safe.

- Hono Documentation: [Middleware](https://hono.bayfront.io/Reference/Middleware)

- Extending the context with custom functions or data in middleware.
- Making middleware type-safe.

**Reasoning:** This rule is important as it demonstrates how to extend the context inside middleware using the 'c.set' method in Hono. It also shows how to make this type-safe by passing a `{ Variables: { yourVariable: YourVariableType } }` generic argument to the `createMiddleware` function. This is a common pattern in Hono framework usage and is crucial for creating reusable and modular code.

*Source: docs/guides/middleware.md*

### Using Third-Party Renovate Configuration in Hono

Since the Hono team does not maintain a Renovate configuration, it's recommended to use a third-party configuration. This can be done by extending the third-party configuration in your `renovate.json` file.

Here is a code snippet demonstrating this:

```json
// renovate.json
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": [
    "github>shinGangan/renovate-config-hono" // [!code ++]
  ]
}
```

In this code snippet, the `extends` field is used to specify the third-party configuration that should be used. The value `github>shinGangan/renovate-config-hono` indicates that the configuration from the `renovate-config-hono` repository on GitHub, owned by the user `shinGangan`, should be used.

- Always ensure that the third-party configuration you are using is reliable and secure.

- [Renovate Configuration](https://docs.renovatebot.com/configuration-options/)
- [renovate-config-hono Repository](https://github.com/shinGangan/renovate-config-hono)

- Automating dependency updates in a Hono project.

**Reasoning:** This rule is important as it demonstrates how to use a third-party Renovate configuration in a Hono project. Renovate is a tool that helps to automate dependency updates, which is crucial for maintaining the security and reliability of the project. Since the Hono team does not maintain a Renovate configuration, users are advised to use a third-party configuration.

*Source: docs/guides/faq.md*

### Defining Routes and Handling Requests in Hono

This code snippet demonstrates how to define routes and handle HTTP GET and POST requests in Hono. It also shows how to send different types of responses, such as text and JSON, and how to set custom headers in the response.

```ts
app.get('/posts', (c) => {
  return c.text('Many posts')
})

app.post('/posts', (c) => {
  return c.json(
    {
      message: 'Created',
    },
    201,
    {
      'X-Custom': 'Thank you',
    }
  )
})
```

The `app.get` method is used to handle HTTP GET requests to the '/posts' path. The callback function takes a context object `c` and returns a text response 'Many posts'.

The `app.post` method is used to handle HTTP POST requests to the '/posts' path. The callback function takes a context object `c` and returns a JSON response with a status code of 201 and a custom header 'X-Custom'.

- The context object `c` provides methods for sending different types of responses and for accessing request information.
- The `c.text` method is used to send a text response.
- The `c.json` method is used to send a JSON response. It takes three arguments: the JSON object, the status code, and the headers.

- [Hono documentation](https://hono.bike/docs)

- Defining routes and handling requests in a web application.
- Sending different types of responses based on the request.

**Reasoning:** This rule is important as it demonstrates how to define routes and handle HTTP GET and POST requests in Hono. It also shows how to send different types of responses, such as text and JSON, and how to set custom headers in the response.

*Source: docs/guides/testing.md*

### Testing GET and POST Requests in Hono

This guide demonstrates how to test GET and POST requests in Hono. It shows how to make requests to specific endpoints and how to check the responses for expected status codes and content.

```ts
describe('Example', () => {
  test('GET /posts', async () => {
    const res = await app.request('/posts')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('Many posts')
  })
})
```

1. The `describe` function groups related tests.
2. The `test` function defines a test for the 'GET /posts' endpoint.
3. `app.request('/posts')` makes a GET request to the '/posts' endpoint.
4. `expect(res.status).toBe(200)` checks that the response status code is 200.
5. `expect(await res.text()).toBe('Many posts')` checks that the response text is 'Many posts'.

- Ensure that your application is running and that the '/posts' endpoint is correctly configured before running these tests.

- [Hono Documentation](https://hono.boutique/docs/)

- Use this pattern to test any GET or POST request in your Hono application.

**Reasoning:** This rule is important as it demonstrates how to test GET and POST requests in Hono. It shows how to make requests to specific endpoints and how to check the responses for expected status codes and content. This is crucial for ensuring the correct functionality of your web application.

*Source: docs/guides/testing.md*

### Making and Testing a POST Request in Hono

This code snippet demonstrates how to make a POST request using the Hono framework, and how to test the response status, headers, and JSON body.

```ts
test('POST /posts', async () => {
  const res = await app.request('/posts', {
    method: 'POST',
  })
  expect(res.status).toBe(201)
  expect(res.headers.get('X-Custom')).toBe('Thank you')
  expect(await res.json()).toEqual({
    message: 'Created',
  })
})
```

1. The `app.request` function is used to make a POST request to the '/posts' endpoint.
2. The response (`res`) is then tested for a status of 201, indicating that the resource was successfully created.
3. The response headers are checked for a custom header 'X-Custom' with a value of 'Thank you'.
4. The JSON body of the response is parsed and tested to be an object with a 'message' property of 'Created'.

- Ensure that the endpoint '/posts' is set up to handle POST requests in your application.
- The 'X-Custom' header and the JSON response body are specific to this example and may vary based on your application's requirements.

- [Hono Documentation](https://hono.bike/docs/guide/)

- Testing API endpoints in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to make a POST request using the Hono framework, and how to test the response status, headers, and JSON body. Understanding this pattern is crucial for developers to ensure their APIs are functioning as expected.

*Source: docs/guides/testing.md*

### Making a POST Request and Asserting the Response in Hono

This code snippet demonstrates how to make a POST request to the '/posts' endpoint with JSON data, and how to assert the response status, headers, and body.

```ts
test('POST /posts', async () => {
  const res = await app.request('/posts', {
    method: 'POST',
    body: JSON.stringify({ message: 'hello hono' }),
    headers: new Headers({ 'Content-Type': 'application/json' }),
  })
  expect(res.status).toBe(201)
  expect(res.headers.get('X-Custom')).toBe('Thank you')
  expect(await res.json()).toEqual({
    message: 'Created',
  })
})
```

1. The `app.request` function is used to make a request to the '/posts' endpoint with a 'POST' method.
2. The body of the request is a JSON stringified object.
3. The headers of the request include a 'Content-Type' of 'application/json'.
4. The response status is asserted to be 201, indicating that a resource was successfully created.
5. The response headers are asserted to include a custom header 'X-Custom' with a value of 'Thank you'.
6. The response body is asserted to be a JSON object with a 'message' property of 'Created'.

- Ensure that the endpoint and method used in the `app.request` function match the endpoint and method of the route being tested.
- The assertions made on the response should match the expected behavior of the endpoint.

- [Hono Documentation](https://hono.bike/)

- Testing endpoints in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to make a POST request in Hono with JSON data, and how to assert the response status, headers, and body. Understanding this pattern is crucial for testing endpoints in a Hono application.

*Source: docs/guides/testing.md*

### Making a POST request with multipart/form-data in Hono

This code snippet demonstrates how to make a POST request with multipart/form-data using the Hono framework.

```ts
test('POST /posts', async () => {
  const formData = new FormData()
  formData.append('message', 'hello')
  const res = await app.request('/posts', {
    method: 'POST',
    body: formData,
  })
  expect(res.status).toBe(201)
  expect(res.headers.get('X-Custom')).toBe('Thank you')
  expect(await res.json()).toEqual({
    message: 'Created',
  })
})
```

1. A new FormData instance is created and a 'message' field is appended to it.
2. The app.request method is used to make a POST request to the '/posts' endpoint, passing the FormData instance as the body of the request.
3. Assertions are performed on the response, checking that the status is 201 (Created), the 'X-Custom' header is 'Thank you', and the body of the response is `{ message: 'Created' }`.

- The FormData API is used to construct a set of key/value pairs representing form fields and their values.
- The app.request method returns a Promise that resolves to the Response to that request, whether it is successful or not.

- [Hono Documentation](https://hono.bevry.me/)

- Submitting forms with file uploads
- Making POST requests with complex data structures

**Reasoning:** This rule is important as it demonstrates how to make a POST request with multipart/form-data using the Hono framework. It also shows how to perform assertions on the response, checking the status, headers, and body of the response. This is a common operation in web development, especially when dealing with forms and file uploads.

*Source: docs/guides/testing.md*

### Testing POST Requests in Hono

This guide demonstrates how to create a test for a POST request in Hono.

```ts
test('POST /posts', async () => {
  const req = new Request('http://localhost/posts', {
    method: 'POST',
  })
  const res = await app.request(req)
  expect(res.status).toBe(201)
  expect(res.headers.get('X-Custom')).toBe('Thank you')
  expect(await res.json()).toEqual({
    message: 'Created',
  })
})
```

1. A new Request instance is created with the URL and method set to 'POST'.
2. The request is sent using the app.request method.
3. The response status, headers, and body are asserted using Jest's expect function.

- The URL in the Request constructor should be the URL of the endpoint you want to test.
- The method in the Request constructor should be the HTTP method that the endpoint accepts.
- The assertions should match the expected response of the endpoint.

- [Hono documentation](https://hono.boutique/docs)

- Testing HTTP endpoints in Hono.

**Reasoning:** This rule is important as it demonstrates how to create a test for a POST request in Hono. It shows how to create a new Request instance, how to send the request using the app.request method, and how to assert the response status, headers, and body. This is a common pattern in testing HTTP endpoints in Hono.

*Source: docs/guides/testing.md*

### Mocking Environment Variables for Testing in Hono

This code snippet demonstrates how to mock environment variables for testing in Hono. This is useful when you want to simulate different environments and see how your application behaves under those conditions.

```ts
const MOCK_ENV = {
  API_HOST: 'example.com',
  DB: {
    prepare: () => {
      /* mocked D1 */
    },
  },
}

test('GET /posts', async () => {
  const res = await app.request('/posts', {}, MOCK_ENV)
})
```

1. Define a `MOCK_ENV` object with the environment variables you want to mock.
2. Pass `MOCK_ENV` as the third parameter to `app.request` in your test.

- The `MOCK_ENV` object should mirror the structure of your actual environment variables.

- [Cloudflare Workers Bindings](https://hono.dev/getting-started/cloudflare-workers#bindings)

- Mocking database connections or API hosts for testing.

**Reasoning:** This rule is important as it demonstrates how to mock environment variables for testing in Hono. It allows developers to simulate different environments and test how their application behaves under those conditions. This is particularly useful when testing components that interact with external services or databases.

*Source: docs/guides/testing.md*

### Creating a Simple Counter Component in Hono

This guide demonstrates how to create a simple counter component using the Hono framework. The counter increments when the button is clicked.

Here is the code snippet:

```tsx
import { useState } from 'hono/jsx'
import { render } from 'hono/jsx/dom'

function Counter() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  )
}

function App() {
  return (
    <html>
      <body>
        <Counter />
      </body>
    </html>
  )
}

const root = document.getElementById('root')
render(<App />, root)
```

1. The `useState` hook is used to manage the state of the counter.
2. The `render` function is used to insert the `App` component within the HTML element with id 'root'.

- Hono's hooks are compatible with React, so if you're familiar with React, you can easily transition to Hono.

- [Hono Documentation](https://hono.dev/docs)

- Creating interactive components in web applications using Hono.

**Reasoning:** This rule is important as it demonstrates how to create a simple counter component using the Hono framework. It shows how to use the useState hook for state management and the render function to insert JSX components within a specified HTML element. Understanding this rule is crucial for developers to create interactive web applications using Hono.

*Source: docs/guides/jsx-dom.md*

### Rendering JSX Components in Hono

In Hono, you can use the `render()` function to insert JSX components within a specified HTML element. This is a fundamental aspect of displaying your components on the webpage.

Here is a code snippet demonstrating this:

```tsx
render(<Component />, container)
```

In this code snippet, `<Component />` is the JSX component you want to render, and `container` is the HTML element where you want to insert your component.

It's important to note that the `render()` function is part of the hono/jsx/dom library, which provides hooks that are compatible or partially compatible with React. You can learn more about these APIs in the [React documentation](https://react.de).

Common use cases for this function include rendering the main app component into the root HTML element of your webpage.

**Reasoning:** This rule is important as it demonstrates how to use the `render()` function in Hono to insert JSX components within a specified HTML element. Understanding this rule is crucial for developers to properly display their JSX components on the webpage.

*Source: docs/guides/jsx-dom.md*

### Using startViewTransition, useState, and css in Hono

The following code demonstrates how to use the `startViewTransition` function in Hono to create a transition effect when changing the state of a component. It also shows how to use the `useState` hook to manage component state and how to apply CSS styles using the `css` function from Hono.

```tsx
import { useState, startViewTransition } from 'hono/jsx'
import { css, Style } from 'hono/css'

export default function App() {
  const [showLargeImage, setShowLargeImage] = useState(false)
  return (
    <>
      <Style />
      <button
        onClick={() =>
          startViewTransition(() =>
            setShowLargeImage((state) => !state)
          )
        }
      >
        Click!
      </button>
      <div>
        {!showLargeImage ? (
          <img src='https://hono.dev/images/logo.png' />
        ) : (
          <div
            class={css`
              background: url('https://hono.dev/images/logo-large.png');
              background-size: contain;
              background-repeat: no-repeat;
              background-position: center;
              width: 600px;
              height: 600px;
            `}
          ></div>
        )}
      </div>
    </>
  )
}
```

The `startViewTransition` function is used to create a transition effect when the state of the `showLargeImage` variable is changed. The `useState` hook is used to manage the state of the `showLargeImage` variable. The `css` function is used to apply CSS styles to the div element.

- The `startViewTransition` function should be used inside an event handler, such as `onClick`.
- The `useState` hook should be used at the top of your function component.
- The `css` function can be used to apply inline styles to your JSX elements.

- [Hono Documentation](https://hono.dev/docs)

- Creating transition effects when changing component state
- Managing component state with the `useState` hook
- Applying CSS styles with the `css` function

**Reasoning:** This rule is important as it demonstrates how to use the `startViewTransition` function in Hono to create a transition effect when changing the state of a component. It also shows how to use the `useState` hook to manage component state and how to apply CSS styles using the `css` function from Hono.

*Source: docs/guides/jsx-dom.md*

### Using View Transitions in Hono

This guide demonstrates how to use view transitions in Hono. The `viewTransition` function is used to create a unique transition name and apply it to a CSS class. The `startViewTransition` function is used to start a view transition when a button is clicked.

```tsx
import { useState, startViewTransition } from 'hono/jsx'
import { viewTransition } from 'hono/jsx/dom/css'
import { css, keyframes, Style } from 'hono/css'

const rotate = keyframes`
  from {
    rotate: 0deg;
  }
  to {
    rotate: 360deg;
  }
`

export default function App() {
  const [showLargeImage, setShowLargeImage] = useState(false)
  const [transitionNameClass] = useState(() =>
    viewTransition(css`
      ::view-transition-old() {
        animation-name: ${rotate};
      }
      ::view-transition-new() {
        animation-name: ${rotate};
      }
    `)
  )
  return (
    <>
      <Style />
      <button
        onClick={() =>
          startViewTransition(() =>
            setShowLargeImage((state) => !state)
          )
        }
      >
        Click!
      </button>
      <div>
        {!showLargeImage ? (
          <img src='https://hono.dev/images/logo.png' />
        ) : (
          <div
            class={css`
              ${transitionNameClass}
              background: url('https://hono.dev/images/logo-large.png');
              background-size: contain;
              background-repeat: no-repeat;
              background-position: center;
              width: 600px;
              height: 600px;
            `}
          ></div>
        )}
      </div>
    </>
  )
}
```

1. The `viewTransition` function is used to create a unique transition name and apply it to a CSS class.
2. The `startViewTransition` function is used to start a view transition when a button is clicked.

- The `viewTransition` function returns a unique transition name that can be used in CSS.
- The `startViewTransition` function starts a view transition.

- [Hono Documentation](https://hono.dev/docs)

- Creating unique transitions for different views in a web application.

**Reasoning:** This rule is important as it demonstrates how to use view transitions in Hono. It shows how to use the `viewTransition` function to create a unique transition name and apply it to a CSS class. It also demonstrates how to use the `startViewTransition` function to start a view transition when a button is clicked.

*Source: docs/guides/jsx-dom.md*

### Using `useViewTransition` and `viewTransition` for Animated Transitions in Hono

This code snippet demonstrates how to use Hono's `useViewTransition` and `viewTransition` functions to create a view transition with a rotation animation. It also shows how to use the `useState` function to manage state within a component, and how to conditionally render components based on state.

```tsx
import { useState, useViewTransition } from 'hono/jsx'
import { viewTransition } from 'hono/jsx/dom/css'
import { css, keyframes, Style } from 'hono/css'

const rotate = keyframes`
  from {
    rotate: 0deg;
  }
  to {
    rotate: 360deg;
  }
`

export default function App() {
  const [isUpdating, startViewTransition] = useViewTransition()
  const [showLargeImage, setShowLargeImage] = useState(false)
  const [transitionNameClass] = useState(() =>
    viewTransition(css`
      ::view-transition-old() {
        animation-name: ${rotate};
      }
      ::view-transition-new() {
        animation-name: ${rotate};
      }
    `)
  )
  return (
    <>
      <Style />
      <button
        onClick={() =>
          startViewTransition(() =>
            setShowLargeImage((state) => !state)
          )
        }
      >
        Click!
      </button>
      <div>
        {!showLargeImage ? (
          <img src='https://hono.dev/images/logo.png' />
        ) : (
          <div
            class={css`
              ${transitionNameClass}
              background: url('https://hono.dev/images/logo-large.png');
              background-size: contain;
              background-repeat: no-repeat;
              background-position: center;
              width: 600px;
              height: 600px;
              position: relative;
              ${isUpdating &&
              css`
                &:before {
                  content: 'Loading...';
                  position: absolute;
                  top: 50%;
                  left: 50%;
                }
              `}
            `}
          ></div>
        )}
      </div>
    </>
  )
}
```

1. The `useViewTransition` function is used to create a view transition. The `startViewTransition` function is called when the button is clicked, triggering a state change that toggles the `showLargeImage` state.
2. The `viewTransition` function is used to define the transition animation. The `rotate` keyframes are used for the animation.
3. The `useState` function is used to manage the `showLargeImage` state. This state determines whether the large image or the small image is displayed.

- The `useViewTransition` and `viewTransition` functions are part of Hono's JSX Runtime for Client Components. Using this will result in smaller bundled results than using `hono/jsx`.

- [Hono Documentation](https://hono.dev)

- Creating animated transitions between views in a single-page application.

**Reasoning:** This rule is important as it demonstrates how to use Hono's `useViewTransition` and `viewTransition` functions to create a view transition with a rotation animation. It also shows how to use the `useState` function to manage state within a component, and how to conditionally render components based on state.

*Source: docs/guides/jsx-dom.md*

### Configuring JSX Runtime for Client Components in Hono

This guide demonstrates how to configure the JSX runtime for client components in Hono framework. Using this configuration will result in smaller bundled results than using `hono/jsx`.

```json
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx/dom"
  }
}
```

This configuration tells the compiler to use 'react-jsx' for JSX and to import JSX from 'hono/jsx/dom'.

- This configuration should be specified in 'tsconfig.json'.
- For Deno, modify the deno.json.

- [Hono Documentation](https://hono.io/docs)

- When you want to optimize the bundle size of your Hono application.
- When you are building client components in Hono.

**Reasoning:** This rule is important as it demonstrates how to configure the JSX runtime for client components in Hono framework. It shows how to specify 'hono/jsx/dom' in 'tsconfig.json' for smaller bundled results. It also provides an alternative way to specify 'hono/jsx/dom' in the esbuild transform options in 'vite.config.ts'.

*Source: docs/guides/jsx-dom.md*

### Specifying JSX Import Source in Vite Configuration for Hono

When using the Hono framework with Vite, you can specify the JSX import source in the Vite configuration file. This is necessary for correctly compiling JSX syntax in a Hono project.

Here is a code snippet demonstrating this:

```ts
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    jsxImportSource: 'hono/jsx/dom',
  },
})
```

In this code snippet, we import the `defineConfig` function from Vite and use it to export a configuration object. Inside this object, we specify the `jsxImportSource` option under the `esbuild` property. This tells Vite to use 'hono/jsx/dom' as the source for JSX imports.

- Make sure to install the necessary dependencies for using JSX with Hono and Vite.

- [Vite Configuration Guide](https://vitejs.dev/config/)

- Use this configuration when you want to use JSX syntax in a Hono project that is built with Vite.

**Reasoning:** This rule is important as it demonstrates how to specify the JSX import source in the Vite configuration file when using the Hono framework. This is crucial for correctly compiling JSX syntax in a Hono project.

*Source: docs/guides/jsx-dom.md*

### Configuring TypeScript Compiler for JSX in Hono

This code demonstrates how to configure the TypeScript compiler to use JSX syntax in a Hono project.

```json
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx"
  }
}
```

In the `tsconfig.json` file, we set the 'jsx' compiler option to 'react-jsx' and 'jsxImportSource' to 'hono/jsx'. This instructs the TypeScript compiler to transform JSX syntax into JavaScript that can be understood by the Hono framework.

- This configuration is necessary if you are using JSX syntax in your Hono project.
- If you are using Deno, you should modify the `deno.json` instead of the `tsconfig.json`.

- [TypeScript Handbook: JSX](https://www.typescriptlang.org/docs/handbook/jsx.html)

- Developing a Hono project that uses JSX syntax for UI description.

**Reasoning:** This rule is important as it demonstrates how to configure the TypeScript compiler to use JSX syntax in a Hono project. JSX is a syntax extension for JavaScript, primarily used with React to describe what the UI should look like. By setting the 'jsx' compiler option to 'react-jsx' and 'jsxImportSource' to 'hono/jsx', we instruct the TypeScript compiler to transform JSX syntax into JavaScript that can be understood by the Hono framework.

*Source: docs/guides/jsx.md*

### Configuring JSX for Hono

When using JSX with the Hono framework, you need to modify the `tsconfig.json` or `deno.json` file to specify the JSX syntax and import source.

For TypeScript, the `tsconfig.json` should look like this:

```json
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx"
  }
}
ts
/** @jsx jsx */
/** @jsxImportSource hono/jsx */
json
{
  "compilerOptions": {
    "jsx": "precompile",
    "jsxImportSource": "hono/jsx"
  }
}
```

The `jsx` option in the compiler options specifies the JSX factory function to use when targeting react JSX emit. The `jsxImportSource` option specifies the module specifier to use when importing the JSX factory functions when targeting react JSX emit.

- Make sure to use the correct file (`tsconfig.json` for TypeScript, `deno.json` for Deno) and correct options (`react-jsx` for TypeScript, `precompile` for Deno).

- [TypeScript Compiler Options](https://www.typescriptlang.org/tsconfig#jsx)
- [Deno Compiler Options](https://deno.land/manual/getting_started/typescript#compiler-options)

- Using JSX syntax in a Hono project

#### Code Snippet

```typescript

Alternatively, you can use pragma directives at the top of your TypeScript file:

```

**Reasoning:** This rule is important as it demonstrates how to configure the TypeScript or Deno compiler to use JSX syntax with the Hono framework. JSX is a syntax extension for JavaScript, often used with React, that allows for writing HTML-like code in your JavaScript code. Hono also supports JSX, but it needs to be enabled in the compiler options.

*Source: docs/guides/jsx.md*

### Configuring JSX Compiler Options in Hono

This code snippet demonstrates how to configure the compiler options for JSX in Hono.

```json
{
  "compilerOptions": {
    "jsx": "precompile",
    "jsxImportSource": "hono/jsx"
  }
}
```

In the `compilerOptions` object, `jsx` is set to `precompile` which means the TypeScript compiler will convert JSX syntax to JavaScript. The `jsxImportSource` is set to `hono/jsx`, which specifies the module to import JSX functions from.

- This configuration is necessary to use JSX syntax in Hono.
- For Deno, you have to modify the `deno.json` instead of the `tsconfig.json`.

- [Hono JSX Documentation](https://hono.io/docs/jsx)

- When you want to use JSX syntax in your Hono project, you need to configure the compiler options as shown.

**Reasoning:** This rule is important as it demonstrates how to configure the compiler options for JSX in Hono. It shows how to set the JSX processing mode and specify the module to import JSX functions from, which is crucial for using JSX syntax in Hono.

*Source: docs/guides/jsx.md*

### Creating a Basic Hono Application with JSX

This code snippet demonstrates how to create a basic Hono application using JSX syntax.

```tsx
import { Hono } from 'hono'
import type { FC } from 'hono/jsx'

const app = new Hono()

const Layout: FC = (props) => {
  return (
    <html>
      <body>{props.children}</body>
    </html>
  )
}

const Top: FC<{ messages: string[] }> = (props: {
  messages: string[]
}) => {
  return (
    <Layout>
      <h1>Hello Hono!</h1>
      <ul>
        {props.messages.map((message) => {
          return <li>{message}!!</li>
        })}
      </ul>
    </Layout>
  )
}

app.get('/', (c) => {
  const messages = ['Good Morning', 'Good Evening', 'Good Night']
  return c.html(<Top messages={messages} />)
})

export default app
```

1. We first import the necessary modules from Hono and define a new Hono application.
2. We then define two functional components, `Layout` and `Top`, using the `FC` (Functional Component) type from Hono's JSX module.
3. The `Layout` component takes in `props` and returns an HTML structure with `{props.children}` as the body content.
4. The `Top` component takes in `props` with a `messages` array and returns the `Layout` component with a list of messages.
5. In the Hono route handler for the root path (`/`), we return the `Top` component with a `messages` array as the HTML response.

- The `FC` type is used to define functional components in Hono with TypeScript.
- The `props` argument in functional components is used to pass data to the components.

- [Hono Documentation](https://hono.bun.js.org/)

- Creating dynamic HTML responses in Hono routes using JSX syntax.

**Reasoning:** This rule is important as it demonstrates how to create a basic Hono application with JSX syntax. It shows how to define functional components, how to pass props to components, and how to use these components to render HTML responses in Hono routes.

*Source: docs/guides/jsx.md*

### Using Fragments to Group Multiple Elements in Hono

In Hono, you can use Fragments to group multiple elements without adding extra nodes to the DOM. This is useful for maintaining a clean and efficient DOM structure.

Here is an example of how to use Fragments:

```tsx
import { Fragment } from 'hono/jsx'

const List = () => (
  <Fragment>
    <p>first child</p>
    <p>second child</p>
    <p>third child</p>
  </Fragment>
)
tsx
const List = () => (
  <>
    <p>first child</p>
    <p>second child</p>
    <p>third child</p>
  </>
)
```

- Fragments are a way to return multiple elements from a component without adding extra nodes to the DOM.
- The alternative syntax for Fragments (`<></>`) can be used if it is set up properly.

- [Hono Documentation](https://hono.dev/docs)

- When you need to return multiple elements from a component but don't want to add extra nodes to the DOM.

#### Code Snippet

```typescript

Alternatively, you can use a more concise syntax for Fragments if it is set up properly:

```

**Reasoning:** This rule is important as it demonstrates how to group multiple elements in Hono without adding extra nodes to the DOM. This is crucial for maintaining a clean and efficient DOM structure. It also shows an alternative syntax for Fragments, which can be useful for developers who prefer a more concise syntax.

*Source: docs/guides/jsx.md*

### Using Fragments and PropsWithChildren in Hono

In Hono, you can use Fragments to group a list of children without adding extra nodes to the DOM. This can be done using the `<Fragment>` tag or the shorthand `<>` if it is set up properly.

```tsx
const List = () => (
  <>
    <p>first child</p>
    <p>second child</p>
    <p>third child</p>
  </>
)
tsx
import { PropsWithChildren } from 'hono/jsx'

type Post = {
  id: number
}
```

- Always use `PropsWithChildren` when you need to infer a child element in a function component for type safety.
- Use Fragments when you need to return multiple elements from a component.

- [Hono Documentation](https://hono.io/docs)

- Grouping multiple elements in a component without adding extra nodes to the DOM.
- Inferring child elements in a function component for type safety and reusability.

#### Code Snippet

```typescript

In addition, Hono provides `PropsWithChildren` to correctly infer a child element in a function component. This is crucial for type safety and component reusability.

```

**Reasoning:** This rule is important as it demonstrates how to use Fragments and PropsWithChildren in Hono. Fragments let you group a list of children without adding extra nodes to the DOM. PropsWithChildren is used to correctly infer a child element in a function component, which is crucial for type safety and component reusability.

*Source: docs/guides/jsx.md*

### Using PropsWithChildren in Hono

In Hono, you can use `PropsWithChildren` to correctly infer a child element in a function component. This is particularly useful when you want to create a component that accepts children elements.

Here is an example:

```tsx
import { PropsWithChildren } from 'hono/jsx'

type Post = {
  id: number
  title: string
}

function Component({ title, children }: PropsWithChildren<Post>) {
  return (
    <div>
      <h1>{title}</h1>
      {children}
    </div>
  )
}
```

In this code snippet:

1. We import `PropsWithChildren` from 'hono/jsx'.
2. We define a type 'Post' with properties 'id' and 'title'.
3. We create a function component 'Component' that takes 'title' and 'children' as props. The type of the props is 'PropsWithChildren<Post>'.
4. In the return statement of the function, we render a 'div' element with a 'h1' element and the 'children' elements.

- 'PropsWithChildren' is a utility type provided by Hono. It takes a type and adds a 'children' property to it.
- The 'children' property can be any valid JSX element or an array of JSX elements.

- [Hono Documentation](https://hono.io/docs/jsx)

- Creating a wrapper component that accepts children elements.
- Creating a layout component that accepts children elements.

**Reasoning:** This rule is important as it demonstrates how to use 'PropsWithChildren' in Hono to correctly infer a child element in a function component. This is a common pattern in Hono when you want to create a component that accepts children elements.

*Source: docs/guides/jsx.md*

### Inserting Raw HTML in Hono

In Hono, you can directly insert HTML into a component using the `dangerouslySetInnerHTML` property. This is a powerful feature but should be used with caution due to potential security risks associated with inserting raw HTML.

Here is a code snippet demonstrating this:

```tsx
app.get('/foo', (c) => {
  const inner = { __html: 'JSX &middot; SSR' }
  const Div = <div dangerouslySetInnerHTML={inner} />
})
```

In this example, a raw HTML string 'JSX &middot; SSR' is inserted into a div component. The HTML string is wrapped in an object with a `__html` key, which is then passed to the `dangerouslySetInnerHTML` property.

- Always sanitize any user-supplied input to prevent Cross-Site Scripting (XSS) attacks.
- Avoid using `dangerouslySetInnerHTML` if possible. It is much safer to use JSX to compose your components.

- [Hono Documentation](https://hono.dev/docs)

- Displaying server-rendered HTML content
- Inserting third-party content that requires HTML formatting

**Reasoning:** This rule is important as it demonstrates how to insert raw HTML directly into a component using the 'dangerouslySetInnerHTML' property in Hono. This is a powerful feature but should be used with caution due to potential security risks associated with inserting raw HTML.

*Source: docs/guides/jsx.md*

### Optimizing Hono Components with Memoization

In Hono, you can optimize your components by memoizing computed strings using `memo`. This practice can significantly improve the performance of your application by avoiding unnecessary re-rendering of components.

Here is an example of how to use `memo` in Hono:

```tsx
import { memo } from 'hono/jsx'

const Header = memo(() => <header>Welcome to Hono</header>)
const Footer = memo(() => <footer>Powered by Hono</footer>)
const Layout = (
  <div>
    <Header />
    <p>Hono is cool!</p>
    <Footer />
  </div>
)
```

In this example, the `Header` and `Footer` components are wrapped with `memo`, which means that these components will only re-render if their props change. This can be particularly useful in cases where your components are expensive to render.

- Be careful when using `memo` as it can lead to unexpected behavior if not used correctly. Make sure that you only use it on components that are expensive to render and that you test your application thoroughly.

- [Hono Documentation](https://hono.dev/docs)

- Use `memo` to optimize components that are expensive to render.
- Use `memo` to prevent unnecessary re-renders when the props of your components do not change.

**Reasoning:** This rule is important as it demonstrates how to optimize Hono components by memoizing computed strings using `memo`. This practice can significantly improve the performance of your application by avoiding unnecessary re-rendering of components.

*Source: docs/guides/jsx.md*

### Using useContext to Share Data Globally in Hono

This code snippet demonstrates how to use the useContext hook in Hono to share data globally across any level of the Component tree without passing values through props.

```tsx
import type { FC } from 'hono/jsx'
import { createContext, useContext } from 'hono/jsx'

const themes = {
  light: {
    color: '#000000',
    background: '#eeeeee',
  },
  dark: {
    color: '#ffffff',
    background: '#222222',
  },
}

const ThemeContext = createContext(themes.light)

const Button: FC = () => {
  const theme = useContext(ThemeContext)
  return <button style={theme}>Push!</button>
}

const Toolbar: FC = () => {
  return (
    <div>
      <Button />
    </div>
  )
}

// ...

app.get('/', (c) => {
  return c.html(
    <div>
      <ThemeContext.Provider value={themes.dark}>
        <Toolbar />
      </ThemeContext.Provider>
    </div>
  )
})
```

1. A context is created using `createContext` and a default value is provided.
2. The `useContext` hook is used within a component to access the current value of the context.
3. The context provider is used to set a new value for the context within a certain part of the component tree.

- The useContext hook can only be used within a function component.
- The value provided to the context provider will be used by all descendants of the provider that use the useContext hook.

- [Hono documentation](https://hono.dev/docs)

- Sharing theme information across an application
- Sharing user data or other global state

**Reasoning:** This rule is important as it demonstrates how to use the useContext hook in Hono to share data globally across any level of the Component tree without passing values through props. This is a common pattern in Hono and other similar frameworks, and understanding it can greatly simplify the process of passing data around in a complex application.

*Source: docs/guides/jsx.md*

### Creating and Using Asynchronous Components in Hono

In Hono, you can create asynchronous components using the `async`/`await` syntax. When you render it with `c.html()`, it will await automatically. This allows for non-blocking operations, improving the performance and user experience of the application.

Here is a code snippet demonstrating this:

```tsx
const AsyncComponent = async () => {
  await new Promise((r) => setTimeout(r, 1000)) // sleep 1s
  return <div>Done!</div>
}

app.get('/', (c) => {
  return c.html(
    <html>
      <body>
        <AsyncComponent />
      </body>
    </html>
  )
})
```

In this code snippet, `AsyncComponent` is an asynchronous component that waits for 1 second before returning a div with the text 'Done!'. When this component is rendered using `c.html()`, it will automatically wait for the promise to resolve before rendering.

- Asynchronous components in Hono are useful for operations that may take some time, such as fetching data from an API.
- Be careful when using asynchronous components as they can lead to unexpected behavior if not handled properly. Always make sure to handle potential errors and consider what should be displayed while the component is loading.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Fetching data from an API before rendering a component.
- Performing calculations or other operations that may take some time before rendering a component.

**Reasoning:** This rule is important as it demonstrates how to create and use asynchronous components in Hono. Asynchronous components allow for non-blocking operations, improving the performance and user experience of the application.

*Source: docs/guides/jsx.md*

### Using Suspense with renderToReadableStream in Hono

This code snippet demonstrates how to use Suspense with renderToReadableStream in Hono. Suspense allows you to specify a fallback UI to display while a component is loading, and renderToReadableStream allows you to render your JSX to a Node.js readable stream.

```tsx
import { renderToReadableStream, Suspense } from 'hono/jsx/streaming'

//...

app.get('/', (c) => {
  const stream = renderToReadableStream(
    <html>
      <body>
        <Suspense fallback={<div>loading...</div>}>
          <Component />
        </Suspense>
      </body>
    </html>
  )
  return c.body(stream, {
    headers: {
      'Content-Type': 'text/html; charset=UTF-8',
      'Transfer-Encoding': 'chunked',
    },
  })
})
```

1. The `renderToReadableStream` function is used to render the JSX to a Node.js readable stream.
2. The `Suspense` component is used to specify a fallback UI to display while the `Component` is loading.
3. The `c.body` function is used to set the response body to the stream and the response headers.

- The 'Content-Type' header is set to 'text/html; charset=UTF-8' to indicate that the response is an HTML document.
- The 'Transfer-Encoding' header is set to 'chunked' to indicate that the response body will be sent in chunks.

- [Hono documentation](https://hono.dev/docs/guides/jsx)

- Providing a fallback UI while a component is loading.
- Rendering JSX to a Node.js readable stream.

**Reasoning:** This rule is important as it demonstrates how to use Suspense with renderToReadableStream in Hono to handle asynchronous operations and provide a fallback UI while the component is loading. It also shows how to set the response headers for the stream.

*Source: docs/guides/jsx.md*

### Error Handling in Hono using ErrorBoundary

In Hono, you can catch errors in child components using `ErrorBoundary`. This is useful to provide a fallback UI in case of an error, ensuring a better user experience and application stability.

Here is an example of how to use it:

```tsx
function SyncComponent() {
  throw new Error('Error')
  return <div>Hello</div>
}

app.get('/sync', async (c) => {
  return c.html(
    <html>
      <body>
        <ErrorBoundary fallback={<div>Out of Service</div>}>
          <SyncComponent />
        </ErrorBoundary>
      </body>
    </html>
  )
})
```

In this example, if an error occurs in `SyncComponent`, the `ErrorBoundary` will catch it and display the fallback UI (`<div>Out of Service</div>`).

Important notes:
- `ErrorBoundary` can also be used with async components and `Suspense`.
- The fallback UI can be any React component.

Common use cases include providing a user-friendly error message or a retry button when an error occurs in a component.

**Reasoning:** This rule is important as it demonstrates how to handle errors in child components using the ErrorBoundary component in Hono. It shows how to provide a fallback UI in case of an error, ensuring a better user experience and application stability.

*Source: docs/guides/jsx.md*

### Handling Errors and Loading States in Asynchronous Components with Hono

In Hono, you can handle errors and loading states in asynchronous components using the ErrorBoundary and Suspense components. The ErrorBoundary component catches JavaScript errors anywhere in their child component tree, logs those errors, and displays a fallback UI. The Suspense component lets you specify a loading state while some suspended component is waiting to render.

Here's an example of how you can use these components:

```tsx
async function AsyncComponent() {
  await new Promise((resolve) => setTimeout(resolve, 2000))
  throw new Error('Error')
  return <div>Hello</div>
}

app.get('/with-suspense', async (c) => {
  return c.html(
    <html>
      <body>
        <ErrorBoundary fallback={<div>Out of Service</div>}>
          <Suspense fallback={<div>Loading...</div>}>
            <AsyncComponent />
          </Suspense>
        </ErrorBoundary>
      </body>
    </html>
  )
})
```

In this example, if an error is thrown in the AsyncComponent, the ErrorBoundary will catch it and display 'Out of Service'. If the AsyncComponent is still loading, the Suspense component will display 'Loading...'.

- Error boundaries do not catch errors for:
  - Event handlers
  - Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)
  - Server side rendering
  - Errors thrown in the error boundary itself (rather than its children)

- [React Error Boundaries](https://reactjs.org/docs/error-boundaries.html)
- [React Suspense](https://reactjs.org/docs/concurrent-mode-suspense.html)

- When you want to handle errors in a component and provide a fallback UI
- When you want to display a loading state while a component is being loaded

**Reasoning:** This rule is important as it demonstrates how to handle errors and loading states in asynchronous components using Hono's JSX and html middlewares. It shows how to use the ErrorBoundary and Suspense components to provide fallback UI when an error occurs or while the component is loading respectively.

*Source: docs/guides/jsx.md*

### Integration of JSX and html middlewares in Hono

This rule demonstrates how to integrate JSX and html middlewares in Hono for powerful templating.

Here is the code snippet:

```tsx
import { Hono } from 'hono'
import { html } from 'hono/html'

const app = new Hono()

interface SiteData {
  title: string
  children?: any
}

const Layout = (props: SiteData) =>
  html`<!doctype html>
    <html>
      <head>
        <title>${props.title}</title>
      </head>
      <body>
        ${props.children}
      </body>
    </html>`

const Content = (props: { siteData: SiteData; name: string }) => (
  <Layout {...props.siteData}>
    <h1>Hello {props.name}</h1>
  </Layout>
)

app.get('/:name', (c) => {
  const { name } = c.req.param()
  const props = {
    name: name,
    siteData: {
      title: 'JSX with html sample',
    },
  }
  return c.html(<Content {...props} />)
})

export default app
```

1. The `SiteData` interface is defined to structure the site data.
2. The `Layout` component is created using the `html` middleware and the `SiteData` interface.
3. The `Content` component is created using the `Layout` component and additional props.
4. In the route handler, the `Content` component is used to return HTML content.

- The `html` middleware is used to create HTML templates in Hono.
- JSX is used to create components in Hono.

- [Hono html middleware documentation](/docs/helpers/html)
- [Hono JSX Renderer Middleware documentation](/docs/middleware/builtin/jsx-renderer)

- Creating HTML pages in Hono using JSX and html middlewares.
- Structuring site data using interfaces in TypeScript.

**Reasoning:** This rule is important as it demonstrates how to integrate JSX and html middlewares in Hono for powerful templating. It shows how to define interfaces for site data, create layout and content components using these interfaces, and use these components in a route handler to return HTML content.

*Source: docs/guides/jsx.md*

### Overriding JSX Type Definitions in Hono

In Hono, you can override the JSX type definitions to include your own custom elements and attributes. This is useful when you want to use your own custom elements in your JSX code.

Here is an example of how to do this:

```ts
declare module 'hono/jsx' {
  namespace JSX {
    interface IntrinsicElements {
      'my-custom-element': HTMLAttributes & {
        'x-event'?: 'click' | 'scroll'
      }
    }
  }
}
```

In this code snippet, a new custom element called 'my-custom-element' is added to the JSX type definitions. This custom element has an attribute 'x-event' which can take the values 'click' or 'scroll'.

The 'declare module' statement is used to extend the module 'hono/jsx'. Inside this, a new namespace 'JSX' is declared. Inside this namespace, the 'IntrinsicElements' interface is extended to include the new custom element and its attributes.

- The custom element name should be a string.
- The custom attribute names should be strings and their possible values should be specified.

- [Hono Documentation](https://hono.beyondco.de/docs/guides/jsx)

- When you want to use your own custom elements in your JSX code.
- When you want to add new attributes to existing elements.

**Reasoning:** This rule is important as it demonstrates how to extend the JSX type definitions in Hono to include custom elements and attributes. This is useful when you want to add your own custom elements and their attributes to the JSX type definitions, which allows you to use them in your JSX code.

*Source: docs/guides/jsx.md*

## Concepts

### Configuring the Default Router in Hono

In Hono, you can configure the default router using the SmartRouter. The SmartRouter is a special type of router that selects the best router from the registered routers based on routing speed.

Here is a code snippet demonstrating this:

```ts
// Inside the core of Hono.
readonly defaultRouter: Router = new SmartRouter({
  routers: [new RegExpRouter(), new TrieRouter()],
})
```

In this code snippet, the default router is set to a new instance of SmartRouter. The SmartRouter is initialized with an array of routers - RegExpRouter and TrieRouter.

When the application starts, the SmartRouter selects the fastest router from the registered routers and continues to use it for routing.

- The SmartRouter automatically selects the fastest router based on routing speed. This helps in optimizing the performance of your Hono application.

- [Hono Documentation](https://hono.bosch.io/docs/)

- Use this configuration when you want to optimize the performance of your Hono application by automatically selecting the fastest router.

**Reasoning:** This rule is important as it demonstrates how to configure the default router in Hono using the SmartRouter. The SmartRouter is a special type of router that selects the best router from the registered routers based on routing speed. This configuration is crucial for optimizing the performance of your Hono application.

*Source: docs/concepts/routers.md*

### Performance Comparison of Hono Routers

This code snippet demonstrates a performance comparison of different routers in Hono. The routers compared are LinearRouter, MedleyRouter, FindMyWay, KoaTreeRouter, and TrekRouter.

```console
• GET /user/lookup/username/hey
----------------------------------------------------- -----------------------------
LinearRouter     1.82 µs/iter      (1.7 µs … 2.04 µs)   1.84 µs   2.04 µs   2.04 µs
MedleyRouter     4.44 µs/iter     (4.34 µs … 4.54 µs)   4.48 µs   4.54 µs   4.54 µs
FindMyWay       60.36 µs/iter      (45.5 µs … 1.9 ms)  59.88 µs  78.13 µs  82.92 µs
KoaTreeRouter    3.81 µs/iter     (3.73 µs … 3.87 µs)   3.84 µs   3.87 µs   3.87 µs
TrekRouter       5.84 µs/iter     (5.75 µs … 6.04 µs)   5.86 µs   6.04 µs   6.04 µs

summary for GET /user/lookup/username/hey
  LinearRouter
   2.1x faster than KoaTreeRouter
   2.45x faster than MedleyRouter
   3.21x faster than TrekRouter
   33.24x faster than FindMyWay
```

The benchmarking results show the time taken for each iteration by the different routers. The LinearRouter is the fastest, followed by KoaTreeRouter, MedleyRouter, TrekRouter, and FindMyWay.

For situations like Fastly Compute, it's better to use LinearRouter with the `hono/quick` preset as it provides the best performance.

- Hono Documentation

- When performance is a key factor in your application, consider using the LinearRouter.

**Reasoning:** This rule is important as it demonstrates the performance comparison of different routers in Hono. It shows that the LinearRouter is significantly faster than other routers, which can be crucial for applications where performance is a key factor.

*Source: docs/concepts/routers.md*

### Deploying a Minified Hono Application Using PatternRouter

This code snippet demonstrates how to deploy a minified version of a Hono application using the PatternRouter. The PatternRouter is a feature of Hono that allows for a smaller application size, which can be beneficial in environments with limited resources.

```console
$ npx wrangler deploy --minify ./src/index.ts
 ⛅️ wrangler 3.20.0
-------------------
Total Upload: 14.68 KiB / gzip: 5.38 KiB
```

The `npx wrangler deploy --minify ./src/index.ts` command deploys a minified version of the application located at `./src/index.ts`. The `--minify` flag instructs wrangler to minify the application, reducing its size.

- The size of the minified application is displayed after the deployment process. In this case, the total upload size is 14.68 KiB.

- [Hono PatternRouter Documentation](https://hono.bouzuya.net/)

- Deploying a Hono application in an environment with limited resources.

**Reasoning:** This rule is important as it demonstrates how to deploy a minified version of a Hono application using the PatternRouter. Minifying the application can be crucial in environments with limited resources, as it reduces the size of the application.

*Source: docs/concepts/routers.md*

### Defining Routes in Hono

This code snippet demonstrates how to define routes in Hono. Each route is an object with a `method` and a `path` property. The `method` property specifies the HTTP method (e.g., GET, POST, PUT, DELETE), and the `path` property specifies the URL path for the route.

```ts
interface Route {
  method: string
  path: string
}
// ---cut---
const routes: (Route & { name: string })[] = [
  {
    name: 'short static',
    method: 'GET',
    path: '/user',
  },
```

When a request is made to the application, Hono matches the request's method and URL with the defined routes. If a match is found, the request is directed to the corresponding handler.

- Routes are matched in the order they are defined. Therefore, if two routes could match the same URL, the first one defined will be used.

- The `*` character in a path (e.g., '/static/*') is a wildcard that matches any sequence of characters.

- [Hono Documentation](https://hono.bosch.io/docs/)

- Defining routes for different functionalities in a web application.
- Setting up a RESTful API with different endpoints.

**Reasoning:** This rule is important as it demonstrates how to define routes in Hono. It shows the standard way of defining HTTP methods and paths for different endpoints in an application. Understanding this rule is crucial for setting up the application's routing system, which is responsible for directing incoming requests to the appropriate handlers.

*Source: docs/concepts/benchmarks.md*

### Performance Comparison of Hono with Other Routers for Cloudflare Workers

This code demonstrates the performance comparison of Hono with other routers for Cloudflare Workers. The results are presented in the form of screenshots.

```text
Let's see the results.

The following screenshots show the results on Node.js.

![bench](/images/bench01.png)

![bench](/images/bench02.png)

![bench](/images/bench03.png)

![bench](/images/bench04.png)

![bench](/images/bench05.png)

![bench](/images/bench06.png)

![bench](/images/bench07.png)

![bench](/images/bench08.png)

The following screenshots show the results on Bun.

![bench](/images/bench09.png)

![bench](/images/bench10.png)

![bench](/images/bench11.png)

![bench](/images/bench12.png)

![bench](/images/bench13.png)

![bench](/images/bench14.png)

![bench](/images/bench15.png)

![bench](/images/bench16.png)

**Hono is the fastest**, compared to other routers for Cloudflare Workers.

- Machine: Apple MacBook Pro, 32 GiB, M1 Pro
- Scripts: [benchmarks/handle-event](https://github.com/honojs/hono/tree/main/benchmarks/handle-event)
```

The performance of different routers is tested on different platforms (Node.js, Bun, and Cloudflare Workers). The results are then compared to determine the fastest router.

- Performance can greatly impact the efficiency and user experience of applications.
- Developers should consider the performance of routers when choosing one for their applications.

- [Hono GitHub](https://github.com/honojs/hono/tree/main/benchmarks/handle-event)

- Choosing a router for Cloudflare Workers.
- Comparing the performance of different routers.

**Reasoning:** This rule is important as it demonstrates the performance comparison of Hono with other routers for Cloudflare Workers. It shows that Hono is the fastest among the compared routers. This information is crucial for developers when choosing a router for their Cloudflare Workers, as performance can greatly impact the efficiency and user experience of their applications.

*Source: docs/concepts/benchmarks.md*

### Creating a GET Endpoint and Validating Query Parameters in Hono

This code snippet demonstrates how to create a GET endpoint in Hono that returns a JSON response. It also shows how to validate query parameters using Zod.

```ts
import { Hono } from 'hono'

const app = new Hono()

app.get('/hello', (c) => {
  return c.json({
    message: `Hello!`,
  })
})
ts
import { zValidator } from '@hono/zod-validator'
import { z } from 'zod'

app.get(
  '/hello',
  zValidator(
    'query',
    z.object({
      name: z.string(),
    })
  ),
  (c) => {
    const { name } = c.query
    // ... rest of the code
  }
)
```

This works by defining a schema for the query parameters using Zod and then using the `zValidator` middleware from Hono to validate the query parameters against this schema.

- Always validate the input data to prevent security vulnerabilities and ensure the integrity of the data.

- [Hono Documentation](https://hono.bayfront.cloud/)
- [Zod Documentation](https://github.com/colinhacks/zod)

- Creating API endpoints that return JSON responses.
- Validating query parameters in API requests.

#### Code Snippet

```typescript

To validate the query parameters, you can use Zod. Here's how you can do it:

```

**Reasoning:** This rule is important as it demonstrates how to create a GET endpoint in Hono that returns a JSON response. It also shows how to validate query parameters using Zod, which is crucial for ensuring the integrity and security of the data received in the request.

*Source: docs/concepts/stacks.md*

### Defining and Validating Query Parameters in Hono

In Hono, you can define and validate query parameters using zod. This is done using the `zValidator` function, which takes two arguments: the type of the parameter ('query' in this case) and a zod schema defining the expected format of the parameter. The validated parameters can then be extracted using the `valid` method on the request object.

Here is an example:

```ts
app.get(
  '/hello',
  zValidator(
    'query',
    z.object({
      name: z.string(),
    })
  ),
  (c) => {
    const { name } = c.req.valid('query')
    return c.json({
      message: `Hello! ${name}`,
    })
  }
)
```

In this example, the 'name' query parameter is expected to be a string. If the incoming request does not meet this expectation, Hono will automatically respond with an error.

This approach is beneficial because it ensures that the incoming requests meet the expected format and prevents potential errors due to invalid data.

**Reasoning:** This rule is important as it demonstrates how to define and validate query parameters in Hono using zod. It also shows how to extract the validated parameters and use them in the route handler. This is crucial for ensuring that the incoming requests meet the expected format and for preventing potential errors due to invalid data.

*Source: docs/concepts/stacks.md*

### Creating a Client Object in Hono

This code snippet demonstrates how to create a client object in Hono by passing the `AppType` type to `hc` as generics. This enables the endpoint path and request type to be suggested, improving code completion and reducing the likelihood of errors.

```ts
import { AppType } from './server'
import { hc } from 'hono/client'

const client = hc<AppType>('/api')
const res = await client.hello.$get({
  query: {
    name: 'Hono',
  },
})
```

1. Import the `AppType` from the server file and `hc` from 'hono/client'.
2. Create a client object by passing the `AppType` type to `hc` as generics.
3. The endpoint path and request type are suggested, improving code completion.

- The `AppType` type should be defined in the server file and should match the structure of the server.

- Hono documentation: https://hono.bayrell.org/

- Creating a client object in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to create a client object in Hono by passing the `AppType` type to `hc` as generics. This enables the endpoint path and request type to be suggested, improving code completion and reducing the likelihood of errors.

*Source: docs/concepts/stacks.md*

### Using Hono Client for GET Requests and Response Parsing

This code snippet demonstrates how to use the Hono client to make a GET request to a server and retrieve data. It also shows how to parse the response using the json() method.

```ts
import { AppType } from './server'
import { hc } from 'hono/client'

const client = hc<AppType>('/api')
const res = await client.hello.$get({
  query: {
    name: 'Hono',
  },
})

const data = await res.json()
console.log(`${data.message}`)
```

1. The Hono client is imported and initialized with the API endpoint.
2. A GET request is made to the 'hello' endpoint with a query parameter.
3. The response is parsed using the json() method, which is compatible with the fetch API.

- The json() method returns a Promise that resolves with the result of parsing the body text as JSON.

- [Hono Client Documentation](https://hono.bayrell.org/en/latest/docs/client/)

- Retrieving data from a server using a GET request.
- Parsing the response data to JSON.

**Reasoning:** This rule is important as it demonstrates how to use the Hono client to make a GET request to a server and retrieve data. It also shows how to parse the response using the json() method, which is compatible with the fetch API. This is crucial for developers to understand as it forms the basis of how data is retrieved from servers using Hono.

*Source: docs/concepts/stacks.md*

### Using Hono with React on Cloudflare Pages

This code snippet demonstrates how to use Hono with React on Cloudflare Pages. It also shows how to handle server-side changes.

```ts
// functions/api/[[route]].ts
import { Hono } from 'hono'
import { handle } from 'hono/cloudflare-pages'
import { z } from 'zod'
import { zValidator } from '@hono/zod-validator'

const app = new Ho
```

1. Import the necessary modules from Hono, zod, and hono/zod-validator.
2. Initialize a new Hono application.

- Hono is compatible with the fetch API, but the data that can be retrieved with `json()` has a type.
- Sharing API specifications allows you to be aware of server-side changes.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Creating applications on Cloudflare Pages using React.
- Handling server-side changes in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to use Hono with React on Cloudflare Pages. It shows how to create applications and handle server-side changes. Understanding this rule is crucial for developers to effectively use Hono in a React environment and handle API responses.

*Source: docs/concepts/stacks.md*

### Defining Routes and Handling Requests in Hono and Using React Query for Data Fetching

This code snippet demonstrates how to define routes and handle requests in Hono, and how to use React Query for data fetching in a React application.

```tsx
return c.json({
  message: 'created!',
})
})
.get((c) => {
  return c.json({
    todos,
  })
})

export type AppType = typeof route

export const onRequest = handle(app, '/api')
```

In the Hono part, `.get` and `.post` methods are used to define GET and POST routes respectively. The `c.json` method is used to send a JSON response.

In the React part, `useQuery` and `useMutation` hooks from React Query are used for data fetching and mutations respectively.

When a GET or POST request is made to the '/api' endpoint, the corresponding function is executed and a JSON response is sent.

In the React application, `useQuery` and `useMutation` hooks are used to fetch data and perform mutations respectively.

- Make sure to correctly define the type of the route using `typeof`.
- Use the `handle` function to handle requests to a specific route.

- [Hono Documentation](https://hono.bayfront.cloud/)
- [React Query Documentation](https://react-query.tanstack.com/)

- Building RESTful APIs with Hono
- Fetching data in a React application using React Query

**Reasoning:** This rule is important as it demonstrates how to define routes and handle requests in Hono, a web framework. It also shows how to use React Query for data fetching in a React application. Understanding this rule is crucial for building scalable and maintainable web applications with Hono and React.

*Source: docs/concepts/stacks.md*

## Api

### Handling Multiple Methods, Paths and Path Parameters in Hono

In Hono, you can define routes that respond to multiple methods or paths. This is useful when you want to perform the same action for different HTTP methods or paths.

```ts
// Multiple Method
app.on(['PUT', 'DELETE'], '/post', (c) =>
  c.text('PUT or DELETE /post')
)

// Multiple Paths
app.on('GET', ['/hello', '/ja/hello', '/en/hello'], (c) =>
  c.text('Hello')
)
ts
// Path Parameter
app.get('/user/:name', async (c) => {
  const name = c.req.param('name')
  // ...
})
```

In the above example, `:name` is a path parameter. You can access its value using `c.req.param('name')`.

- When defining multiple methods or paths, make sure they are in an array.
- Path parameters are prefixed with a colon (`:`) and can be accessed using `c.req.param()`.

- [Hono Documentation](https://hono.boutell.com/)

- Creating CRUD (Create, Read, Update, Delete) operations where the same route is used with different HTTP methods.
- Creating localized routes (e.g., `/en/hello`, `/ja/hello`).
- Capturing user IDs or other data from the URL.

#### Code Snippet

```typescript

Additionally, Hono allows you to define path parameters. These are dynamic parts of the URL that can be captured and used in your route handler.

```

**Reasoning:** This rule is important as it demonstrates how to handle multiple methods and paths, and how to extract path parameters in Hono. Understanding this rule allows developers to create more flexible and dynamic routes in their web applications.

*Source: docs/api/routing.md*

### Using Path Parameters in Hono

In Hono, you can define path parameters in your routes. These parameters can then be accessed in your route handlers.

Here's an example of a route with a single path parameter:

```ts
import { Hono } from 'hono'
const app = new Hono()
app.get('/user/:name', async (c) => {
  const name = c.req.param('name')
})
ts
import { Hono } from 'hono'
const app = new Hono()
app.get('/posts/:id/comment/:comment_id', async (c) => {
  const { id, comment_id } = c.req.param()
})
```

In both examples, the parameters are defined in the route using the `:` prefix. They can then be accessed in the route handler using the `param` method on the request object (`c.req`).

- Path parameters are a powerful tool for creating dynamic routes, but they should be used judiciously to avoid creating overly complex routes.
- Always validate path parameters to ensure they are of the expected format and type.

- [Hono Documentation](https://hono.bevry.me/)

- Retrieving a specific resource by its ID
- Navigating nested resources (e.g., comments on a post)

#### Code Snippet

```typescript

And here's an example of a route with multiple path parameters:

```

**Reasoning:** This rule is important as it demonstrates how to use path parameters in Hono. Path parameters are a crucial part of building RESTful APIs, allowing developers to create more dynamic routes. Understanding how to extract these parameters from the request is key to handling different types of requests and responses.

*Source: docs/api/routing.md*

### Defining Routes with Dynamic and Optional Parameters in Hono

In Hono, you can define routes with dynamic parameters and optional parameters. Dynamic parameters are defined by prefixing the parameter name with a colon `:`. Optional parameters are defined by appending a question mark `?` to the parameter name.

Here is an example of a route with dynamic parameters:

```ts
import { Hono } from 'hono'
const app = new Hono()
app.get('/posts/:id/comment/:comment_id', async (c) => {
  const { id, comment_id } = c.req.param()
  // ...
})
ts
import { Hono } from 'hono'
const app = new Hono()
app.get('/api/animal/:type?', (c) => c.text('Animal!'))
```

In this example, `:type?` is an optional parameter. The route will match both `/api/animal` and `/api/animal/:type`.

- Dynamic and optional parameters can be accessed via the `req.param()` method in the route handler.
- Optional parameters make the route more flexible, but can also make it more ambiguous. Use them judiciously.

- [Hono Documentation](https://hono.beyondnlp.com/)

- Creating RESTful APIs with dynamic resource identifiers.
- Creating routes that can handle different levels of specificity.

#### Code Snippet

```typescript

In this example, `:id` and `:comment_id` are dynamic parameters. The actual values for these parameters are provided in the URL when the route is accessed.

Here is an example of a route with an optional parameter:

```

**Reasoning:** This rule is important because it demonstrates how to define routes with optional and dynamic parameters in Hono. Understanding this rule allows developers to create flexible and dynamic routes in their web applications.

*Source: docs/api/routing.md*

### Defining Dynamic Routes in Hono

In Hono, you can define dynamic routes with parameters and regular expressions. This allows you to create more flexible and powerful routing patterns.

Here are some examples:

```ts
import { Hono } from 'hono'
const app = new Hono()

// Define a route with parameters and regular expressions
app.get('/post/:date{[0-9]+}/:title{[a-z]+}', async (c) => {
  const { date, title } = c.req.param()
  // ...
})

// Define a route that includes slashes
app.get('/posts/:filename{.+\.png}', async (c) => {
  //...
})
```

In the first example, the route includes two parameters, `date` and `title`, which are constrained by regular expressions. The `date` parameter must be a number, and the `title` parameter must be a lowercase string.

In the second example, the route includes a parameter `filename` that can include slashes, as indicated by the regular expression `.+\.png`.

To extract the parameters from the request, you can use `c.req.param()`.

- The regular expressions in the route definitions are used to validate the parameters. If a parameter does not match the regular expression, the route will not match.

- [Hono Documentation](https://hono.bryntum.com/docs)

- Creating blog post URLs that include the post date and title
- Serving static files with dynamic paths

**Reasoning:** This rule is important as it demonstrates how to define dynamic routes with parameters and regular expressions in Hono. It shows how to extract parameters from the request and how to define routes that include slashes or are chained.

*Source: docs/api/routing.md*

### Defining Routes with Chained Methods and Including Slashes in Hono

In Hono, you can chain methods to define routes for different HTTP methods on the same endpoint. You can also include slashes in the route parameters.

Here's an example:

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/posts/:filename{.+\.png}', async (c) => {
  //...
})
ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app
  .get('/endpoint', (c) => {
    return c.text('GET /endpoint')
  })
  .post((c) => {
    return c.text('POST /endpoint')
  })
```

In the above code, `app.get('/endpoint', (c) => {...})` and `app.post((c) => {...})` define GET and POST routes for the same endpoint.

- The `{.+\.png}` in the route parameter is a regular expression that matches any string that includes a `.png` extension.
- The `c` parameter in the route handler function is the context object, which provides methods and properties related to the HTTP request and response.

- [Hono API Documentation](https://hono.beyondco.de/docs/routing)

- Defining routes for different HTTP methods on the same endpoint.
- Including slashes in route parameters when necessary.

#### Code Snippet

```typescript

In the above code, `app.get('/posts/:filename{.+\.png}', async (c) => {...})` defines a GET route where the `:filename` parameter can include slashes.

Here's another example:

```

**Reasoning:** This rule is important as it demonstrates how to define routes in Hono framework using chained methods and how to include slashes in the route parameters. It also shows how to handle different HTTP methods for the same endpoint.

*Source: docs/api/routing.md*

### Grouping Routes in Hono

In Hono, you can group the routes with the Hono instance and add them to the main app with the route method. This helps in organizing your routes in a clean and maintainable way.

Here is a code snippet demonstrating this:

```ts
import { Hono } from 'hono'

const book = new Hono()

book.get('/', (c) => c.text('List Books')) // GET /book
book.get('/:id', (c) => {
  // GET /book/:id
  const id = c.req.pa
```

In this snippet, we are creating a new Hono instance and grouping the routes for 'book'. We then add these routes to the main app using the route method.

1. Import the Hono module.
2. Create a new Hono instance.
3. Define your routes using the get method on the Hono instance.
4. Add these routes to the main app using the route method.

- Grouping routes helps in maintaining a clean codebase and improves readability.

- [Hono Documentation](https://hono.bespokejs.com)

- When you have multiple routes related to a specific resource (like 'book' in this case), you can group them using a Hono instance.

**Reasoning:** This rule is important as it demonstrates how to group routes using the Hono instance and add them to the main application using the route method. This is a common practice in web development to organize routes in a clean and maintainable way.

*Source: docs/api/routing.md*

### Grouping Routes Without Changing Base in Hono

This code demonstrates how to group multiple instances in Hono without changing the base. It shows how to define different HTTP methods (GET and POST) for the same route ('/book') and how to use the 'route' method to add these routes to the Hono application.

```ts
import { Hono } from 'hono'

const book = new Hono()
book.get('/book', (c) => c.text('List Books'))
book.post('/book', (c) => c.text('Create Book'))

const app = new Hono()
app.route('/book', book)
```

1. A new Hono instance 'book' is created.
2. The 'get' and 'post' methods are used to define GET and POST routes for '/book'.
3. A new Hono application 'app' is created.
4. The 'route' method is used to add the 'book' routes to the 'app'.

- The 'route' method is used to add a group of routes to a Hono application.
- The base of the routes remains unchanged when they are added to the application.

- [Hono Documentation](https://hono.boutell.com/)

- Grouping related routes in a Hono application.
- Defining different HTTP methods for the same route.

**Reasoning:** This rule is important as it demonstrates how to group multiple instances in Hono without changing the base. It shows how to define different HTTP methods (GET and POST) for the same route ('/book') and how to use the 'route' method to add these routes to the Hono application. Understanding this pattern is crucial for organizing routes in a Hono application.

*Source: docs/api/routing.md*

### Defining Routes and Base Paths in Hono

In Hono, you can define routes and specify the base path for all routes. This is crucial for handling different HTTP methods for different routes and serving responses.

Here is a code snippet demonstrating this:

```ts
import { Hono } from 'hono'

const user = new Hono()
user.get('/', (c) => c.text('List Users')) // GET /user
user.post('/', (c) => c.text('Create User')) // POST /user

const app = new Hono()
app.route('/', book) // Handle /book
app.route('/', user) // Handle /user

const api = new Hono().basePath('/api')
api.get('/book', (c) => c.text('List Books')) // GET /api/book
```

In this snippet:

- `user.get('/', (c) => c.text('List Users'))` defines a GET route at `/user` that responds with 'List Users'.
- `user.post('/', (c) => c.text('Create User'))` defines a POST route at `/user` that responds with 'Create User'.
- `app.route('/', book)` and `app.route('/', user)` attach the `book` and `user` routes to the main `app`.
- `const api = new Hono().basePath('/api')` sets the base path for all routes to `/api`.

- The base path is prefixed to all routes. So, `api.get('/book', (c) => c.text('List Books'))` will handle GET requests at `/api/book`.

- [Hono Documentation](https://hono.bike/)

- Building APIs with different routes and methods.
- Grouping routes under a common base path.

**Reasoning:** This rule is important as it demonstrates how to define routes and specify base paths in Hono. It shows how to handle different HTTP methods (GET, POST) for different routes and how to set a base path for all routes. Understanding this is crucial for building applications with Hono as it forms the basis of how requests are handled and responses are served.

*Source: docs/api/routing.md*

### Defining Base Path and Routing with Hostname in Hono

This code demonstrates how to define the base path and routing with hostname in Hono.

```ts twoslash
import { Hono } from 'hono'
// ---cut---
const api = new Hono().basePath('/api')
api.get('/book', (c) => c.text('List Books')) // GET /api/book
ts twoslash
import { Hono } from 'hono'
// ---cut---
const app = new Hono({
  getPath: (req) => req.url.replace(/^https?:\/\/([^?]+).*$/, '$1'),
})

app.get('/www1.example.com/hello', (c) => c.text('hello'))
```

In the above code, the getPath option is used to customize the path extraction from the request. The get method is then used to define a route '/www1.example.com/hello' which responds with 'hello' when accessed.

- The basePath method sets the base path for all routes.
- The get method is used to define a route.
- The getPath option can be used to customize the path extraction from the request.

- [Hono Documentation](https://hono.bike/)

- Defining a base path for all routes in an application.
- Defining routes in an application.
- Customizing path extraction from the request.

#### Code Snippet

```typescript

In the above code, the basePath method is used to set '/api' as the base path for all routes. The get method is then used to define a route '/book' which responds with 'List Books' when accessed.

```

**Reasoning:** This rule is important as it demonstrates how to define the base path and routing with hostname in Hono. It shows how to use the basePath method to set a base path for all routes and how to use the get method to define a route. It also shows how to use the getPath option to customize the path extraction from the request.

*Source: docs/api/routing.md*

### Handling the 'host' Header Value in Hono

In Hono, you can handle the `host` header value by setting the `getPath()` function in the Hono constructor. This allows for dynamic routing based on the host header value.

Here is an example:

```ts
import { Hono } from 'hono'

const app = new Hono({
  getPath: (req) =>
    '/' +
    req.headers.get('host') +
    req.url.replace(/^https?:\/\/[^/]+(\/[^?]*).*/, '$1'),
})
```

In this example, the `getPath()` function is used to construct a path that includes the host header value and the original URL path. This can be useful in multi-tenant applications or when serving different content based on the domain.

- The `getPath()` function is called for every request, so it should be as efficient as possible.

- [Hono documentation](https://hono.bike/)

- Multi-tenant applications
- Serving different content based on the domain

**Reasoning:** This rule is important as it demonstrates how to handle the 'host' header value in Hono by setting the 'getPath()' function in the Hono constructor. This allows for dynamic routing based on the host header value, which can be useful in multi-tenant applications or when serving different content based on the domain.

*Source: docs/api/routing.md*

### Understanding Routing and Routing Priority in Hono

In Hono, routes are matched in the order they are registered. This means that if a request matches multiple routes, the first one registered will be used.

Here's an example:

```ts
import { Hono } from 'hono'
const app = new Hono()
app.get('/book/a', (c) => c.text('a'))
app.get('/book/:slug', (c) => c.text('common'))
```

In this example, a GET request to '/book/a' will match the first route and return 'a', even though it could also match the second route.

This behavior is important to keep in mind when designing your application's routing. If you have overlapping routes, make sure to register the more specific ones first.

Also, you can change the routing by `User-Agent` header which can be useful for serving different content or layouts to different types of devices or browsers.

**Reasoning:** This rule is important as it demonstrates how routing works in Hono and how the order of registration affects the routing priority. It shows that the first matching route is selected, and subsequent routes are ignored. This is crucial for developers to understand to avoid unexpected behavior in their applications.

*Source: docs/api/routing.md*

### Understanding Hono Routing and Handler Execution Order

This code snippet demonstrates the routing mechanism in Hono and the importance of the order of route handlers.

```ts
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/book/a', (c) => c.text('a')) // a
app.get('/book/:slug', (c) => c.text('common')) // common
ts
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('*', (c) => c.text('common')) // common
app.get('/foo', (c) => c.text('foo')) // foo
```

In this example, regardless of the specific route, the response will be `common` because the wildcard handler is executed first.

Hono executes the handlers in the order they are defined. Once a handler is executed, the process will be stopped, and no further handlers will be executed.

The order of defining route handlers in Hono is crucial. If a wildcard handler is defined before a specific route handler, the specific route handler will never be executed.

- [Hono Documentation](https://hono.boutell.com/)

- Defining specific route handlers before wildcard handlers to handle specific routes differently.
- Using wildcard handlers to provide a default response for unspecified routes.

#### Code Snippet

```typescript

In this example, if a GET request is made to `/book/a`, the response will be `a`. If a GET request is made to `/book/b`, the response will be `common`.

```

**Reasoning:** This rule is important as it demonstrates the routing mechanism in Hono and how the order of route handlers matters. It shows that once a handler is executed, the process will be stopped, and no further handlers will be executed. This is crucial to understand to avoid unexpected behavior in the application.

*Source: docs/api/routing.md*

### Order of Middleware and Route Handlers in Hono

In Hono, the order in which middleware and route handlers are declared matters, as they will be executed in that order.

Here is an example:

```ts
import { Hono } from 'hono'
import { logger } from 'hono/logger'
const app = new Hono()
// ---cut---
app.use(logger())
app.get('/foo', (c) => c.text('foo'))
```

In this example, the `logger()` middleware is declared before the route handler for '/foo'. This means that the logger middleware will be executed before the route handler whenever a GET request is made to '/foo'.

When a request is made to the Hono application, it goes through the middleware and route handlers in the order they were declared. If a middleware does not call the `next()` function, the request-response cycle will end there and the following middleware or route handlers will not be executed.

- Always declare middleware that you want to execute before route handlers above the route handlers.

- [Hono Middleware](https://hono.bevry.me/docs/middleware)

- Logging requests before they reach the route handlers.
- Authenticating requests before they reach the route handlers.

**Reasoning:** This rule is important as it demonstrates the order of middleware and route handlers in Hono. Middleware functions are functions that have access to the request object, the response object, and the next function in the application’s request-response cycle. The next function is a function in the Hono application, when invoked, executes the middleware succeeding the current middleware. Middleware functions can perform the following tasks: execute any code, make changes to the request and the response objects, end the request-response cycle, call the next middleware in the stack. If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging. The order in which middleware and route handlers are declared matters, as they will be executed in that order.

*Source: docs/api/routing.md*

### Setting Up a Fallback Route in Hono

In Hono, you can create a fallback route that will be used when no other routes match the incoming request. This is done by defining a route with a wildcard '*' as the path.

Here is an example:

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/bar', (c) => c.text('bar')) // bar
app.get('*', (c) => c.text('fallback')) // fallback
```

In this example, if a GET request is made to '/bar', the response will be 'bar'. If a GET request is made to any other path, the response will be 'fallback'.

When a request is made, Hono will try to match the request's path with the paths of the routes that have been defined. It starts from the top and goes down. If it finds a match, it will use that route. If it doesn't find a match, it will use the fallback route.

- The order of the routes is important. The fallback route should be defined last.

- [Hono documentation](https://hono.bevry.me/)

- Displaying a 404 page when the requested route does not exist.

**Reasoning:** This rule is important as it demonstrates how to set up a fallback route in Hono. A fallback route is a route that will be used when no other routes match the incoming request. This is useful for handling unknown routes or displaying a 404 page.

*Source: docs/api/routing.md*

### Correct Grouping and Ordering of Routes in Hono

This code snippet demonstrates the correct way to group and order routes in Hono.

```ts
three.get('/hi', (c) => c.text('hi'))
two.route('/three', three)
app.route('/two', two)

export default app
```

In this example, the `route()` function takes the stored routing from the second argument (such as `three` or `two`) and adds it to its own (`two` or `app`) routing. This results in the following route: `GET /two/three/hi ---> 'hi'`.

It's important to note that mistakes in grouping or ordering of routes can be hard to notice but can lead to unexpected behavior or errors. Therefore, it's crucial to pay attention to the order in which routes are defined and grouped.

- [Hono Documentation](https://hono.boutell.com/)

- Defining nested routes in a web application
- Grouping related routes under a common path

**Reasoning:** This rule is important as it demonstrates the correct ordering and grouping of routes in Hono. It shows how the `route()` function works by taking the stored routing from the second argument and adding it to its own routing. This is crucial for the correct functioning of the application, as incorrect ordering or grouping of routes can lead to unexpected behavior or errors.

*Source: docs/api/routing.md*

### Correct Order of Nested Routes in Hono

This code snippet demonstrates the correct order of defining nested routes in Hono.

```ts
three.get('/hi', (c) => c.text('hi'))
two.route('/three', three)
app.route('/two', two)

export default app
```

In this example, the route '/two/three/hi' will return a 200 response with the text 'hi'. However, if the routes are defined in the wrong order, it will return a 404 error.

In Hono, routes are defined using the `.route()` method. This method takes a path as its first argument and a Hono instance as its second. The second Hono instance will handle any requests that match the given path.

- The order in which routes are defined matters. If routes are not properly nested, it can lead to 404 errors.

- [Hono Documentation](https://hono.boutell.com/)

- Defining nested routes in a Hono application.

**Reasoning:** This rule is important as it demonstrates how routing works in Hono. It shows that the order in which routes are defined matters and can affect the response of the application. If routes are not properly nested, it can lead to 404 errors.

*Source: docs/api/routing.md*

### Importance of Route Definition Order in Hono

In Hono, the order in which routes are defined is crucial. The order of route definition determines the order in which the routes are matched and handled. If routes are defined in the wrong order, it could lead to unexpected 404 errors.

Here is an example:

```ts
three.get('/hi', (c) => c.text('hi'))
two.route('/three', three)
app.route('/two', two)

export default app
ts
three.get('/hi', (c) => c.text('hi'))
app.route('/two', two) // `two` does not have '/three' route defined yet
```

When a request is made, Hono matches the routes in the order they were defined. If a matching route is found, the corresponding handler is invoked. If no matching route is found, a 404 error is returned.

- Always define routes in the order they should be matched.
- Be careful when defining nested routes. The parent route should be defined before the child route.

- [Hono Documentation](https://hono.boutell.com/)

- Defining nested routes
- Handling 404 errors

#### Code Snippet

```typescript

In this example, the route '/two/three/hi' will return a 200 response. However, if the routes are defined in the wrong order, it will return a 404.

```

**Reasoning:** This rule is important because it demonstrates the significance of the order in which routes are defined in Hono. The order of route definition determines the order in which the routes are matched and handled. If routes are defined in the wrong order, it could lead to unexpected 404 errors.

*Source: docs/api/routing.md*

### Handling HTTP Requests and Sending Responses in Hono

This code snippet demonstrates how to handle HTTP GET requests and send responses using Hono. It shows how to extract headers from the request, and how to send a text response.

```ts
import { Hono } from 'hono'
const app = new Hono()
app.get('/hello', (c) => {
  const userAgent = c.req.header('User-Agent')
  return c.text(`Hello, ${userAgent}`)
})
```

In this example, a GET request is made to the '/hello' endpoint. The `c.req.header('User-Agent')` is used to extract the 'User-Agent' header from the request. The `c.text()` method is then used to send a text response to the client.

When returning Text or HTML, it is recommended to use `c.text()` or `c.html()`. You can also set headers with `c.header()` and set HTTP status code with `c.status`. This can also be set in `c.text()`, `c.json()` and so on.

**Reasoning:** This rule is important as it demonstrates how to handle HTTP requests and send responses using Hono. It shows how to extract headers from the request, and how to send a text response. Understanding this is crucial for building web applications with Hono.

*Source: docs/api/context.md*

### Setting HTTP Headers, Status Code, and Response Body in Hono

This code snippet demonstrates how to set HTTP headers, status code, and response body in Hono.

```ts
import { Hono } from 'hono'
const app = new Hono()

app.get('/welcome', (c) => {
  c.header('X-Message', 'Hello!')
  c.header('Content-Type', 'text/plain')

  // Set HTTP status code
  c.status(201)

  // Return the response body
  return c.body('Thank you for coming')
})
ts
app.get('/welcome', (c) => {
  return c.body('Thank you for coming', 201, {
    'X-Message': 'Hello!',
    'Content-Type': 'text/plain'
  })
})
```

In Hono, you can use the `header` method of the context object `c` to set HTTP headers. The `status` method is used to set the HTTP status code. The `body` method is used to set the response body.

- The `header` method takes two arguments: the name of the header and its value.
- The `status` method takes one argument: the HTTP status code.
- The `body` method can take up to three arguments: the response body, the status code, and an object containing headers.

- [Hono Documentation](https://hono.boutell.com/)

- Sending custom headers in the HTTP response.
- Setting a specific HTTP status code.
- Returning a response body.

#### Code Snippet

```typescript

Alternatively, you can also set the status code and headers while returning the response body as follows:

```

**Reasoning:** This rule is important as it demonstrates how to set HTTP headers, status code, and response body in Hono. Understanding this is crucial for creating HTTP responses in a Hono application.

*Source: docs/api/context.md*

### Defining a GET Route and Returning Custom Response in Hono

This code snippet demonstrates how to define a GET route in Hono and how to return a custom response with a specific status code and headers.

```javascript
const { Hono } = require('hono')
const app = new Hono()

app.get('/welcome', (c) => {
  return c.body('Thank you for coming', 201, {
    'X-Message': 'Hello!',
    'Content-Type': 'text/plain',
  })
})
```

In this example, a GET route '/welcome' is defined. When this route is hit, it returns a response with the body 'Thank you for coming', a status code of 201, and custom headers 'X-Message' and 'Content-Type'.

This shows the flexibility of Hono in handling HTTP responses, which is crucial for building web applications.

- The `c.body()` function is used to set the response body, status code, and headers.
- The status code and headers are optional. If not provided, Hono will use default values.

- [Hono Documentation](https://hono.boutell.com/)

- Returning custom responses in web applications.
- Setting custom headers for responses.

**Reasoning:** This rule is important as it demonstrates how to define a GET route in Hono and how to return a custom response with a specific status code and headers. It shows the flexibility of Hono in handling HTTP responses, which is crucial for building web applications.

*Source: docs/api/context.md*

### Handling Different Types of Responses in Hono

This code demonstrates how to handle different types of responses in Hono.

You can send a custom response by creating a new instance of the `Response` class and passing in the response message, status, and headers.

```ts
ew Response('Thank you for coming', {
  status: 201,
  headers: {
    'X-Message': 'Hello!',
    'Content-Type': 'text/plain',
  },
})
ts
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/say', (c) => {
  return c.text('Hello!')
})
ts
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/json', (c) => {
  return c.json({ message: 'Hello!' })
})
```

These methods are part of Hono's context object, which is passed to every route handler. They provide a convenient way to send different types of responses to the client.

#### Code Snippet

```typescript

### Text Response

You can render text as 'Content-Type:text/plain' by using the `text()` method.

```

**Reasoning:** This rule is important as it demonstrates how to handle different types of responses in Hono. It shows how to send a custom response, render text as 'Content-Type:text/plain', and render JSON as 'Content-Type:application/json'. Understanding these response types is crucial for building APIs that can handle different types of data and respond appropriately to client requests.

*Source: docs/api/context.md*

### Handling HTTP Responses in Hono

This rule demonstrates how to use Hono's built-in methods for handling different types of HTTP responses.

Render HTML as `Content-Type:text/html`.

```ts
import { Hono } from 'hono'
const app = new Hono()
app.get('/', (c) => {
  return c.html('<h1>Hello! Hono!</h1>')
})
ts
import { Hono } from 'hono'
const app = new Hono()
app.get('/notfound', (c) => {
  return c.notFound()
})
ts
import { Hono } from 'hono'
const app = new Hono()
app.get('/redirect', (c) => {
  return c.redirect('/new-location')
})
```

These methods are part of Hono's context object, which is passed to each route handler. They provide a simple and intuitive way to handle common HTTP responses.

#### Code Snippet

```typescript

### notFound()

Return the `Not Found` Response.

```

**Reasoning:** These code snippets demonstrate how to use Hono's built-in methods for handling different types of HTTP responses. Understanding these methods is crucial for building web applications with Hono, as they allow developers to easily send HTML content, handle not found errors, and perform redirects.

*Source: docs/api/context.md*

### Handling Not Found and Redirection Responses in Hono

This code snippet demonstrates how to handle not found and redirection responses in Hono.

```ts
import { Hono } from 'hono'
const app = new Hono()

app.get('/notfound', (c) => {
  return c.notFound()
})

app.get('/redirect', (c) => {
  return c.redirect('/')
})
```

In the above code:

1. The `notFound()` method is used to return a 'Not Found' response when the '/notfound' route is accessed.
2. The `redirect()` method is used to redirect the user to the root route ('/') when the '/redirect' route is accessed. By default, the status code for this redirection is `302`.

- The `notFound()` and `redirect()` methods are part of the context (`c`) object provided by Hono.
- The `redirect()` method can also accept a second argument specifying a different status code.

- [Hono Documentation](https://hono.bryntum.com/docs)

- Use the `notFound()` method to handle routes that do not exist in your application.
- Use the `redirect()` method to redirect users after certain actions, such as successful form submission or login.

**Reasoning:** This rule is important as it demonstrates how to handle not found and redirection responses in Hono. Understanding these methods is crucial for managing routing and user navigation within a Hono application.

*Source: docs/api/context.md*

### Using set() / get() and Response Headers in Hono Middleware

This code snippet demonstrates how to use middleware in Hono to set and append headers to the response object. It also shows how to use the 'set' function to add arbitrary key-value pairs to the context object.

```ts
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
// Response object
app.use('/', async (c, next) => {
  await next()
  c.res.headers.append('X-Debug', 'Debug message')
})
```

In this code snippet, the middleware function is used to append a 'X-Debug' header with the value 'Debug message' to the response object. The 'set' function is used to add a 'message' key with the value 'Hono is cool!!' to the context object.

This allows passing specific values between middleware or from middleware to route handlers. It is a common practice in Hono to use middleware for such purposes.

- The 'set' function can be used to add arbitrary key-value pairs to the context object.
- The 'get' function can be used to retrieve the value of a key from the context object.
- The lifetime of these key-value pairs is the current request.

- [Hono Documentation](https://hono.bevry.me/)

- Passing specific values between middleware or from middleware to route handlers.
- Adding custom headers to the response object.

**Reasoning:** This rule is important as it demonstrates how to use middleware in Hono to set and append headers to the response object. It shows how to use the 'set' function to add arbitrary key-value pairs to the context object, which can be used to pass specific values between middleware or from middleware to route handlers.

*Source: docs/api/context.md*

### Using Generics in Hono for Type Safety

This code snippet demonstrates how to use generics in Hono to make the code type-safe. By passing the `Variables` to the constructor of `Hono`, we can ensure that the values of 'c.set' and 'c.get' are retained and correctly typed.

```ts
import { Hono } from 'hono'

type Variables = {
  message: string
}

const app = new Hono<{ Variables: Variables }>()
```

In this code, we define a type `Variables` with a property `message` of type `string`. We then pass this type as a generic to the constructor of `Hono`. This means that when we use 'c.set' and 'c.get', the values are correctly typed as `string`.

- Using generics in this way is a best practice in Hono framework usage as it reduces the risk of runtime errors due to incorrect types.

- [Hono Documentation](https://hono.bike/)

- Storing and retrieving variables in a Hono application
- Ensuring type safety in a Hono application

**Reasoning:** This rule is important as it demonstrates how to use generics in Hono to make the code type-safe. It shows how to pass variables to the constructor of Hono, which ensures that the values of 'c.set' and 'c.get' are retained and correctly typed. This is a best practice in Hono framework usage as it reduces the risk of runtime errors due to incorrect types.

*Source: docs/api/context.md*

### Type-Safety and Variable Management in Hono

This code demonstrates how to use the Hono framework to create type-safe applications and how to manage and access variables within the same request.

```ts twoslash
import { Hono } from 'hono'
// ---cut---
type Variables = {
  message: string
}

const app = new Hono<{ Variables: Variables }>()
ts twoslash
import type { Context } from 'hono'
declare const c: Context
// ---cut---
const result = c.var.client.oneMethod()
```

In the above code, `c.var` is used to access the value of a variable.

- The value of `c.set` / `c.get` are retained only within the same request. They cannot be shared or persisted across different requests.
- You can access the value of a variable with `c.var`.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Creating type-safe applications with Hono
- Managing and accessing variables within the same request

#### Code Snippet

```typescript

In the above code, a type `Variables` is defined and passed to the constructor of `Hono` to make it type-safe.

The value of `c.set` / `c.get` are retained only within the same request. They cannot be shared or persisted across different requests.

You can also access the value of a variable with `c.var`.

```

**Reasoning:** This rule is important as it demonstrates how to use the Hono framework to create type-safe applications and how to manage and access variables within the same request. It also highlights the limitation of `c.set` / `c.get` in that they cannot be shared or persisted across different requests.

*Source: docs/api/context.md*

### Accessing Variable Values and Creating Custom Middleware Methods in Hono

This code demonstrates how to access the value of a variable using 'c.var' and how to create a middleware that provides a custom method in Hono.

```ts twoslash
import type { Context } from 'hono'
declare const c: Context
// ---cut---
const result = c.var.client.oneMethod()
ts twoslash
import { Hono } from 'hono'
import { createMiddleware } from 'hono/factory'
// ---cut---
type Env = {
  Variables: {
    echo: (str: string) => string
  }
}

const app = new Hono()
```

In the first snippet, 'c.var' is used to access the value of a variable. In the second snippet, a custom method is created in the middleware by defining a new type 'Env' and initializing a new Hono application.

- 'c.var' is a powerful feature in Hono that allows for efficient variable management.
- Custom methods in middleware can be created to extend the functionality of your Hono application.

- [Hono Documentation](https://hono.bryntum.com/docs/)

- Accessing variable values in Hono applications
- Extending middleware functionality by creating custom methods

#### Code Snippet

```typescript

To create a middleware that provides a custom method, you can follow the example below:

```

**Reasoning:** This rule is important as it demonstrates how to access the value of a variable using 'c.var' in Hono and how to create a middleware that provides a custom method. Understanding this rule allows developers to effectively utilize Hono's capabilities to manage variables and create custom methods in middleware.

*Source: docs/api/context.md*

### Using Middleware in Multiple Handlers and Ensuring Type Safety in Hono

This code snippet demonstrates how to use a middleware in multiple handlers using the Hono web framework. It also shows how to ensure type safety by passing the 'Env' as Generics to the constructor of 'Hono'.

```ts
const echoMiddleware = createMiddleware<Env>(async (c, next) => {
  c.set('echo', (str) => str)
  await next()
})

app.get('/echo', echoMiddleware, (c) => {
  return c.text(c.var.echo('Hello!'))
})
```

If you want to use the middleware in multiple handlers, you can use `app.use()`. Then, you have to pass the `Env` as Generics to the constructor of `Hono` to make it type-safe.

1. The `echoMiddleware` is created using `createMiddleware` function of Hono. It sets a function 'echo' in the context 'c' that returns the input string.
2. The middleware is then used in a GET handler for the route '/echo'. The handler uses the 'echo' function set in the context by the middleware to return a text response.
3. If you want to use the middleware in multiple handlers, you can use `app.use(echoMiddleware)`.
4. To ensure type safety, you can pass the `Env` as Generics to the constructor of `Hono`.

- Middleware in Hono can be used in multiple handlers, which promotes reusability.
- Type safety can be ensured by passing the 'Env' as Generics to the constructor of 'Hono'.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Using middleware for common functionality across multiple routes.
- Ensuring type safety in middleware.

**Reasoning:** This rule is important as it demonstrates how to use middleware in multiple handlers using Hono web framework. It also shows how to make the middleware type-safe by passing the 'Env' as Generics to the constructor of 'Hono'. This is a common pattern in Hono framework usage and is a best practice for ensuring type safety and reusability of middleware.

*Source: docs/api/context.md*

### Using Middleware and Environment Variables in Hono

In Hono, you can use the 'use' method to add middleware to your application. Middleware are functions that have access to the request object, the response object, and the next function in the application’s request-response cycle. The next function is a function in the Hono stack that, when invoked, executes the middleware succeeding the current middleware.

You can also define a GET request handler using the 'get' method. The handler takes a callback function which receives a context object 'c'. This object contains the request and response objects, among other things.

Environment variables can be accessed in Hono using 'c.var'.

Here is an example:

```javascript
const app = new Hono<Env>()

app.use(echoMiddleware)

app.get('/echo', (c) => {
  return c.text(c.var.echo('Hello!'))
})
```

In this code, 'echoMiddleware' is a middleware function that is added to the application. The '/echo' endpoint returns the result of the 'echo' function defined in the environment variables with 'Hello!' as the argument.

**Reasoning:** This rule is important as it demonstrates how to use the Hono framework to create a simple server with a custom middleware and an endpoint. It shows how to use the 'use' method to add middleware to the application and the 'get' method to define a GET request handler. The rule also demonstrates how to access environment variables in Hono using 'c.var'.

*Source: docs/api/context.md*

### Creating Custom HTML Layouts in Hono

The following code snippet demonstrates how to use the `setRenderer` and `render` methods in Hono to create a custom HTML layout for responses.

```javascript
app.use(async (c, next) => {
  c.setRenderer((content) => {
    return c.html(
      <html>
        <body>
          <p>{content}</p>
        </body>
      </html>
    )
  })
  await next()
})
javascript
app.get('/', (c) => {
  return c.render('Hello!')
})
html
<html>
  <body>
    <p>Hello!</p>
  </body>
</html>
```

The `setRenderer` method is used to define a custom renderer for responses. This renderer is a function that takes a content parameter and returns an HTML string. The `render` method is then used to create responses using this custom layout.

- The `setRenderer` method should be called in a middleware function to ensure that it is set before any routes are processed.
- The `render` method should be used in route handlers to create responses using the custom layout.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Creating custom HTML layouts for responses in a web application.

#### Code Snippet

```typescript

Then, you can utilize `c.render()` to create responses within this layout.

```

**Reasoning:** This rule is important as it demonstrates how to use the `setRenderer` and `render` methods in Hono to create a custom HTML layout for responses. This is a common use case when building web applications with Hono, as it allows developers to easily customize the structure and appearance of their responses.

*Source: docs/api/context.md*

### Creating Responses with `c.render()` and Ensuring Type Safety in Hono

In Hono, you can use the `c.render()` function to create responses within a layout. Here is an example:

```ts
import { Hono } from 'hono'
const app = new Hono()

app.get('/', (c) => {
  return c.render('Hello!')
})
html
<html>
  <body>
    <p>Hello!</p>
  </body>
</html>
ts
declare m
```

The `c.render()` function takes a string argument and wraps it in a basic HTML layout. This is useful for creating dynamic responses in your Hono application.

- The `c.render()` function only supports string arguments.
- To ensure type safety, you can define types using the `declare` keyword.

- [Hono Documentation](https://hono.bespokejs.com)

- Creating dynamic responses in a Hono application.
- Ensuring type safety by defining types.

#### Code Snippet

```typescript

The output of this code will be:

```

**Reasoning:** This rule is important as it demonstrates how to use the `c.render()` function in Hono to create responses within a layout. It also shows how to ensure type safety by defining types. This is a fundamental aspect of building applications with the Hono framework, as it allows developers to create dynamic responses and maintain type safety.

*Source: docs/api/context.md*

### Defining Routes and Rendering Responses in Hono with Type Safety

This code snippet demonstrates how to define a route in Hono and render a response. It also shows how to ensure type safety by defining types for the arguments in the ContextRenderer interface.

```javascript
const app = new Hono()
app.get('/', (c) => {
  return c.render('Hello!')
})
typescript
declare module 'hono' {
  interface ContextRenderer {
    (
      content: string | Promise<string>,
      head: { title: string }
    ): Response | Promise<Response>
  }
}
```

This ensures that the 'content' argument can be a string or a Promise that resolves to a string, and the 'head' argument is an object with a 'title' property of type string. The function can return a Response object or a Promise that resolves to a Response object.

- The 'render' method of the context object is used to send a response to the client.
- Type definitions help in maintaining the integrity of the code and avoiding potential runtime errors.

- [Hono Documentation](https://hono.bike/)

- Defining routes and rendering responses in a Hono application.
- Ensuring type safety in a TypeScript project.

#### Code Snippet

```typescript

In the above code, a new Hono application is created and a GET route for the root URL ('/') is defined. The callback function takes a context object 'c' and uses its 'render' method to send a response.

To ensure type safety, types can be defined for the arguments in the ContextRenderer interface as shown below:

```

**Reasoning:** This rule is important as it demonstrates how to define a route in Hono and render a response. It also shows how to ensure type safety by defining types for the arguments in the ContextRenderer interface. This is crucial in maintaining the integrity of the code and avoiding potential runtime errors.

*Source: docs/api/context.md*

### Defining and Using a Custom Context Renderer in Hono

In Hono, you can define a custom context renderer to render the response of a route handler in a custom way. This is useful when you want to modify the response of a route handler without changing the handler itself.

Here is how you can define a custom context renderer:

```ts
declare module 'hono' {
  interface ContextRenderer {
    (
      content: string | Promise<string>,
      head: { title: string }
    ): Response | Promise<Response>
  }
}
ts
app.use('/pages/*', async (c, next) => {
  c.setRenderer((content, head) => {
    return c.html(
      <html>
        <head>
          <title>{head.title}</title>
        </head>
        <body>
```

The `setRenderer` method sets the context renderer for the current route handler. The context renderer is a function that takes the content and head as arguments and returns a response.

- The context renderer is only used for the current route handler. If you want to use it for all route handlers, you need to set it in a middleware.

- [Hono documentation](https://hono.bouzuya.net/)

- Customizing the response of a route handler
- Adding common headers or footers to the response

#### Code Snippet

```typescript

And here is how you can use it in a route handler:

```

**Reasoning:** This rule is important as it demonstrates how to define and use a custom context renderer in Hono. Context renderers are used to render the response of a route handler in a custom way. This is useful when you want to modify the response of a route handler without changing the handler itself.

*Source: docs/api/context.md*

### Rendering HTML Content with a Title in Hono

This code snippet demonstrates how to use the 'render' method in Hono to return HTML content with a specific title. This is a common use case when building web applications with Hono, as it allows developers to dynamically generate and serve HTML content.

```javascript
app.get('/pages/my-favorite', (c) => {
  return c.render(<p>Ramen and Sushi</p>, {
    title: 'My favorite',
  })
})

app.get('/pages/my-hobbies', (c) => {
  return c.render(<p>Watching baseball</p>, {
    title: 'My hobbies',
  })
})
```

In this example, two routes are defined: '/pages/my-favorite' and '/pages/my-hobbies'. When these routes are accessed, the 'render' method is called with two arguments: the HTML content to be displayed and an object with a 'title' property. The 'title' property is used to set the title of the HTML page.

It's important to note that the 'render' method expects the HTML content to be a valid JSX element. This means that you need to have a JSX transpiler (like Babel) in your project.

Common use cases for this pattern include serving dynamic HTML content based on user input or server-side data.

**Reasoning:** This rule is important as it demonstrates how to use the 'render' method in Hono to return HTML content with a specific title. This is a common use case when building web applications with Hono, as it allows developers to dynamically generate and serve HTML content.

*Source: docs/api/context.md*

### Using Bindings in Hono

In Hono, bindings are a way to access environment variables, secrets, KV namespaces, databases, and buckets that are bound to a worker. Regardless of type, bindings are always available as global variables and can be accessed via the context `c.env.BINDING_KEY`.

Here is an example of how to use bindings in Hono:

```ts
import { Hono } from 'hono'
type KVNamespace = any

// Type definition to make type inference
type Bindings = {
  MY_KV: KVNamespace
}

const app = new Hono<{ Bindings: Bindings }>()

// FetchEvent object (only set when using Service Worker syntax)
app.get('/foo', async (c) => {
  c.event.waitUntil(c.env.MY_KV.put(key, data))
  // ...
})
```

In this code snippet, `MY_KV` is a binding of type `KVNamespace`. It is accessed via `c.env.MY_KV` in the handler for the GET request to '/foo'.

This pattern is important for managing and accessing resources in a Cloudflare Workers environment.

**Reasoning:** This rule is important as it demonstrates how to use bindings in Hono. Bindings are a way to access environment variables, secrets, KV namespaces, databases, and buckets that are bound to a worker. This is crucial for managing and accessing resources in a Cloudflare Workers environment.

*Source: docs/api/context.md*

### Error Handling in Hono Middleware

In Hono, if a handler throws an error, the error object is placed in `c.error`. This can be accessed in your middleware for error handling and debugging.

Here is a code snippet demonstrating this:

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.use(async (c, next) => {
  await next()
  if (c.error) {
    // do something...
  }
})
```

1. Import the Hono framework and initialize a new Hono application.
2. Use the `app.use` method to add a middleware to the application.
3. In the middleware, call `await next()` to wait for the next middleware or route handler to finish.
4. If there is an error in the handler, it will be placed in `c.error`. You can then handle the error as needed.

- Always check for `c.error` in your middleware to handle any errors that may occur in your handlers.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Error logging: You can log the error to a logging service or to the console for debugging purposes.
- Error response: You can send a response to the client with an error message and status code.

**Reasoning:** This rule is important as it demonstrates how to handle errors in Hono middleware. It shows that if a handler throws an error, the error object is placed in `c.error` and can be accessed in your middleware. This is crucial for error handling and debugging in your Hono application.

*Source: docs/api/context.md*

### Using Middleware and Extending ContextVariableMap in Hono

This code demonstrates how to use middleware in Hono and how to extend the `ContextVariableMap` to add type definitions to variables when a specific middleware is used.

```ts
import { Hono } from 'hono'
const app = new Hono()
app.use(async (c, next) => {
  await next()
  if (c.error) {
    // do something...
  }
})
ts
declare module 'hono' {
  interface ContextVariableMap {
    result: string
  }
}
ts
import { createMiddleware } from 'hono/factory'
```

In the first snippet, a middleware is created that waits for the next middleware to finish before checking if there was an error. If there was an error, it performs a certain action.

In the second snippet, the `ContextVariableMap` is extended to include a new variable `result` of type string. This allows you to add type definitions to variables when a specific middleware is used.

- Middleware in Hono is used to handle requests and responses. It's a way to add functionality to your application.
- Extending `ContextVariableMap` allows you to ensure type safety within your middleware.

- [Hono Documentation](https://hono.bike/docs)

- Error handling in middleware
- Adding type definitions to variables in middleware

#### Code Snippet

```typescript

To extend `ContextVariableMap`, you can do the following:

```

**Reasoning:** This rule is important as it demonstrates how to use middleware in Hono and how to extend the ContextVariableMap to add type definitions to variables when a specific middleware is used. This is crucial for enhancing the functionality of your application and for ensuring type safety within your middleware.

*Source: docs/api/context.md*

### Extending ContextVariableMap and Using Custom Variables in Middleware

This code demonstrates how to extend the 'ContextVariableMap' interface in Hono to add custom variables, and how to use these custom variables in middleware.

```ts
declare module 'hono' {
  interface ContextVariableMap {
    result: string
  }
}
ts twoslash
import { createMiddleware } from 'hono/factory'
// ---cut---
const mw = createMiddleware(async (c, next) => {
  c.set('result', 'some values') // result is a string
  await next()
})
```

1. The 'ContextVariableMap' interface is extended to include a new variable 'result'.
2. This new variable is then used in a middleware function created using 'createMiddleware'.

- The new variable can be of any type, not just string.

- Hono documentation: [Extending ContextVariableMap](https://hono.bryntum.com/docs/classes/contextvariablemap.html)

- Adding custom data to the context that can be used across multiple middleware functions.

#### Code Snippet

```typescript

You can then utilize this in your middleware:

```

**Reasoning:** This rule is important as it demonstrates how to extend the 'ContextVariableMap' interface in Hono to add custom variables, and how to use these custom variables in middleware. This is a common pattern in Hono and allows for greater flexibility and customization in middleware functions.

*Source: docs/api/context.md*

### Setting and Retrieving Variables in Hono Middleware

This code demonstrates how to use middleware in Hono to set and retrieve variables. It also shows how Hono's type inference works when setting and retrieving variables in the context object.

```ts
import { createMiddleware } from 'hono/factory'

const mw = createMiddleware(async (c, next) => {
  c.set('result', 'some values')
  await next()
})
ts
import { Hono } from 'hono'

const app = new Hono<{ Variables: { result: string } }>()

app.get('/', (c) => {
  const val = c.get('result')
  return
})
```

The `createMiddleware` function is used to create a middleware that sets a variable in the context object. The `c.set` function is used to set the variable. The `next` function is called to pass control to the next middleware.

In the handler, the `c.get` function is used to retrieve the variable. The type of the variable is inferred from the type of the `Variables` property in the `Hono` instance.

- The `c.set` and `c.get` functions are used to set and retrieve variables in the context object.
- The type of the variable is inferred from the type of the `Variables` property in the `Hono` instance.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Storing and retrieving data in middleware that needs to be accessed in handlers.

#### Code Snippet

```typescript

In a handler, the variable is inferred as the proper type:

```

**Reasoning:** This rule is important as it demonstrates how to use middleware in Hono to set and retrieve variables. It shows how Hono's type inference works when setting and retrieving variables in the context object, ensuring type safety.

*Source: docs/api/context.md*

### Handling Authentication and Throwing Custom HTTP Exceptions in Hono

This code snippet demonstrates how to handle authentication and throw custom HTTP exceptions in Hono.

```javascript
app.post('/auth', async (c, next) => {
  // authentication
  if (authorized === false) {
    throw new HTTPException(401, { message: 'Custom error message' })
  }
  await next()
})
```

In this code:

1. An asynchronous function is defined for the '/auth' route.
2. If the user is not authorized, an HTTPException is thrown with a status code of 401 and a custom error message.
3. If the user is authorized, the next middleware function in the stack is called.

- The HTTPException class is part of the 'hono/http-exception' module.
- The status code and error message can be customized to fit the specific needs of your application.

- [Hono Documentation](https://hono.bike/docs/)

- This pattern is commonly used in routes that require authentication.

**Reasoning:** This rule is important as it demonstrates how to handle authentication and throw custom HTTP exceptions in Hono. It shows how to use the HTTPException class to throw an error with a custom message and status code when authentication fails. This is a common pattern in web development to provide meaningful error messages to the client.

*Source: docs/api/exception.md*

### Handling HTTP Exceptions in Hono

In Hono, you can handle the thrown HTTPException with `app.onError`.

```ts
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
import { HTTPException } from 'hono/http-exception'

// ...

app.onError((err, c) => {
  if (err instanceof HTTPException) {
    // handle the exception
  }
})
```

The `app.onError` method is used to register a function that will be called whenever an error is thrown in your application. This function takes two arguments: the error that was thrown and the current context.

In this case, we're checking if the error is an instance of `HTTPException`. If it is, we can handle it in a specific way.

- Make sure to import the `HTTPException` class from 'hono/http-exception'.
- The `app.onError` method should be called after all your routes and middleware have been registered.

- [Hono documentation](https://hono.bayfront.cloud/)

- Returning a custom error response to the user.
- Logging the error for debugging purposes.

**Reasoning:** This rule is important as it demonstrates how to handle HTTP exceptions in the Hono framework. Proper exception handling is crucial in any application to ensure that it can recover gracefully from errors and provide useful feedback to the user.

*Source: docs/api/exception.md*

### Extracting Parameters from Request URL in Hono

In Hono, you can extract parameters from the request URL using the `param()` method. This is useful when dealing with dynamic routes where the URL parameters can change based on the request.

Here's a code snippet demonstrating this:

```ts
import { Hono } from 'hono'
const app = new Hono()

// Extracting a single parameter
app.get('/entry/:id', async (c) => {
  const id = c.req.param('id')
})

// Extracting multiple parameters at once
app.get('/entry/:id/comment/:commentId', async (c) => {
  const { id, commentId } = c.req.param()
})
```

In the first route, we're extracting a single parameter 'id' from the request URL. In the second route, we're extracting multiple parameters 'id' and 'commentId' at once using destructuring.

- The `param()` method returns the value of the named route parameter.
- When called without any arguments, it returns an object containing all the route parameters.

- [Hono Documentation](https://hono.boutell.com/)

- Retrieving blog post based on post ID
- Fetching user profile based on user ID

**Reasoning:** This rule is important as it demonstrates how to extract parameters from the request URL in Hono. Understanding this rule is crucial for handling dynamic routes where the URL parameters can change based on the request.

*Source: docs/api/request.md*

### Handling Multiple Query Parameters in Hono

In Hono, you can handle multiple query parameters using the `queries()` method. This method returns an array of values for a given query parameter. Here's how you can use it:

```ts
import { Hono } from 'hono'
const app = new Hono()

app.get('/search', async (c) => {
  // tags will be string[]
  const tags = c.req.queries('tags')
  // ...
})
```

In the above code, `tags` will be an array of strings containing the values of the 'tags' query parameter.

- The `queries()` method returns an array of strings. If the query parameter is not present in the request, it returns an empty array.

- [Hono Documentation](https://hono.bevry.me/)

- Filtering results based on multiple tags in a search API endpoint.

**Reasoning:** This rule is important as it demonstrates how to handle multiple query parameters in Hono. It shows how to extract multiple query parameters from a request using the queries() method. This is crucial in building APIs where endpoints often need to handle multiple query parameters.

*Source: docs/api/request.md*

### Extracting Query Parameters in Hono

This code snippet demonstrates how to extract query parameters from a request in Hono.

```ts
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/search', async (c) => {
  // tags will be string[]
  const tags = c.req.queries('tags')
  // ...
})
```

In this example, the `queries` method is used to retrieve the 'tags' query parameter from the request. The returned value will be an array of strings.

The `queries` method is a part of the request (`req`) object in Hono. It is used to retrieve the value of a specified query parameter. The parameter name is passed as an argument to the `queries` method.

- The `queries` method returns an array of strings. If the query parameter is not present in the request, it will return an empty array.

- [Hono Documentation](https://hono.bike/docs/)

- Filtering data based on query parameters
- Manipulating data based on query parameters

**Reasoning:** This rule is important as it demonstrates how to extract query parameters from a request in Hono. Understanding how to retrieve query parameters is crucial for handling client requests and manipulating data based on these parameters.

*Source: docs/api/request.md*

### Retrieving Header Values in Hono

In Hono, when you call the `header()` method with no arguments, all keys in the returned record are lowercase. Therefore, if you want to get the value of a header with an uppercase name, you need to call the `header()` method with the specific header name as an argument.

Here is an example of how to do it correctly:

```ts
// ✅ Will work
const foo = c.req.header('X-Foo')
ts
// ❌ Will not work
const headerRecord = c.req.header()
const foo = headerRecord['X-Foo']
```

- Always remember to use the specific header name as an argument when calling the `header()` method if the header name contains uppercase letters.

- Hono Documentation

- Retrieving specific header values from a request in Hono.

#### Code Snippet

```typescript

And here is an example of what will not work:

```

**Reasoning:** This rule is important because it demonstrates how to correctly retrieve header values from a request in Hono. It shows that when calling the header() method with no arguments, all keys in the returned record are lowercase. Therefore, to get the value of a header with an uppercase name, it is necessary to call the header() method with the specific header name as an argument.

*Source: docs/api/request.md*

### Accessing Headers and Parsing Request Bodies in Hono

In Hono, headers should be accessed directly using the header name as a parameter in the `c.req.header()` function. Trying to access it as a property of the returned object will not work.

```ts
// ❌ Will not work
const headerRecord = c.req.header()
const foo = headerRecord['X-Foo']

// ✅ Will work
const foo = c.req.header('X-Foo')
ts
c.req.parseBody()
```

This function supports the following types of request bodies: `multipart/form-data` and `application/x-www-form-urlencoded`.

- Always use the header name as a parameter when accessing headers.
- Use `parseBody()` to parse request bodies of the supported types.

- Hono Documentation

- Accessing request headers
- Parsing request bodies

#### Code Snippet

```typescript

To parse request bodies of type `multipart/form-data` or `application/x-www-form-urlencoded`, use the `parseBody()` function.

```

**Reasoning:** This rule is important as it demonstrates the correct way to access headers and parse request bodies in Hono. It shows that headers should be accessed directly using the header name as a parameter in the `c.req.header()` function, rather than trying to access it as a property of the returned object. It also shows how to parse request bodies of type `multipart/form-data` or `application/x-www-form-urlencoded` using the `parseBody()` function.

*Source: docs/api/request.md*

### Handling POST Requests with `parseBody()` in Hono

In Hono, you can use the `parseBody()` function to parse the body of a POST request. This function supports various behaviors, including handling single file uploads.

Here's an example of how to use it:

```ts
import { Hono } from 'hono'
const app = new Hono()
app.post('/entry', async (c) => {
  const body = await c.req.parseBody()
  // ...
})
ts
import { Context } from 'hono'
declare const c: Context
const body = await c.req.parseBody()
const data = body['foo']
```

In this case, `body['foo']` will be of type `(string | File)`, depending on whether the uploaded file was a string or a file.

- `parseBody()` is an asynchronous function, so you need to use `await` when calling it.

- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)

- Parsing the body of a POST request to handle form submissions or file uploads.

#### Code Snippet

```typescript

In this code snippet, `parseBody()` is used to parse the body of the request. The parsed body is then stored in the `body` variable.

You can access the parsed data like this:

```

**Reasoning:** This rule is important because it demonstrates how to use the `parseBody()` function in Hono to handle POST requests. This is a common task in web development, and understanding how to do it properly in Hono is crucial for building robust applications.

*Source: docs/api/request.md*

### Handling Multiple File Uploads in Hono

This code snippet demonstrates how to handle multiple file uploads in Hono.

```ts twoslash
import { Context } from 'hono'
declare const c: Context
// ---cut---
const body = await c.req.parseBody()
body['foo[]']
ts twoslash
import { Context } from 'hono'
declare const c: Context
// ---cut---
const body = await c.req.parseBody({ all: true })
body['foo']
```

The 'all' option is disabled by default. When enabled, it allows for handling multiple files with the same name.

- The '[]' postfix is required for handling multiple files.
- The 'all' option is disabled by default and needs to be enabled for handling multiple files with the same name.

- Hono Documentation

- Uploading multiple files in a single request
- Handling files with the same name in a single request

#### Code Snippet

```typescript

In this example, `body['foo[]']` is always `(string | File)[]`. The '[]' postfix is required when dealing with multiple files.

For handling multiple files with the same name, the 'all' option is used.

```

**Reasoning:** This rule is important as it demonstrates how to handle multiple file uploads in Hono. It shows how to parse the request body to access the uploaded files and the importance of using the '[]' postfix for multiple files and the 'all' option for files with the same name.

*Source: docs/api/request.md*

### Handling Multiple Files and Structuring Return Values in Hono

This code demonstrates how to handle multiple files with the same name and how to structure the return value based on the dot notation in Hono.

```ts
import { Context } from 'hono'
declare const c: Context
// ---cut---
const body = await c.req.parseBody({ all: true })
body['foo']
ts
data.append('obj.key1', 'value1')
data.append('obj.key2', 'value2')
```

You can get the structured value by setting the `dot` option `true`.

- The `all` option allows you to parse all files, not just the first one with a specific name.
- The `dot` option allows you to structure the return value based on the dot notation, which can be useful for handling complex data structures.

- [Hono Documentation](https://hono.bike/)

- Parsing form data with multiple files of the same name.
- Structuring return values based on the dot notation for complex data structures.

#### Code Snippet

```typescript

By default, the `all` option is disabled. If `body['foo']` is multiple files, it will be parsed to `(string | File)[]`. If `body['foo']` is a single file, it will be parsed to `(string | File)`.

If you set the `dot` option `true`, the return value is structured based on the dot notation. For example, if you receive the following data:

```

**Reasoning:** This rule is important as it demonstrates how to handle multiple files with the same name and how to structure the return value based on the dot notation in Hono. Understanding these features allows developers to effectively parse and structure data in their applications.

*Source: docs/api/request.md*

### Parsing Structured FormData in Hono

This code snippet demonstrates how to parse structured data from a FormData object in Hono.

```ts twoslash
const data = new FormData()
data.append('obj.key1', 'value1')
data.append('obj.key2', 'value2')
ts twoslash
import { Context } from 'hono'
declare const c: Context
// ---cut---
const body = await c.req.parseBody({ dot: true })
// body is `{ obj: { key1: 'value1', key2: 'value2' } }`
```

The `parseBody` method of the `req` object in Hono's Context is used to parse the FormData. By setting the `dot` option to true, the keys in the FormData object that are structured based on the dot notation are parsed into a nested object.

- The 'dot' option should be set to true if you want to parse structured data from FormData.

- Hono Documentation

- Parsing structured data from FormData in web applications.

#### Code Snippet

```typescript

You can get the structured value by setting the `dot` option `true`:

```

**Reasoning:** This rule is important because it demonstrates how to parse structured data from a FormData object in Hono. By setting the 'dot' option to true, the structured data can be extracted in a nested object format, which can be easier to work with in many scenarios.

*Source: docs/api/request.md*

### Parsing Request Body in Hono

This code snippet demonstrates how to parse the request body in Hono. This is commonly done when handling POST requests, where the body often contains the data that the client wants to send to the server.

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.post('/entry', async (c) => {
  const body = await c.req.json()
  // ...
})
```

In this example, the `json()` method is used to parse the body as JSON. This is a common data format for APIs.

The `json()` method is called on the `req` object, which represents the request. This method returns a promise that resolves with the parsed body.

- The `json()` method can only parse JSON-formatted data. If the data is not in this format, an error will be thrown.

- [Hono Documentation](https://hono.beyondco.de/docs/getting-started)

- Parsing the body of a POST request to get the data sent by the client.

**Reasoning:** This rule is important as it demonstrates how to parse the request body in Hono. Parsing the request body is a common task in web development, especially when dealing with POST requests. The rule shows how to parse the body as JSON, which is a common data format for APIs.

*Source: docs/api/request.md*

### Parsing Request Bodies in Hono

This rule demonstrates how to parse different types of request bodies in Hono. The code snippets show how to parse JSON, text, and arrayBuffer types of request bodies.

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.post('/entry', async (c) => {
  const body = await c.req.json()
  // ...
})
ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.post('/entry', async (c) => {
  const body = await c.req.text()
  // ...
})
```

In each of the code snippets, a POST request is being made to the '/entry' endpoint. The request body is then parsed using the appropriate method depending on the content type of the request body.

It's crucial to use the correct parsing method for the content type of the request body. Using the wrong method could lead to errors or incorrect data processing.

- Hono Documentation: [Request Parsing](https://hono.bike/docs/request-parsing/)

Parsing request bodies is a common task in server-side programming. It's typically done when a client sends data to the server via a POST or PUT request.

#### Code Snippet

```typescript

#### Text

```

**Reasoning:** This rule is important as it demonstrates how to parse different types of request bodies in Hono. It shows how to parse JSON, text, and arrayBuffer types of request bodies. Understanding how to correctly parse request bodies is crucial for handling client requests and processing data in server-side applications.

*Source: docs/api/request.md*

### Parsing Request Body as ArrayBuffer in Hono

This code snippet demonstrates how to parse the request body as an `ArrayBuffer` in Hono.

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.post('/entry', async (c) => {
  const body = await c.req.arrayBuffer()
  // ...
})
```

In the given code, `app.post` is used to handle POST requests to the '/entry' endpoint. Inside the callback function, `c.req.arrayBuffer()` is used to parse the request body as an `ArrayBuffer`.

- The `arrayBuffer()` method returns a promise that resolves with an `ArrayBuffer` representing the request's body.
- This method is useful when you need to handle binary data.

- [Hono Documentation](https://hono.bryntum.com/docs/)

- Receiving binary data like images or files from the client.

**Reasoning:** This rule is important as it demonstrates how to parse the request body as an `ArrayBuffer` in Hono. Understanding how to correctly parse the request body is crucial for handling client requests and processing data in the server.

*Source: docs/api/request.md*

### Handling and Validating Incoming Data in Hono

In Hono, you can handle and validate incoming data from different sources using the 'valid' method. This method takes a string argument that specifies the source of the data.

Here is a code snippet that demonstrates this:

```ts
c.app.post('/posts', async (c) => {
  const { title, body } = c.req.valid('form')
  // ...
})
```

In this example, the 'valid' method is used to validate data coming from a form. The validated data is then destructured into 'title' and 'body'.

The 'valid' method can handle data from the following sources:

- `form`
- `json`
- `query`
- `header`
- `cookie`
- `param`

It's important to validate incoming data to ensure that it is as expected and to prevent potential issues related to data integrity and security.

References:

- Hono documentation: [link]

Common use cases:

- Validating form data before processing it
- Checking the validity of incoming JSON data
- Ensuring that query parameters meet certain criteria

**Reasoning:** This rule is important as it demonstrates how to handle and validate different types of incoming data in Hono. It shows how to use the 'valid' method to validate incoming data from different sources such as form, json, query, header, cookie, and param. This is crucial in ensuring that the data being processed by the application is as expected and helps prevent potential issues related to data integrity and security.

*Source: docs/api/request.md*

### Using 'valid' and 'routePath' methods in Hono

This code demonstrates how to use the 'valid' method to get validated data from different targets and the 'routePath' method to retrieve the registered path within the handler.

```ts
app.post('/posts', async (c) => {
  const { title, body } = c.req.valid('form')
  // ...
})
ts
app.get('/posts/:id', (c) => {
  return c.json({ path: c.req.routePath })
})
```

The 'valid' method is used to get validated data from the specified target. The available targets are form, json, query, header, cookie, and param.

The 'routePath' method is used to retrieve the registered path within the handler.

- Make sure to use the correct target with the 'valid' method.
- The 'routePath' method returns the path as registered in the app, not the actual URL.

- [Validation section](/docs/guides/validation)

- Use the 'valid' method to get validated data when handling form submissions or API requests.
- Use the 'routePath' method to get the registered path for logging or debugging purposes.

**Reasoning:** This rule is important as it demonstrates how to use the 'valid' method and 'routePath' method in Hono. The 'valid' method is used to get validated data from different targets such as form, json, query, header, cookie, and param. The 'routePath' method is used to retrieve the registered path within the handler.

*Source: docs/api/request.md*

### Defining and Accessing Route Parameters in Hono

In Hono, you can define a route with a parameter by using a colon (`:`) followed by the parameter name in the route string. You can then access this parameter within the route handler using the `req.routePath` property.

Here is an example:

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/posts/:id', (c) => {
  return c.json({ path: c.req.routePath })
})
json
{ "path": "/posts/:id" }
```

When you define a route with a parameter in Hono, the framework automatically extracts the parameter from the incoming request URL and makes it available within the route handler through the `req.routePath` property.

- Route parameters are a powerful feature that allows you to create dynamic routes. However, they should be used judiciously to avoid creating overly complex routes that are difficult to maintain.

- [Hono Documentation](https://hono.beyondco.de/docs/routing)

- Creating a blog post detail page where the post ID is dynamic.
- Building a user profile page where the user ID is dynamic.

#### Code Snippet

```typescript

If you access `/posts/123`, it will return `/posts/:id`:

```

**Reasoning:** This rule is important as it demonstrates how to define a route with a parameter in Hono and how to access that parameter within the route handler. It also shows how to return the registered path within the handler. This is a fundamental concept in building web applications with Hono, as it allows developers to create dynamic routes that can handle a variety of requests.

*Source: docs/api/request.md*

### Handling Route Parameters in Hono

In Hono, you can define routes with parameters and access these parameters in the route handler. Here is an example:

```javascript
const app = new Hono()
app.get('/posts/:id', (c) => {
  return c.json({ path: c.req.routePath })
})
json
{ "path": "/posts/:id" }
```

This is useful when you want to handle requests to different URLs in a similar way, but the exact URL is not known in advance. For example, you might want to display a specific post based on its ID, and the ID is part of the URL.

- The route parameters are accessible through the `c.req.routePath` object.
- The route parameters are always strings.

- [Hono Documentation](https://hono.bevry.me/)

- Retrieving a specific resource based on its ID from the URL.
- Handling requests to different URLs in a similar way.

#### Code Snippet

```typescript

In this example, `:id` is a route parameter. When you access `/posts/123`, it will return `/posts/:id`:

```

**Reasoning:** This rule is important as it demonstrates how to handle route parameters in Hono. It shows how to define a route with a parameter and how to access this parameter in the route handler. This is a common requirement in many web applications where the URL contains some dynamic part.

*Source: docs/api/request.md*

### Accessing the Request Pathname in Hono

This code demonstrates how to access the request pathname in Hono.

```ts
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/about/me', async (c) => {
  const pathname = c.req.path // `/about/me`
  // ...
})
```

In this snippet, a GET request handler is set up for the path '/about/me'. Inside the handler, the request pathname is accessed using `c.req.path`. This will return the path of the request, in this case, '/about/me'.

- The request object (`c.req`) contains information about the HTTP request that triggered the event. It includes properties such as `path` (the request pathname), `method` (the HTTP method), and `headers` (the HTTP headers).

- [Hono Documentation](https://hono.bj/hono)

- Use the request pathname to handle different routes in your application.
- Use the request pathname to perform different actions based on the specific route.

**Reasoning:** This rule is important as it demonstrates how to access the request pathname in Hono. Understanding how to retrieve the request pathname is crucial for routing and handling requests in a web application.

*Source: docs/api/request.md*

### Accessing Request Pathname and URL in Hono

This code demonstrates how to access the request pathname and URL in the Hono web framework.

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/about/me', async (c) => {
  const pathname = c.req.path // `/about/me`
  // ...
})
ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/about/me', async (c) => {
  const url = c.req.url // `http://localhost:8787/about/me`
  // ...
})
```

In these snippets, `c.req.path` and `c.req.url` are used to access the request pathname and URL respectively. The `c` object is the context object passed to the route handler, which contains the request (`req`) and response (`res`) objects among other things.

- The request pathname does not include the protocol or domain.
- The request URL includes the protocol and domain.

- [Hono Documentation](https://hono.bike/)

- Checking the request pathname or URL to perform specific actions based on the route.
- Logging the request pathname or URL for debugging or analytics purposes.

**Reasoning:** This rule is important as it demonstrates how to access the request pathname and URL in the Hono web framework. Understanding how to retrieve these values is crucial for handling requests and routing in web applications.

*Source: docs/api/request.md*

### Handling HTTP GET Requests in Hono

This code snippet demonstrates how to handle HTTP GET requests in the Hono framework. It shows how to extract the URL and the method of the request.

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.get('/about/me', async (c) => {
  const url = c.req.url // `http://localhost:8787/about/me`
  // ...
})
```

In the above code, `app.get` is used to handle GET requests to the '/about/me' endpoint. The callback function takes a context object `c` as an argument, which contains the request and response objects. The URL of the request can be accessed with `c.req.url`, and the method of the request with `c.req.method`.

- The context object `c` contains other useful properties and methods for handling the request and response.

- [Hono Documentation](https://hono.bike/)

- Retrieving the URL or method of the request is useful in many situations, such as logging, routing, or conditional processing based on the request details.

**Reasoning:** This rule is important as it demonstrates how to handle HTTP GET requests in the Hono framework. It shows how to extract the URL and the method of the request, which are fundamental aspects of handling HTTP requests in any web framework.

*Source: docs/api/request.md*

### Accessing Request Method and Raw Request in Hono

The following code snippets demonstrate how to access the method name of the request and the raw request object in Hono.

To access the method name of the request:

```ts
import { Hono } from 'hono'
const app = new Hono()
app.get('/about/me', async (c) => {
  const method = c.req.method // `GET`
  // ...
})
ts
// For Cloudflare Workers
app.post('/', async (c) => {
  const metadata = c.req.raw.cf?.hostMetadata?
  // ...
})
```

In the first snippet, `c.req.method` is used to access the method name of the request. In the second snippet, `c.req.raw` is used to access the raw request object.

These properties can be useful for handling different types of HTTP requests and for accessing raw request data when necessary.

References:
- [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)

Common use cases:
- Checking the HTTP method of a request to perform different actions based on the method
- Accessing raw request data for advanced use cases

#### Code Snippet

```typescript

To access the raw request object:

```

**Reasoning:** This rule is important as it demonstrates how to access the method name of the request and the raw request object in Hono. Understanding how to access these properties is crucial for handling different types of HTTP requests and for accessing raw request data when necessary.

*Source: docs/api/request.md*

### Custom Error Handling in Hono

In Hono, the `app.onError` method is used to handle any errors that occur during the execution of the application. This method takes a callback function as an argument, which is called when an error occurs. The callback function receives the error object and a context object as arguments.

Here is a code snippet demonstrating this:

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
app.onError((err, c) => {
  console.error(`${err}`)
  return c.text('Custom Error Message', 500)
})
```

In this example, when an error occurs, the error message is logged to the console and a custom error message is returned with a status code of 500.

- The `app.onError` method should be used for error handling in Hono applications.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Customizing error responses in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to handle errors in the Hono framework. It shows how to use the `app.onError` method to handle any errors that occur during the execution of the application and return a customized response. This is crucial for robust error handling and providing meaningful feedback to the user.

*Source: docs/api/hono.md*

### Handling Errors and Adding Fetch Event Listener in Hono

This code demonstrates how to handle errors and add a fetch event listener in Hono framework.

```ts
import { Hono } from 'hono'
const app = new Hono()

app.onError((err, c) => {
  console.error(`${err}`)
  return c.text('Custom Error Message', 500)
})
ts
app.fire()
ts
addEventListener('fetch', (event: FetchEventLike): void => {
  event.respondWith(this.dispatch(...))
})
```

This means that whenever a fetch event occurs, the application will automatically respond with the result of the `dispatch()` method.

- [Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)
- [Cloudflare Workers](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/)

- Handling errors in a Hono application
- Adding a fetch event listener to a Hono application

#### Code Snippet

```typescript

In the above code, `app.onError()` is used to handle any errors that occur in the application. The error and the context are passed to the callback function, which logs the error and returns a custom error message with a status code of 500.

The `fire()` method is used to automatically add a global `fetch` event listener. This is useful in environments that adhere to the Service Worker API, such as non-ES module Cloudflare Workers.

```

**Reasoning:** This rule is important as it demonstrates how to handle errors in Hono framework and how to use the `fire()` method to add a global `fetch` event listener. Understanding this rule is crucial for developers to ensure their applications can handle errors gracefully and respond to fetch events correctly.

*Source: docs/api/hono.md*

### Setting up the Entry Point in Hono

The `app.fetch` function is used to set up the entry point of your application in the Hono web framework. This is the first point of contact for incoming requests to your application.

Here is an example of how to set this up for Cloudflare Workers:

```ts twoslash
import { Hono } from 'hono'
const app = new Hono()
type Env = any
type ExecutionContext = any
// ---cut---
export default {
  fetch(request: Request, env: Env, ctx: ExecutionContext) {
```

The `app.fetch` function is called when a request is made to your application. The `fetch` function takes in a `request` object, an `env` object representing the environment, and a `ctx` object representing the execution context.

- The `app.fetch` function is specific to the Hono web framework and may not be available in other frameworks.

- [Hono Documentation](https://hono.boutell.com/)

- Setting up the entry point for a new Hono application.
- Modifying the entry point for an existing Hono application.

**Reasoning:** This rule is important as it demonstrates how to set up the entry point of an application using the Hono web framework. The entry point is crucial as it is the first point of contact for incoming requests to the application. Understanding how to correctly set this up is key to ensuring the application functions as expected.

*Source: docs/api/hono.md*

### Exporting a Hono Instance

This guide demonstrates two different ways of exporting a Hono instance in a module.

```ts
import { Hono } from 'hono'
const app = new Hono()
export default {
  fetch(request: Request, env: Env, ctx: ExecutionContext) {
    return app.fetch(request, env, ctx)
  },
}
ts
import { Hono } from 'hono'
const app = new Hono()
export default app
```

In this method, we are directly exporting the Hono instance. This method is more concise and is suitable when no additional logic is needed in the fetch function.

- Choose the method that best suits your needs. If you need to add additional logic in the fetch function, use the first method. If you don't need to add additional logic, use the second method for conciseness.

- [Hono Documentation](https://hono.readthedocs.io/en/latest/)

- When creating a module that uses Hono for fetching data.

#### Code Snippet

```typescript

In this method, we are explicitly defining a fetch function that calls the fetch function of the Hono instance. This method is more verbose and allows for additional logic to be added in the fetch function if needed.

## Code Snippet 2:

```

**Reasoning:** This rule is important as it demonstrates two different ways of exporting a Hono instance in a module. The first method is more verbose and allows for additional logic to be added in the fetch function if needed. The second method is more concise and is suitable when no additional logic is needed in the fetch function.

*Source: docs/api/hono.md*

### Initializing and Exporting a Hono Application

This code snippet demonstrates how to initialize a new Hono application and export it for use in other modules. It also shows how to override the default settings of the application by exporting an object with custom properties.

```ts
import { Hono } from 'hono'
const app = new Hono()
// ---cut---
export default app
ts
export default app // [!code --]
export default {  // [!code ++]
  port: 3000, // [!code ++]
  fetch: app.fetch, // [!code ++]
} // [!code ++]
```

1. The `Hono` class is imported from the 'hono' module.
2. A new instance of `Hono` is created and assigned to the `app` constant.
3. The `app` constant is then exported as the default export of the module.
4. Alternatively, you can export an object with custom properties. This object includes the `port` property set to 3000 and the `fetch` method of the `app` instance.

- The `fetch` method is a useful method for making HTTP requests.

- Hono documentation: https://hono.bryntum.com/docs/

- Initializing a Hono application for use in a server-side JavaScript environment.

#### Code Snippet

```typescript

Or you can do:

```

**Reasoning:** This rule is important as it demonstrates how to properly initialize and export a Hono application. It also shows how to override the default settings of the application by exporting an object with custom properties.

*Source: docs/api/hono.md*

### Exporting an Application and Using request Method in Hono

In Hono, you can export your application with additional configurations. This is demonstrated in the following code snippet:

```ts
export default app // [!code --]
export default {  // [!code ++]
  port: 3000, // [!code ++]
  fetch: app.fetch, // [!code ++]
} // [!code ++]
ts
import { Hono } from 'hono'
const app = new Hono()
declare const test: (name: string, fn: () => void) => void
declare const expect: (value: any) => any
// ---cut---
test('GET /hello is ok'
```

This is a common use case when testing your application's endpoints.

- When exporting your application, ensure to include all necessary configurations.
- The `request` method is a powerful tool for testing, use it to ensure your endpoints are working as expected.

- Hono Documentation

- Exporting an application with specific configurations
- Testing endpoints with the `request` method

#### Code Snippet

```typescript

This allows you to specify the port and fetch method for your application.

The `request` method is a useful tool for testing in Hono. You can pass a URL or pathname to send a GET request, and `app` will return a `Response` object. This is demonstrated in the following code snippet:

```

**Reasoning:** This rule is important as it demonstrates how to correctly export an application in Hono. It also shows how to use the `request` method for testing, which is a common use case in Hono framework.

*Source: docs/api/hono.md*

### Testing Routes in Hono

This code snippet demonstrates how to test routes in the Hono framework.

```ts
import { Hono } from 'hono'
const app = new Hono()
declare const test: (name: string, fn: () => void) => void
declare const expect: (value: any) => any

test('GET /hello is ok', async () => {
  const res = await app.request('/hello')
  expect(res.status).toBe(200)
})
```

1. We first import the `Hono` class and create an instance of it.
2. We declare the `test` and `expect` functions. These are usually provided by a testing library like Jest.
3. We define a test for the `GET /hello` route. We send a request to this route using the `request` method of the `app` instance.
4. We check the status of the response. We expect it to be `200`, which means the request was successful.

- The `request` method returns a `Promise` that resolves to the response. We need to use the `await` keyword to wait for the promise to resolve.

- [Hono documentation](https://hono.bevry.me/)

- Testing the functionality of routes in a web application.

**Reasoning:** This rule is important as it demonstrates how to test routes in the Hono framework. It shows how to send a request to a specific route and how to check the status of the response. This is a fundamental part of developing and testing web applications, ensuring that the routes are working as expected.

*Source: docs/api/hono.md*

### Testing POST Requests in Hono

This code snippet demonstrates how to test a POST request in Hono. It creates a request, sends it to the Hono application, and then checks the response status.

```ts
test('POST /message is ok', async () => {
  const req = new Request('Hello!', {
    method: 'POST',
  })
  const res = await app.request(req)
  expect(res.status).toBe(201)
})
```

1. A test is defined with the description 'POST /message is ok'.
2. A new Request is created with the message 'Hello!' and the method set to 'POST'.
3. The request is sent to the Hono application using the `app.request()` method.
4. The response status is checked to be 201, indicating that the request was successful and a new resource was created.

- The `app.request()` method is used to send the request to the Hono application.
- The `expect()` function is used to check the response status.

- [Hono documentation](https://hono.bike/)

- Testing how your Hono application responds to different types of requests.
- Checking that your application behaves as expected when it receives a POST request.

**Reasoning:** This rule is important as it demonstrates how to test a POST request in Hono. It shows how to create a request, send it to the Hono application, and then check the response status. This is a fundamental aspect of ensuring that the application behaves as expected when it receives a POST request.

*Source: docs/api/hono.md*

### Managing Route Matching in Hono Using Strict Mode

In Hono, the strict mode is used to manage route matching. By default, the strict mode is set to `true` and it distinguishes between similar routes. For example, `/hello` and `/hello/` are treated as different routes.

```text
Strict mode defaults to `true` and distinguishes the following routes.

- `/hello`
- `/hello/`

`app.get('/hello')` will not match `GET /hello/`.
text
By setting strict mode to `false`, both paths will be treated equally.
```

When you create a new Hono application, you can set the strict mode in the options. If you set it to `false`, the trailing slashes in the routes will be ignored.

- The strict mode only affects the trailing slashes in the routes.

- [Hono Documentation](https://hono.bouzuya.net/)

- When you want to treat `/hello` and `/hello/` as the same route, you can set the strict mode to `false`.

#### Code Snippet

```typescript

However, you can make the route matching less strict by setting the strict mode to `false`. In this case, both `/hello` and `/hello/` will be treated as the same route.

```

**Reasoning:** This rule is important as it demonstrates how to manage route matching in Hono framework using the strict mode. It shows how the strict mode can be used to distinguish between similar routes and how to make the route matching less strict by setting the strict mode to false.

*Source: docs/api/hono.md*

### Specifying a Different Router in Hono

In Hono, the default router is 'SmartRouter'. If you want to use a different router, like 'RegExpRouter', you can do so by passing it to a new Hono instance. Here is a code snippet demonstrating this:

```ts twoslash
import { Hono } from 'hono'
import { RegExpRouter } from 'hono/router/reg-exp-router'

const app = new Hono({ router: new RegExpRouter() })
```

In this code snippet, we first import the 'Hono' and 'RegExpRouter' modules. Then, we create a new instance of 'Hono', passing an object with a 'router' property set to a new instance of 'RegExpRouter'. This tells Hono to use 'RegExpRouter' for routing instead of the default 'SmartRouter'.

- You can use any router that is compatible with Hono by following this pattern.

- [Hono Documentation](https://hono.bevry.me/)

- When you need to use a different routing mechanism in your Hono application.

**Reasoning:** This rule is important as it demonstrates how to specify a different router in Hono. By default, Hono uses the 'SmartRouter'. However, if a user wants to use a different router, like 'RegExpRouter', they can do so by passing it to a new Hono instance. This flexibility allows developers to choose the routing mechanism that best suits their application's needs.

*Source: docs/api/hono.md*

### Using Generics in Hono to Specify Types of Cloudflare Workers Bindings and Variables

In Hono, you can use Generics to specify the types of Cloudflare Workers Bindings and variables used in `c.set`/`c.get`. This is useful for maintaining type safety and ensuring the correct usage of variables and bindings.

Here is a code snippet demonstrating this:

```ts twoslash
import { Hono } from 'hono'
type User = any
declare const user: User
// ---cut---
type Bindings = {
  TOKEN: string
}

type Variables = {
  user: User
}

const app = new Hono<{
  Bindings:
```

In this code snippet, a generic is used to specify the types of the `TOKEN` binding and the `user` variable. This ensures that these elements are used correctly in the code, and any misuse will be caught by the TypeScript compiler.

- Generics in Hono are a powerful tool for maintaining type safety and ensuring correct usage of variables and bindings.

- Misuse of variables and bindings can lead to runtime errors, so it's important to use generics to catch these errors at compile time.

- [Hono Documentation](https://hono.boutell.com/)

- Defining the types of Cloudflare Workers Bindings and variables used in `c.set`/`c.get`.

**Reasoning:** This rule is important as it demonstrates how to use Generics in Hono to specify the types of Cloudflare Workers Bindings and variables used in `c.set`/`c.get`. This is crucial for type safety and ensuring the correct usage of variables and bindings.

*Source: docs/api/hono.md*

### Importing and Using Different Versions of Hono

This code snippet demonstrates how to import and use different versions of Hono, and how to instantiate routers in each version.

```ts
// Importing Hono
import { Hono } from 'hono'

// Instantiating routers in Hono
this.router = new SmartRouter({
  routers: [new RegExpRouter(), new TrieRouter()],
})

// Importing Hono Quick
import { Hono } from 'hono/quick'

// Instantiating routers in Hono Quick
this.router = new SmartRouter({
  routers: [new LinearRouter(), new TrieRouter()],
})
```

In the first part, we import the main Hono package and instantiate a SmartRouter with a RegExpRouter and a TrieRouter. In the second part, we import the 'quick' version of Hono and instantiate a SmartRouter with a LinearRouter and a TrieRouter.

Different versions of Hono may have different performance characteristics and features. Choose the version that best fits your application's needs.

- Hono Documentation

- When you need to use different routing strategies in your application.
- When you need to switch between different versions of Hono based on performance requirements or feature availability.

**Reasoning:** This rule is important as it demonstrates how to import and use different versions of Hono, and how to instantiate routers in each version. Understanding this rule allows developers to utilize the appropriate version of Hono based on their specific needs and constraints.

*Source: docs/api/presets.md*

### Using Different Presets in Hono Framework

This rule demonstrates how to use different presets in Hono framework. The presets 'hono/quick' and 'hono/tiny' are used in this example.

For 'hono/quick':

```ts twoslash
import { Hono } from 'hono/quick'

this.router = new SmartRouter({
  routers: [new LinearRouter(), new TrieRouter()],
})
ts twoslash
import { Hono } from 'hono/tiny'

this.router = new PatternRouter()
```

The 'hono/quick' preset uses a SmartRouter with LinearRouter and TrieRouter. The 'hono/tiny' preset uses a PatternRouter.

Choose the preset based on the specific needs of your application. The 'hono/quick' preset is suitable for more complex routing needs, while the 'hono/tiny' preset is suitable for simpler routing needs.

- Hono Documentation

- Creating a web application with different routing needs.

#### Code Snippet

```typescript

For 'hono/tiny':

```

**Reasoning:** This rule is important as it demonstrates how to use different presets in Hono framework. It shows how to import and use different routers in Hono, specifically the 'hono/quick' and 'hono/tiny' presets. Understanding this rule helps in choosing the right preset based on the specific needs of the application.

*Source: docs/api/presets.md*

## Helpers

### Defining Routes and Generating Static Site Content in Hono

This code snippet demonstrates how to define routes in a Hono application and how to use the 'toSSG' function to generate static site content.

```tsx
// index.tsx
const app = new Hono()

app.get('/', (c) => c.html('Hello, World!'))
app.use('/about', async (c, next) => {
  c.setRenderer((content, head) => {
    return c.html(
      <html>
        <head>
          <title>{head.title ?? ''}</title>
        </head>
        <body>
          <p>{content}</p>
        </body>
      </html>
    )
  })
  await next()
})
app.get('/about', (c) => {
  return c.render('Hello!', { title: 'Hono SSG Page' })
})

export default app
```

1. A new Hono application is created.
2. The root route ('/') is defined to return a simple HTML string.
3. A middleware is added to the '/about' route that sets a custom renderer. This renderer wraps the content in a basic HTML structure and uses the 'head.title' property for the page title.
4. The '/about' route is defined to render a string with a title.
5. The application is then exported for use in other modules.

- The 'toSSG' function is used to generate static site content. It takes the Hono application and a file system module as arguments.

- [Hono documentation](https://hono.bayfront.cloud/)

- Building static websites or blogs with Hono.
- Defining custom renderers for specific routes.

**Reasoning:** This rule is important as it demonstrates how to define routes in a Hono application and how to use the 'toSSG' function to generate static site content. It also shows how to use middleware to set a custom renderer for a specific route.

*Source: docs/helpers/ssg.md*

### Using Hono's Static Site Generation (SSG) Feature

This code snippet demonstrates how to use Hono's static site generation (SSG) feature to pre-render pages at build time.

```ts
// build.ts
import app from './index'
import { toSSG } from 'hono/ssg'
import fs from 'fs/promises'

toSSG(app, fs)
```

1. Import the application from the index file.
2. Import the `toSSG` function from 'hono/ssg'.
3. Import 'fs/promises' for file system operations.
4. Call the `toSSG` function with the application and the file system module as arguments.

- The `toSSG` function pre-renders the pages at build time, improving performance and SEO.
- The output files will be HTML files corresponding to the routes defined in the application.

- [Hono Documentation](https://hono.dev/docs)

- Pre-rendering pages for static site generation in Hono applications.

**Reasoning:** This rule is important as it demonstrates how to use Hono's static site generation (SSG) feature to pre-render pages at build time. This is particularly useful for improving performance and SEO of Hono applications.

*Source: docs/helpers/ssg.md*

### Generating Static Site Files with Hono's 'toSSG' Function

The 'toSSG' function in Hono is used to generate static site files. Here is a code snippet demonstrating its usage:

```ts
// build.ts
import app from './index'
import { toSSG } from 'hono/ssg'
import fs from 'fs/promises'

toSSG(app, fs)
bash
ls ./static
about.html  index.html
```

1. The 'toSSG' function is imported from the 'hono/ssg' module.
2. The function is then applied to an app, along with the file system module.
3. The function generates static site files from the app and writes them to the file system.

- The 'toSSG' function is part of the Hono framework, which is designed for building server-rendered JavaScript apps.
- The function generates static site files, which can be served by any static file server.

- [Hono GitHub](https://github.com/honojs/hono)

- Generating static site files for a server-rendered JavaScript app.

#### Code Snippet

```typescript

When this script is executed, it outputs the files as follows:

```

**Reasoning:** This rule is important as it demonstrates how to use the 'toSSG' function from the Hono framework to generate static site files. It shows the process of importing the function, applying it to an app, and using the file system module to write the static files. The rule also highlights the output of the process, which is the creation of HTML files in the static directory.

*Source: docs/helpers/ssg.md*

### Defining the toSSG Function Interface in Hono

The `toSSG` function in Hono is used for generating static sites. It takes an application, a filesystem module, and an optional options object as arguments. The correct way to define this function in TypeScript is by using an interface, as shown in the following code snippet:

```ts
export interface ToSSGInterface {
  (
    app: Hono,
    fsModule: FileSystemModule,
    options?: ToSSGOptions
  ): Promise<ToSSGResult>
}
```

In this interface:

- `app` specifies `new Hono()` with registered routes.
- `fsModule` is an object that represents the filesystem module, assuming `node:fs/promise`.
- `options` is an optional object that can be used to specify additional options for the function.

The function returns a promise that resolves with a `ToSSGResult` object.

- Defining the function in this way allows TypeScript's static type checking to ensure the function is used correctly.

- [Hono Documentation](https://hono.bespokejs.com)

- Generating static sites with Hono.

**Reasoning:** This rule is important as it demonstrates how to define an interface for the toSSG function in Hono, which is used for generating static sites. It shows the correct way to define the function parameters and their types, which is crucial for TypeScript's static type checking and for ensuring the function is used correctly.

*Source: docs/helpers/ssg.md*

### Defining and Using the FileSystemModule Interface in Hono

In Hono, the FileSystemModule interface is used to define methods for file operations. It includes methods for writing data to a file and creating a directory.

Here is a code snippet demonstrating this:

```ts
export interface FileSystemModule {
  writeFile(path: string, data: string | Uint8Array): Promise<void>
  mkdir(
    path: string,
    options: { recursive: boolean }
  ): Promise<void | string>
}
```

1. The `writeFile` method takes a path and data (either a string or Uint8Array) as arguments and returns a Promise that resolves to void. This method is used to write data to a file at the specified path.

2. The `mkdir` method takes a path and an options object as arguments and returns a Promise that resolves to either void or a string. This method is used to create a directory at the specified path. The options object has a `recursive` property which, when set to true, allows for the creation of directories recursively.

- These methods return Promises, so they are asynchronous and should be handled accordingly.

- [Hono Documentation](https://hono.bun.js.org/)

- Writing data to a file
- Creating a directory

**Reasoning:** This rule is important as it demonstrates how to define and use the FileSystemModule interface in Hono. It shows the methods that need to be implemented for file operations, which are writeFile and mkdir. This is crucial for any operations that involve reading from or writing to the file system.

*Source: docs/helpers/ssg.md*

### Using 'toSSG' function in Hono for Deno and Bun

This code snippet demonstrates how to use the 'toSSG' function provided by Hono for different file systems like Deno and Bun.

```ts
import { toSSG } from 'hono/deno'

toSSG(app) // The second argument is an option typed 'ToSSGOptions'.
```

1. The 'toSSG' function is imported from 'hono/deno' for Deno and 'hono/bun' for Bun.
2. The function is then called with the 'app' argument. The second argument is an option typed 'ToSSGOptions'.

- The 'toSSG' function is specific to the file system being used. Make sure to import it from the correct module.
- The second argument to the 'toSSG' function is optional and should be of type 'ToSSGOptions'.

- Hono documentation: [link]

- When you want to use SSG on Deno or Bun with Hono, you can use the 'toSSG' function as demonstrated in the code snippet.

**Reasoning:** This rule is important as it demonstrates how to use the 'toSSG' function provided by Hono for different file systems like Deno and Bun. It shows the correct way to import and use the function, and highlights that the second argument is an option typed 'ToSSGOptions'. Understanding this rule is crucial for developers who want to use SSG on Deno or Bun with Hono.

*Source: docs/helpers/ssg.md*

### Using the `toSSG` function in Hono

In Hono, a `toSSG` function is provided for each file system. This function is used to convert an application into a static site generator.

For Deno:

```ts
import { toSSG } from 'hono/deno'

toSSG(app) // The second argument is an option typed `ToSSGOptions`.
ts
import { toSSG } from 'hono/bun'

toSSG(app) // The second argument is an option typed `ToSSGOptions`.
```

The `ToSSGOptions` interface specifies the options for the `toSSG` function. These options include `dir`, `concurrency`, `beforeRequestHook`, and `afterResponse`.

The `toSSG` function takes two arguments: the application and an options object. The options object is typed `ToSSGOptions` and can include various properties to customize the behavior of the static site generator.

- The `toSSG` function is specific to the Hono framework and may not work in other frameworks.

- [Hono Documentation](https://hono.io/docs)

- Converting a dynamic Hono application into a static site for improved performance and security.

#### Code Snippet

```typescript

For Bun:

```

**Reasoning:** This rule is important as it demonstrates how to use the `toSSG` function in Hono framework for both Deno and Bun. The `toSSG` function is used to convert an application into a static site generator. Understanding how to use this function is crucial for developers who want to leverage the benefits of static site generation in their Hono applications.

*Source: docs/helpers/ssg.md*

### Configuring the 'toSSG' function in Hono

The 'toSSG' function is used to generate static sites. It accepts an application instance and an optional 'ToSSGOptions' object as arguments. The 'ToSSGOptions' interface allows developers to customize the static site generation process.

Here is the 'ToSSGOptions' interface:

```ts
export interface ToSSGOptions {
  dir?: string
  concurrency?: number
  beforeRequestHook?: BeforeRequestHook
  afterResponseHook?: AfterResponseHook
  afterGenerateHook?: AfterGenerateHook
  extensionMap?: Record<string, string>
}
ts
import { toSSG } from 'hono/bun'

toSSG(app, {
  dir: './public',
  concurrency: 5,
  beforeRequestHook: () => console.log('Before request'),
  afterResponseHook: () => console.log('After response'),
  afterGenerateHook: () => console.log('After generate'),
  extensionMap: { '.html': 'text/html' }
})
```

In this example, the static site will be generated in the './public' directory, with a concurrency of 5. The specified hooks will log messages at different stages of the generation process, and '.html' files will be served with the 'text/html' MIME type.

#### Code Snippet

```typescript

- `dir`: Specifies the output destination for static files. Default is `./static`.
- `concurrency`: Specifies the concurrent number of files to be generated at the same time. Default is `2`.
- `beforeRequestHook`, `afterResponseHook`, `afterGenerateHook`: These are optional hooks that can be used to perform actions before a request is made, after a response is received, and after a file is generated, respectively.
- `extensionMap`: An optional object that maps file extensions to their MIME types.

### Usage

```

**Reasoning:** This rule is important as it demonstrates how to use the 'toSSG' function in Hono framework, specifically how to configure the options for the 'ToSSGOptions' interface. Understanding these options allows developers to customize the static site generation process according to their specific needs.

*Source: docs/helpers/ssg.md*

### Defining TypeScript Interface for Function Results in Hono

In Hono, it's common to define TypeScript interfaces for the results of functions. This helps with type checking and ensures that the function returns the correct data structure. Here's an example of how to define an interface for the result of the 'toSSG' function.

```ts
export interface ToSSGResult {
  success: boolean
  files: string[]
  error?: Error
}
```

In this code snippet:

- `success` is a boolean indicating whether the operation was successful.
- `files` is an array of strings, representing the files processed.
- `error` is an optional field of type Error, which will be defined if there was an error during the operation.

- The `error` field is optional (`error?`). This means it does not have to be included in the objects that implement this interface.

- [TypeScript Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)

- Defining the expected return type of a function in TypeScript.

**Reasoning:** This rule is important as it demonstrates how to define an interface in TypeScript for the result of the 'toSSG' function in Hono. The interface 'ToSSGResult' includes a boolean 'success' field, a 'files' field which is an array of strings, and an optional 'error' field of type Error. This pattern is crucial in TypeScript for type checking and ensuring the correct data structure is returned by functions.

*Source: docs/helpers/ssg.md*

### Defining and Using Hooks in Hono

In Hono, you can customize the process of `toSSG` by specifying custom hooks in options. These hooks are functions that get called at different stages of the request-response lifecycle.

Here is how you can define these hooks:

```ts
export type BeforeRequestHook = (req: Request) => Request | false
export type AfterResponseHook = (res: Response) => Response | false
export type AfterGenerateHook = (
  result: ToSSGResult
) => void | Promise<void>
```

The `BeforeRequestHook` is called before a request is made. It receives the request object as a parameter and should return the modified request object or `false` to cancel the request.

The `AfterResponseHook` is called after a response is received. It receives the response object as a parameter and should return the modified response object or `false` to cancel the response.

The `AfterGenerateHook` is called after the static site files have been generated. It receives the `ToSSGResult` object as a parameter and should return `void` or a `Promise` that resolves to `void`.

- Hooks are a powerful feature that allow you to customize the behavior of Hono. However, they should be used with care as they can also introduce complexity and potential issues.

- [Hono Documentation](https://hono.beyondco.de/docs/hooks)

- Modifying requests or responses
- Performing actions after the generation of static site files

**Reasoning:** This rule is important as it demonstrates how to define and use hooks in Hono. Hooks are a powerful feature that allow developers to customize the process of `toSSG` by specifying custom functions that get called at different stages of the request-response lifecycle. This can be used to modify requests and responses, or to perform actions after the generation of static site files.

*Source: docs/helpers/ssg.md*

### Filtering Requests Using Hooks in Hono

This code snippet demonstrates how to use hooks in Hono to filter requests. Specifically, it uses the 'beforeRequestHook' to filter out all non-GET requests.

```ts
toSSG(app, fs, {
  beforeRequestHook: (req) => {
    if (req.method === 'GET') {
      return req
    }
    return false
  },
})
```

The 'beforeRequestHook' is a function that is called before each request is processed. If the function returns false, the request is not processed.

In this case, the function checks if the request method is 'GET'. If it is, the request is processed. If it's not, the request is not processed.

- The 'beforeRequestHook' can be used to filter requests based on any criteria, not just the request method.

- [Hono Documentation](https://hono.bike/docs/hooks/)

- Logging only GET requests
- Preventing certain types of requests from being processed

**Reasoning:** This rule is important as it demonstrates how to filter requests in the Hono framework using hooks. In this case, the 'beforeRequestHook' is used to filter out all non-GET requests, which can be useful in scenarios where only GET requests need to be processed or logged.

*Source: docs/helpers/ssg.md*

### Filtering Responses by Status Code Using afterResponseHook in Hono

This code snippet demonstrates how to use the 'afterResponseHook' in Hono's 'toSSG' function to filter responses based on their status codes.

```ts
toSSG(app, fs, {
  afterResponseHook: (res) => {
    if (res.status === 200 || res.status === 500) {
      return res
    }
    return false
  },
})
```

In this example, the 'afterResponseHook' function is used to check the status code of each response. If the status code is either 200 or 500, the response is returned and processed further. If the status code is anything else, the function returns 'false', effectively filtering out the response.

This can be useful in scenarios where only certain responses are needed for static site generation, such as only successful responses (status code 200) or server error responses (status code 500).

- The 'afterResponseHook' function is called after each response is received, but before it is processed by 'toSSG'.
- The 'afterResponseHook' function should return the response if it should be processed further, or 'false' if it should be filtered out.

- [Hono Documentation](https://hono.bjacobel.com/docs)

- Filtering responses by status code for static site generation
- Logging or handling specific types of responses separately

**Reasoning:** This rule is important as it demonstrates how to use the 'afterResponseHook' in Hono's 'toSSG' function to filter responses based on their status codes. This can be useful in scenarios where only certain responses are needed for static site generation, such as only successful responses (status code 200) or server error responses (status code 500).

*Source: docs/helpers/ssg.md*

### Using afterGenerateHook in Hono

The `afterGenerateHook` is a feature in Hono that allows you to execute additional logic after the `toSSG` function has run. This can be useful for logging, debugging, or other post-processing tasks.

Here is an example of how to use it:

```ts
toSSG(app, fs, {
  afterGenerateHook: (result) => {
    if (result.files) {
      result.files.forEach((file) => console.log(file))
    }
  }
})
```

In this example, if the `result` object contains a `files` array, it logs each file to the console.

- The `afterGenerateHook` function is called after the `toSSG` function has completed.
- The `result` object passed to the `afterGenerateHook` function contains the result of the `toSSG` function.

- [Hono Documentation](https://hono.bespokejs.com)

- Logging the result of the `toSSG` function for debugging purposes.
- Performing additional post-processing on the `result` object.

**Reasoning:** This rule is important as it demonstrates how to use the 'afterGenerateHook' in Hono. This hook allows developers to execute additional logic after the 'toSSG' function has run, which is useful for logging, debugging, or other post-processing tasks.

*Source: docs/helpers/ssg.md*

### Customizing File Extensions in Hono's Static Site Generator

This code snippet demonstrates how to customize the file extensions in Hono's SSG based on the `Content-Type` returned by each route.

```ts
import { toSSG, defaultExtensionMap } from 'hono/ssg'

// Save `application/x-html` content with `.html`
toSSG(app, fs, {
  extensionMap: {
    'application/x-html': 'html',
    ...defaultExtensionMap,
  },
})
```

The `toSSG` function is used to configure the SSG. The `extensionMap` option is set to map the `Content-Type` 'application/x-html' to the '.html' extension. The `defaultExtensionMap` is spread into the `extensionMap` to include the default mappings.

Paths ending with a slash are saved as index.ext regardless of the extension.

- [Hono Documentation](https://hono.bevry.me/docs/ssg)

- Serving different types of content in a static website
- Customizing file extensions for specific content types

**Reasoning:** This rule is important as it demonstrates how to customize file extensions in Hono's static site generator (SSG) based on the `Content-Type` returned by each route. This is crucial for serving different types of content correctly in a static website.

*Source: docs/helpers/ssg.md*

### Defining Routes in Hono to Return HTML and Text Responses

This rule demonstrates how to define routes in Hono that return HTML and text responses. The 'get' method is used to handle HTTP GET requests to specific paths ('/html/' and '/text/'), and the 'html' and 'text' methods are used to send responses of different types.

```ts
// save to ./static/html/index.html
app.get('/html/', (c) => c.html('html'))

// save to ./static/text/index.txt
app.get('/text/', (c) => c.text('text'))
```

1. The 'get' method is used to define a route that handles HTTP GET requests. The first argument is the path, and the second argument is a callback function that is executed when the route is matched.

2. The callback function takes a context object 'c' as an argument. This object contains information about the HTTP request and has methods for sending a response.

3. The 'html' and 'text' methods of the context object are used to send HTML and text responses, respectively.

- The paths in the 'get' method calls end with a slash. This means that the routes will match requests to '/html/' and '/text/', but not to '/html' and '/text'.

- The 'html' and 'text' methods automatically set the correct 'Content-Type' HTTP header in the response ('text/html' and 'text/plain', respectively).

- [Hono Documentation](https://hono.boutell.com/)

- Use the 'html' method to send an HTML response when you want to render a web page.

- Use the 'text' method to send a text response when you want to send plain text data, for example, as a response to an API request.

**Reasoning:** This rule is important as it demonstrates how to define routes in Hono that return HTML and text responses. It also shows how to use the 'get' method to handle HTTP GET requests to specific paths ('/html/' and '/text/') and how to use the 'html' and 'text' methods to send responses of different types. Understanding this rule is crucial for creating dynamic web applications with Hono.

*Source: docs/helpers/ssg.md*

### Using Built-in Middleware for Static Site Generation in Hono

In Hono, you can use built-in middleware for static site generation (SSG). This is particularly useful when you want to pre-render pages at build time for performance benefits.

Here's an example of how to use the `ssgParams` middleware to generate static parameters for a route:

```ts
app.get(
  '/shops/:id',
  ssgParams(async () => {
    const shops = await getShops()
    return shops.map((shop) => ({ id: shop.id }))
  }),
  async (c) => {
    const shop = await getShop(c.req.param('id'))
    if (!shop) {
      return c.notFound()
    }
    return c.render(
      <div>
        <h1>{shop.name}</h1>
      </div>
    )
  }
)
```

In this code snippet:

1. The `ssgParams` middleware is used to generate static parameters for the route '/shops/:id'. It fetches a list of shops and returns an array of objects, each containing an `id` property.

2. In the route handler, it fetches the shop with the requested `id` and renders a response. If the shop is not found, it returns a 404 response.

This approach allows you to generate static pages for each shop at build time, improving the performance of your application.

**Important notes:**

- The `ssgParams` middleware is similar to the `generateStaticParams` API in Next.js.
- Routes with the `disableSSG` middleware set are excluded from static file generation.

**Common use cases:**

- Pre-rendering pages at build time for performance benefits.
- Handling routes with dynamic parameters.

**References:**

- [Hono documentation](https://hono.dev/docs)
- [Next.js documentation](https://nextjs.org/docs)

**Reasoning:** This rule is important as it demonstrates how to use the built-in middleware in Hono for static site generation (SSG). It shows how to use the `ssgParams` middleware to generate static parameters for a route, similar to the `generateStaticParams` API in Next.js. It also shows how to handle routes with dynamic parameters and how to render a response based on the fetched data.

*Source: docs/helpers/ssg.md*

### Using disableSSG Middleware to Exclude Routes from Static File Generation in Hono

In Hono, the `disableSSG` middleware is used to exclude certain routes from static file generation by `toSSG`. This is particularly useful for routes that should not be statically generated, such as API endpoints.

Here is an example of how to use it:

```ts
app.get('/api', disableSSG(), (c) => c.text('an-api'))
```

In this code snippet, the route '/api' is set to be excluded from static file generation. This means that when `toSSG` is executed, this route will not be included in the generated static files.

- The `disableSSG` middleware should be used sparingly, as it can lead to performance issues if used excessively.

- [Hono Documentation](https://hono.boutique/docs)

- Excluding API endpoints from static file generation
- Excluding routes that require dynamic content from static file generation

**Reasoning:** This rule is important as it demonstrates how to use the `disableSSG` middleware in Hono to exclude certain routes from static file generation by `toSSG`. This is useful when you have routes that should not be statically generated, such as API endpoints.

*Source: docs/helpers/ssg.md*

### Using onlySSG Middleware to Serve Static Pages in Hono

This code snippet demonstrates how to use the 'onlySSG' middleware in Hono to serve static pages.

```ts
app.get('/static-page', onlySSG(), (c) => c.html(<h1>Welcome to my site</h1>))
```

In this example, the '/static-page' route is defined with the 'onlySSG' middleware. This means that this route will only be available during the static site generation process. If a request is made to this route outside of this process, the 'c.notFound()' method will be called, returning a 'not found' error.

- The 'onlySSG' middleware is useful for pages that should only be statically generated and not served dynamically.

- [Hono Documentation](https://hono.bayfront.cloud/)

- Serving static pages that should not be available dynamically.

**Reasoning:** This rule is important as it demonstrates how to use the 'onlySSG' middleware in Hono to serve static pages. It shows how to define a route that will only be available during the static site generation process and will return a 'not found' error at other times. This is useful for pages that should only be statically generated and not served dynamically.

*Source: docs/helpers/ssg.md*

### Handling Accept Headers with Hono's Accepts Helper

The Accepts Helper in Hono is used to handle Accept headers in requests. This is crucial in web development as it helps the server understand what type of content the client can handle.

```ts
import { Hono } from 'hono'
import { accepts } from 'hono/accepts'
```

The `accepts()` function looks at the Accept header, such as Accept-Encoding and Accept-Language, and returns the proper value.

- The Accepts Helper is a part of the Hono framework and must be imported from 'hono/accepts'.
- The Accepts Helper is typically used in the context of a GET request.

- Hono Documentation

- When the server needs to understand what type of content the client can handle, the Accepts Helper can be used.

**Reasoning:** The Accepts Helper in Hono is important as it allows the handling of Accept headers in requests. This is crucial in web development as it helps the server understand what type of content the client can handle. This rule demonstrates how to import and use the Accepts Helper in Hono.

*Source: docs/helpers/accepts.md*

### Handling Accept Headers with Hono's 'accepts' Function

The 'accepts' function in Hono is used to handle different Accept headers in a request. It looks at the specified Accept header and returns the proper value based on the supported values and a default value.

Here is a code snippet demonstrating its usage:

```ts
import { accepts } from 'hono/accepts'

app.get('/', (c) => {
  const accept = accepts(c, {
    header: 'Accept-Language',
    supports: ['en', 'ja', 'zh'],
    default: 'en',
  })
  return c.json({ lang: accept })
})
```

In this example, the 'accepts' function is used to handle the 'Accept-Language' header. It supports 'en', 'ja', and 'zh' languages, with 'en' as the default language.

This function is crucial for handling internationalization and different content types in a web application. It allows the application to respond appropriately based on the client's preferences.

- The 'accepts' function should be used in the route handler, as it needs the context 'c' which contains the request and response objects.

- [Hono documentation](https://hono.beyondco.de/docs/helpers/accepts)

- Handling different languages in a web application
- Handling different content types in a web application

**Reasoning:** This rule is important as it demonstrates how to use the 'accepts' function from Hono to handle different Accept headers in a request. It shows how to specify the header, the supported values, and a default value. This is crucial for handling internationalization and different content types in a web application.

*Source: docs/helpers/accepts.md*

### Defining AcceptHeader Type in Hono

In Hono, you can define an `AcceptHeader` type to specify the types of accept headers your application can handle. This is done using TypeScript's union type (`|`), which allows you to define a type that can be one of several types.

Here is an example of how to define an `AcceptHeader` type:

```ts
export type AcceptHeader =
  | 'Accept'
  | 'Accept-Charset'
  | 'Accept-Encoding'
  | 'Accept-Language'
  | 'Accept-Patch'
  | 'Accept-Post'
  | 'Accept-Ranges'
```

When you define a variable of type `AcceptHeader`, it can only be assigned one of the specified values. If you try to assign a value that is not in the list, TypeScript will throw a compile-time error.

- The `AcceptHeader` type definition is not limited to the values shown in the example. You can add or remove values as needed for your application.

- [TypeScript Union Type](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#union-types)

- Use the `AcceptHeader` type when you need to work with accept headers in your application, to ensure that only valid headers are used.

**Reasoning:** This rule is important as it demonstrates how to define an AcceptHeader type in Hono. Accept headers are used in HTTP requests to tell the server what content types the client can handle. By defining the AcceptHeader type, we ensure that only valid accept headers are used in our application, reducing the chance of errors.

*Source: docs/helpers/accepts.md*

### Importing and Using the 'css' Module from Hono

This code snippet demonstrates how to import and use the 'css' module from the 'hono' library in TypeScript.

```ts
import { Hono } from 'hono'
import { css, cx, keyframes, Style } from 'hono/css'
```

The 'css' module allows developers to write CSS in a template literal. The return value of 'css' will be the class name, which can then be set to the value of the class attribute in your components. The '<Style />' component will then contain the value of the CSS.

- The 'css' module is marked as 'Experimental'. This means that it is still under development and may change in future versions of Hono.

- [Hono Documentation](https://hono.brontosaurusrex.com/)

- Styling components in a more JavaScript-centric way.
- Managing styles in a single place, making it easier to maintain and update the styles of your application.

**Reasoning:** This rule is important as it demonstrates how to import and use the 'css' module from the 'hono' library in TypeScript. The 'css' module allows developers to write CSS in a template literal, which can then be used as a class name in the application. This is a key feature of the Hono framework, enabling developers to manage styles in a more JavaScript-centric way.

*Source: docs/helpers/css.md*

### Styling Pseudo-classes in Hono

In Hono, you can style pseudo-classes like `:hover` by using the nesting selector, `&`.

Here is an example:

```ts
const buttonClass = css`
  background-color: #fff;
  &:hover {
    background-color: red;
  }
`
```

In this code snippet, the `&` symbol represents the current selector. So, `&:hover` is equivalent to `.buttonClass:hover` in regular CSS. When the user hovers over an element with the `buttonClass` class, the background color changes to red.

- The `&` symbol can be used to reference the current selector in other contexts as well, not just pseudo-classes.

- [Nesting selector - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Nesting_selector)

- Changing the color of a button when the user hovers over it
- Displaying a dropdown menu when the user hovers over a navigation item

**Reasoning:** This rule is important as it demonstrates how to style pseudo-classes like `:hover` in Hono using the nesting selector `&`. This is a common practice in CSS-in-JS libraries, and it's crucial for developers to understand how to use it to create interactive styles in their applications.

*Source: docs/helpers/css.md*

### Using Nesting Selectors and Extending CSS in Hono

In Hono, you can use the nesting selector, `&`, to define styles that should apply under certain conditions. For example, you can define a hover style for a button like this:

```ts
const buttonClass = css`
  background-color: #fff;
  &:hover {
    background-color: red;
  }
`
tsx
const baseClass = css`
  color: white;
  background-color: blue;
`

const header1Class = css`
  ${baseClass}
  font-size: 3rem;
`

const header2Class = css`
  ${baseClass}
  font-size: 2rem;
`
```

In this snippet, both `header1Class` and `header2Class` will have the styles defined in `baseClass`, but with different font sizes.

- The `&` symbol refers to the parent selector.
- You can embed a class name to extend its styles.

- [Nesting selector](https://developer.mozilla.org/en-US/docs/Web/CSS/Nesting_selector)

- Defining hover, active, focus, etc. styles for an element.
- Creating base styles that can be extended and customized for different elements.

#### Code Snippet

```typescript

In this snippet, the `&:hover` means 'when this element is hovered over'. The `&` refers to the parent selector, in this case the button.

You can also extend the CSS definition by embedding the class name. This is useful when you want to apply a base style to multiple elements, but with some variations. For example:

```

**Reasoning:** This rule is important as it demonstrates how to use the nesting selector and how to extend CSS definitions in Hono. This is a common practice in CSS-in-JS libraries to keep your code DRY (Don't Repeat Yourself) and to maintain a consistent style across your application.

*Source: docs/helpers/css.md*

### Reusing and Nesting CSS Classes in Hono

This code snippet demonstrates how to reuse and nest CSS classes in Hono. This is done by defining a base class and then using it in other classes. The syntax `${baseClass} {}` is used to nest classes.

```tsx
const baseClass = css`
  color: white;
  background-color: blue;
`

const header1Class = css`
  ${baseClass}
  font-size: 3rem;
`

const header2Class = css`
  ${baseClass}
  font-size: 2rem;
`

const headerClass = css`
  color: white;
  background-color: blue;
`

const containerClass = css`
  ${headerClass} {
    h1 {
      font-size: 3rem;
    }
  }
`
```

The base class is defined with the `css` function. This class is then used in other classes with the `${baseClass}` syntax. This allows the properties of the base class to be reused in other classes. The `${baseClass} {}` syntax is used to nest classes, allowing for hierarchical structuring of CSS.

- Changes to the base class will propagate to all classes that use it, promoting code maintainability.
- Nesting classes can make the code easier to understand and manage.

- [Hono Documentation](https://hono.bokuweb.me/)

- When you want to reuse CSS properties across multiple classes.
- When you want to structure your CSS in a hierarchical manner.

**Reasoning:** This rule is important as it demonstrates how to reuse and nest CSS classes in Hono. This promotes code reusability and maintainability, as changes to the base class will propagate to all classes that use it. It also shows how to structure CSS in a hierarchical manner, which can make the code easier to understand and manage.

*Source: docs/helpers/css.md*

### Defining Global Styles in Hono

In Hono, you can define global styles using the `:-hono-global` pseudo-selector. This is useful when you want to apply a certain style to all elements of a particular type, regardless of their location in the document tree.

Here is a code snippet demonstrating this:

```tsx
const globalClass = css`
  :-hono-global {
    html {
      font-family: Arial, Helvetica, sans-serif;
    }
  }
`

return c.render(
  <div class={globalClass}>
    <h1>Hello!</h1>
    <p>Today is
```

In this snippet, the `:-hono-global` pseudo-selector is used to define a global style that sets the font-family of all html elements to Arial, Helvetica, sans-serif.

- The `:-hono-global` pseudo-selector can only be used within the `css` tagged template literal.
- The styles defined within the `:-hono-global` block will be applied globally, affecting all matching elements in the document.

- [Hono Documentation](https://hono.io/docs)

- Setting a global font-family or font-size.
- Applying a global background color or text color.

**Reasoning:** This rule is important as it demonstrates how to define global styles in Hono using the `:-hono-global` pseudo-selector. This is useful when you want to apply a certain style to all elements of a particular type, regardless of their location in the document tree.

*Source: docs/helpers/css.md*

### Using `keyframes` in Hono for Animations

In Hono, you can use `keyframes` to write the contents of `@keyframes`. This is useful for creating animations. In the given code snippet, `fadeInAnimation` is the name of the animation.

```tsx
const fadeInAnimation = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`
const headerClass = css`
  animation-name: ${fadeInAnimation};
  animation-duration: 2s;
`
```

1. Define the `keyframes` with the desired animation. Here, the `fadeInAnimation` changes the opacity from 0 to 1.
2. Use the defined `keyframes` in your CSS with the `animation-name` property.
3. Set the `animation-duration` property to determine how long the animation should take.

- The `keyframes` feature in Hono is marked as experimental. It may change in future releases.

- [Hono Documentation](https://hono.bespokejs.com)

- Use `keyframes` to create animations for page transitions, loading spinners, and hover effects.

**Reasoning:** This rule is important as it demonstrates how to use `keyframes` in Hono to create animations. Animations can greatly enhance the user experience by providing visual feedback, guiding tasks, and offering a smooth transition.

*Source: docs/helpers/css.md*

### Compositing Class Names with `cx` in Hono

In Hono, you can use the `cx` function to composite multiple class names. This is useful when you want to apply multiple styles to a single element, and those styles are defined in separate classes.

Here is a code snippet demonstrating this:

```tsx
const buttonClass = css`
  border-radius: 10px;
`
const primaryClass = css`
  background: orange;
`
const Button = () => (
  <a class={cx(buttonClass, primaryClass)}>Click!</a>
)
```

In this example, the `Button` component has two classes applied to it: `buttonClass` and `primaryClass`. The `cx` function composites these two classes, allowing the button to have both a border radius and an orange background.

- The `cx` function is experimental and may change in future versions of Hono.

- [Hono Documentation](https://hono.brontosaurusrex.com/)

- Applying multiple styles to a single element
- Compositing classes to create complex styles

**Reasoning:** This rule is important as it demonstrates how to use the `cx` function in Hono to composite multiple class names. This is useful when you want to apply multiple styles to a single element, and those styles are defined in separate classes.

*Source: docs/helpers/css.md*

### CSS Class Composition in Hono

This code snippet demonstrates how to define and apply CSS styles to components in Hono. It also shows how to use the `cx` function to apply multiple classes to a component and to compose simple strings.

```tsx
const buttonClass = css`
  border-radius: 10px;
`
const primaryClass = css`
  background: orange;
`
const Button = () => (
  <a class={cx(buttonClass, primaryClass)}>Click!</a>
)
tsx
const Header = () => <a class={cx('h1', primaryClass)}>Hi</a>
```

In this case, the `cx` function is used to apply the 'h1' string and the `primaryClass` to the `Header` component.

- The `cx` function is a powerful tool for applying multiple classes or composing strings in Hono.
- The `css` function is used to define CSS classes in Hono.

- [Hono Documentation](https://hono.bike/docs)

- Styling components in Hono
- Applying multiple classes to a component
- Composing simple strings

#### Code Snippet

```typescript

In the above code, `buttonClass` and `primaryClass` are CSS classes defined using the `css` function. The `cx` function is then used to apply both classes to the `Button` component.

The `cx` function can also be used to compose simple strings, as shown below:

```

**Reasoning:** This rule is important as it demonstrates how to use css in Hono to define and apply styles to components. It shows how to define css classes and how to apply multiple classes to a component using the cx function. It also shows that the cx function can be used to compose simple strings.

*Source: docs/helpers/css.md*

### Using CSS Helpers with Secure Headers Middleware in Hono

This code snippet demonstrates how to use css helpers in combination with the Secure Headers middleware in Hono. It shows how to add the 'nonce' attribute to the 'Style' component to avoid Content-Security-Policy issues caused by the css helpers.

```tsx
<Style nonce={c.get('secureHeadersNonce')} />
```

The 'nonce' attribute is a security feature that can be used to make a whitelist of trusted sources of content. By adding this attribute to the 'Style' component, you can ensure that the css helpers are trusted and will not cause Content-Security-Policy issues.

- The 'nonce' attribute should be a base64-encoded random value that changes for each HTTP request.

- [Secure Headers Middleware](/docs/middleware/builtin/secure-headers)
- [Nonce Attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce)

This pattern is commonly used when you want to use css helpers in your Hono application and need to ensure that they do not cause security issues.

**Reasoning:** This rule is important as it demonstrates how to use css helpers in combination with the Secure Headers middleware in Hono. It shows how to add the 'nonce' attribute to the 'Style' component to avoid Content-Security-Policy issues caused by the css helpers. This is crucial for maintaining the security of the application and ensuring that the css helpers function correctly.

*Source: docs/helpers/css.md*

### Managing Cookies in Hono Framework

This code demonstrates how to manage cookies in Hono framework using the cookie helper functions.

```ts
import { Hono } from 'hono'
import {
  getCookie,
  getSignedCookie,
  setCookie,
  setSignedCookie,
  deleteCookie,
} from 'hono/cookie'
```

1. Import the Hono framework and the cookie helper functions.
2. Use the `setCookie` function to set a cookie. It takes three arguments: the context, the cookie name, and the cookie value.
3. Use the `getCookie` function to retrieve a cookie. It takes two arguments: the context and the cookie name.
4. Use the `deleteCookie` function to delete a cookie. It takes two arguments: the context and the cookie name.

- The `getSignedCookie` and `setSignedCookie` functions are used for signed cookies, which are a type of cookie that have a signature, so they can't be tampered with.

- [Hono documentation](https://hono.bayfrontcloud.com/docs)

- Managing session data
- Storing user preferences

**Reasoning:** This rule is important as it demonstrates how to manage cookies in Hono framework. It shows how to import and use the cookie helper functions such as getCookie, setCookie, and deleteCookie. Understanding this rule is crucial for developers to manage session data and user preferences, which are common use cases for cookies.

*Source: docs/helpers/cookie.md*

### Handling Cookies in Hono

This rule demonstrates how to handle cookies in Hono framework. The operations include setting, getting, and deleting cookies.

```ts
import { Hono } from 'hono'
import {
  getCookie,
  getSignedCookie,
  setCookie,
  setSignedCookie,
  deleteCookie,
} from 'hono/cookie'

app.get('/cookie', (c) => {
  setCookie(c, 'cookie_name', 'cookie_value')
  const yummyCookie = getCookie(c, 'cookie_name')
  deleteCookie(c, 'cookie_name')
  const allCookies = getCookie(c)
  // ...
})
```

In the above code:

- `setCookie(c, 'cookie_name', 'cookie_value')` sets a cookie with the name 'cookie_name' and value 'cookie_value'.
- `getCookie(c, 'cookie_name')` retrieves the value of the cookie named 'cookie_name'.
- `deleteCookie(c, 'cookie_name')` deletes the cookie named 'cookie_name'.
- `getCookie(c)` retrieves all cookies.

Note: The 'c' parameter represents the context of the request.

Common use cases include maintaining user sessions, tracking user behavior, etc.

**Reasoning:** This rule is important as it demonstrates how to handle cookies in Hono framework. It covers how to set, get, and delete regular cookies, which are common operations in web development for maintaining user sessions, tracking user behavior, etc.

*Source: docs/helpers/cookie.md*

### Handling Signed Cookies in Hono

This code snippet demonstrates how to set, retrieve, and delete signed cookies in Hono. Signed cookies are a security measure that ensures the data stored in the cookie has not been tampered with.

```ts
app.get('/signed-cookie', (c) => {
  const secret = 'secret'

  await setSignedCookie(c, 'cookie_name0', 'cookie_value', secret)
  const fortuneCookie = await getSignedCookie(c, secret, 'cookie_name0')
  deleteCookie(c, 'cookie_name0')
  const allSignedCookies = await getSignedCookie(c, secret)
})
```

In this snippet:

- A secret key is defined.
- `setSignedCookie` is used to set a signed cookie.
- `getSignedCookie` is used to retrieve the value of a signed cookie. It will return `false` if the signature was tampered with or is invalid.
- `deleteCookie` is used to delete a cookie.

- The secret key should be a large enough string to be secure.
- The operations are asynchronous due to the async nature of the WebCrypto API, which is used to create HMAC SHA-256 signatures.

- Storing user session information in a secure manner.
- Storing temporary data between requests.

- [Hono Documentation](https://hono.boutell.com/)

**Reasoning:** This rule is important as it demonstrates how to set, retrieve, and delete signed cookies in Hono. Signed cookies are a security measure that ensures the data stored in the cookie has not been tampered with. This is done by appending a signature to the cookie value and verifying it when the cookie is read.

*Source: docs/helpers/cookie.md*

### Setting and Deleting Cookies in Hono

This code demonstrates how to set and delete cookies in Hono. It includes examples for both regular and signed cookies.

```ts
// Regular cookies
setCookie(c, 'great_cookie', 'banana', {
  path: '/',
  secure: true,
  domain: 'example.com',
  httpOnly: true,
  maxAge: 1000,
  expires: new Date(Date.UTC(2000, 11, 24, 10, 30, 59, 900)),
  sameSite: 'Strict',
})

// Signed cookies
await setSignedCookie(
  c,
  'fortune_cookie',
  'lots-of-money',
  'secret ingredient',
  {
    path: '/',
    secure: true,
    domain: 'example.com',
    httpOnly: true,
    maxAge: 1000,
    expires: new Date(Date.UTC(2000, 11, 24, 10, 30, 59, 900)),
    sameSite: 'Strict',
  }
)
```

The `setCookie` function is used to set a regular cookie, while the `setSignedCookie` function is used to set a signed cookie. Both functions take a context object, the cookie name, the cookie value, and an options object as parameters. The options object can include properties like `path`, `secure`, `domain`, `httpOnly`, `maxAge`, `expires`, and `sameSite`.

- `setSignedCookie` also takes a secret parameter, which is used to sign the cookie.
- The `deleteCookie` function is used to delete a cookie. It takes a context object, the cookie name, and an options object as parameters. The options object can include properties like `path`, `secure`, and `domain`.

- [Hono documentation](https://hono.bespoken.io/docs/cookies/)

- Storing user session data
- Tracking user behavior
- Personalizing user experience

**Reasoning:** This rule is important as it demonstrates how to set and delete cookies in Hono, including regular and signed cookies. Cookies are essential for maintaining session data and other information on the client side. Understanding how to correctly set and delete cookies is crucial for managing user sessions, personalization, and tracking.

*Source: docs/helpers/cookie.md*

### Deleting Cookies in Hono

This code snippet demonstrates how to delete a cookie using the Hono web framework.

```ts
deleteCookie(c, 'banana', {
  path: '/',
  secure: true,
  domain: 'example.com',
})
```

The `deleteCookie` function takes three parameters:

1. `c`: The context object.
2. `'banana'`: The name of the cookie to be deleted.
3. An options object that specifies the path, whether the cookie is secure, and the domain.

- The `deleteCookie` function returns the deleted value.
- The Cookie helper supports `__Secure-` and `__Host-` prefix.

- [Hono Documentation](https://hono.bike/docs/cookies)

- Deleting user session cookies when a user logs out.
- Deleting tracking cookies when a user opts out of tracking.

**Reasoning:** This rule is important as it demonstrates how to delete a cookie using the Hono web framework. Understanding how to delete cookies is crucial for managing user sessions, tracking, and personalization features.

*Source: docs/helpers/cookie.md*

### Deleting Cookies and Handling Secure Cookie Prefixes in Hono

This code demonstrates how to delete a cookie in Hono.

```ts
deleteCookie(c, 'banana', {
  path: '/',
  secure: true,
  domain: 'example.com',
})
ts
const deletedCookie = deleteCookie(c, 'delicious_cookie')
ts
const deletedCookie = deleteCookie(c, 'delicious_cookie')
```

- The `deleteCookie` function requires the cookie name and optionally, the path, secure flag, and domain.
- The `__Secure-` and `__Host-` prefixes are used to ensure that the cookie is only sent over secure connections and cannot be accessed via JavaScript respectively.

- Deleting user session cookies when the user logs out.
- Deleting cookies when they are no longer needed to free up space.

- [MDN Web Docs - Secure and HttpOnly cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies)

#### Code Snippet

```typescript

The `deleteCookie` function returns the deleted value:

```

**Reasoning:** This rule is important as it demonstrates how to delete a cookie using the Hono framework. It also shows how to handle cookies with `__Secure-` and `__Host-` prefixes, which are security features for cookies. Understanding this rule is crucial for managing user sessions and implementing security measures in web applications.

*Source: docs/helpers/cookie.md*

### Using `__Secure-` and `__Host-` Prefixes in Cookie Names with Hono

In Hono, you can add `__Secure-` and `__Host-` prefixes to cookie names for added security. Here's how you can do it:

```ts
const securePrefixCookie = getCookie(c, 'yummy_cookie', 'secure')
const hostPrefixCookie = getCookie(c, 'yummy_cookie', 'host')

const securePrefixSignedCookie = await getSignedCookie(
  c,
  secret,
  'fortune_cookie',
  'secure'
)
const hostPrefixSignedCookie = await getSignedCookie(
  c,
  secret,
  'fortune_cookie',
  'host'
)
ts
setCookie(c, 'delicious_cookie', 'macha', {
  prefix: 'secure', // or `host`
})
```

- The `__Secure-` prefix tells the browser to only send the cookie over an encrypted HTTPS connection.
- The `__Host-` prefix requires the cookie to be secure and its path attribute to be `/`, ensuring that the cookie won't be sent across different sites.

- [Cookie Prefixes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Cookie_prefixes)

- Use `__Secure-` and `__Host-` prefixes when you want to ensure that your cookies are only sent over secure connections and are not accessible across different sites.

#### Code Snippet

```typescript

In this code snippet, `getCookie` and `getSignedCookie` functions are used to retrieve cookies with `__Secure-` and `__Host-` prefixes. The third argument to these functions is the prefix type.

To set a cookie with a prefix, you can use the `setCookie` function and specify the prefix type in the options object:

```

**Reasoning:** This rule is important as it demonstrates how to use the `__Secure-` and `__Host-` prefixes in cookie names using the Hono framework. These prefixes add an extra layer of security to cookies. The `__Secure-` prefix tells the browser to only send the cookie over an encrypted HTTPS connection. The `__Host-` prefix requires the cookie to be secure and its path attribute to be `/`, ensuring that the cookie won't be sent across different sites.

*Source: docs/helpers/cookie.md*

### Setting Cookies and Signed Cookies with a Prefix in Hono

This code snippet demonstrates how to set cookies and signed cookies in Hono with a prefix.

```ts
setCookie(c, 'delicious_cookie', 'macha', {
  prefix: 'secure', // or `host`
})

await setSignedCookie(
  c,
  'delicious_cookie',
  'macha',
  'secret choco chips',
  {
    prefix: 'secure', // or `host`
  }
)
```

The `setCookie` and `setSignedCookie` functions are used to set a cookie and a signed cookie respectively. The `prefix` option is used to specify a prefix when setting the cookie.

Following the best practices for cookie settings is crucial for secure and efficient web development. The New Cookie RFC (a.k.a cookie-bis) and CHIPS include some best practices for Cookie settings that developers should follow.

- [RFC6265bis-13](https://datatracker.i

This is commonly used when you want to set a cookie or a signed cookie with a specific prefix in a Hono application.

**Reasoning:** This rule is important as it demonstrates how to set cookies and signed cookies in Hono with a prefix. The prefix option is used to specify a prefix when setting the cookie. Following best practices for cookie settings is crucial for secure and efficient web development.

*Source: docs/helpers/cookie.md*

### Handling WebSocket Connections in Hono

This code snippet demonstrates how to handle WebSocket connections in the Hono framework using the `upgradeWebSocket()` function.

```ts
import type { ServerWebSocket } from 'bun'

const { upgradeWebSocket, websocket } = createBunWebSocket<ServerWebSocket>()

// ...

export default {
  fetch: app.fetch,
  websocket,
}
```

In the above code, `upgradeWebSocket()` is used to return a handler for handling WebSocket connections. This handler can be used to listen for incoming messages from the client and send responses.

1. Import the necessary modules and types.
2. Create a new WebSocket using `createBunWebSocket()`.
3. Use `upgradeWebSocket()` to return a handler for handling WebSocket connections.
4. Export the handler so it can be used elsewhere in your application.

- The `upgradeWebSocket()` function is part of the Hono framework and is designed to work with the `ServerWebSocket` type from the 'bun' module.

- [@hono/node-ws](https://github.com/honojs/middleware/tree/main/packages/node-ws)

- Real-time applications that require bi-directional communication between the client and server.
- Applications that require push notifications from the server to the client.

**Reasoning:** This rule is important as it demonstrates how to handle WebSocket connections in the Hono framework. It shows how to upgrade a connection to a WebSocket and handle incoming messages from the client.

*Source: docs/helpers/websocket.md*

### Using WebSocket Helper in Hono Framework

The WebSocket Helper in Hono framework supports various events such as `onOpen`, `onMessage`, `onClose`, and `onError`. However, currently, Cloudflare Workers does not support the `onOpen` event.

```text
Available events:

- `onOpen` - Currently, Cloudflare Workers does not support it.
- `onMessage`
- `onClose`
- `onError`
```

It's important to note that if you use middleware that modifies headers (e.g., applying CORS) on a route that uses WebSocket Helper, you may encounter an error saying you can't modify immutable headers. This is because `upgradeWebSocket()` also changes headers internally. Therefore, caution is required when using WebSocket Helper and middleware at the same time.

Handlers defined with WebSocket Helper also support RPC mode.

When a WebSocket connection is established, the events are triggered based on the interaction. For instance, `onMessage` is triggered when a message is received from the client.

Be cautious when using middleware that modifies headers on a route that uses WebSocket Helper, as it can lead to errors due to immutable headers.

- Hono framework documentation

- Real-time communication between client and server
- Implementing chat applications, multiplayer games, live updates, etc.

**Reasoning:** This rule is important as it demonstrates the use of WebSocket Helper in Hono framework and the events it supports. It also highlights the caution required when using middleware that modifies headers on a route that uses WebSocket Helper, as it can lead to errors due to immutable headers.

*Source: docs/helpers/websocket.md*

### Creating WebSocket Server and Client in Hono

This code demonstrates how to create a WebSocket server and client using the Hono framework.

```ts
// server.ts
import { Hono } from 'hono'
import { upgradeWebSocket } from 'hono/cloudflare-workers'

const app = new Hono().get(
  '/ws',
  upgradeWebSocket(() => {
    return {
      onMessage: (e

// client.ts
const client = hc<WebSocketApp>('http://localhost:8787')
const socket = client.ws.$ws() // A WebSocket object for a client
```

On the server side, the `upgradeWebSocket` function is used to upgrade an HTTP connection to a WebSocket connection. On the client side, the `hc` function is used to create a WebSocket client that connects to the server.

- The `upgradeWebSocket` function is specific to the Hono framework and may not work with other frameworks.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Real-time applications such as chat apps, live updates, etc.

**Reasoning:** This rule is important as it demonstrates how to create a WebSocket client and server using the Hono framework. It shows how to upgrade an HTTP connection to a WebSocket connection on the server side and how to create a WebSocket client that connects to the server.

*Source: docs/helpers/websocket.md*

### Establishing WebSocket Connection with Hono

This code snippet demonstrates how to establish a WebSocket connection using the Hono framework.

```javascript
const client = hc<typeof app>('http://localhost:8787')
const ws = client.ws.$ws(0)

ws.addEventListener('open', () => {
  setInterval(() => {
    ws.send(new Date().toString())
  }, 1000)
})
```

1. A client is created that connects to the server at 'http://localhost:8787'.
2. A WebSocket (ws) is created using the client's WebSocket method.
3. An event listener is added to the WebSocket that triggers when the connection is opened.
4. Inside the event listener, a setInterval function is used to send the current date and time to the server every second.

- The WebSocket connection is established at the start of the application and remains open for real-time data transfer.
- The server must be set up to handle WebSocket connections and messages.

- [Hono Documentation](https://hono.bouffier.com/docs)

- Real-time data transfer between client and server
- Live updates or notifications
- Collaborative applications where multiple users interact with the same data

**Reasoning:** This rule is important as it demonstrates how to establish a WebSocket connection using the Hono framework. WebSockets provide a full-duplex communication channel over a single TCP connection, which is essential for real-time data transfer between the client and server.

*Source: docs/helpers/websocket.md*

### Importing and Using JWT Functionality in Hono

This code snippet demonstrates how to import and use the JWT functionality from the Hono framework.

```ts
import { decode, sign, verify } from 'hono/jwt'
```

The `decode`, `sign`, and `verify` functions are imported from the `hono/jwt` module. These functions are used to handle JWT tokens in the application.

- `decode`: This function is used to decode a JWT token and retrieve the payload.
- `sign`: This function is used to generate a JWT token by encoding a payload and signing it.
- `verify`: This function is used to verify a JWT token and ensure it is valid.

The JWT Middleware also imports the `jwt` function from the `hono/jwt` module.

- [JWT Middleware](/docs/middleware/builtin/jwt)

- Implementing user authentication and authorization in a web application.
- Verifying the integrity of data sent between the client and server.

**Reasoning:** This rule is important as it demonstrates how to import and use the JWT functionality from the Hono framework. JWT (JSON Web Tokens) are commonly used for authorization purposes in web applications. Understanding how to import and use these functions is crucial for implementing secure authorization in a web application using Hono.

*Source: docs/helpers/jwt.md*

### Generating JWT Tokens in Hono

The `sign` function from the `hono/jwt` module is used to generate a JWT (JSON Web Token) by encoding a payload and signing it using a specified algorithm and secret.

Here is the function signature:

```ts
sign(
  payload: unknown,
  secret: string,
  alg?: 'HS256';
): Promise<string>;
ts
import { sign } from 'hono/jwt'

const payload = {
  sub: 'user123',
  role: 'admin',
  exp: Math.floor(Date.now() / 1000) + 60 * 5, // Token expires in 5 minutes
}

const secret = 'your-secret'

const token = await sign(payload, secret)
```

In this example, a payload is created with a subject (`sub`), a role, and an expiration time (`exp`). The `sign` function is then used to generate a JWT token using this payload and a secret.

- The `sign` function returns a promise that resolves to a string. This string is the JWT token.

- The `alg` parameter is optional and defaults to 'HS256', which stands for HMAC SHA-256, a commonly used cryptographic algorithm for generating JWT tokens.

- [Hono JWT Documentation](https://hono.bryntum.com/docs/modules/jwt.html)

- Authenticating users in a web application
- Securely transmitting information between parties

#### Code Snippet

```typescript

And here is an example of its usage:

```

**Reasoning:** This rule is important as it demonstrates how to use the 'sign' function from the 'hono/jwt' module to generate a JWT token. JWT tokens are a common method for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed.

*Source: docs/helpers/jwt.md*

### Verifying JWT Tokens in Hono

This code snippet demonstrates how to verify a JWT token using the Hono framework.

```ts
verify(
  token: string,
  secret: string,
  alg?: 'HS256';
): Promise<any>;
ts
import { verify } from 'hono/jwt'

const tokenToVerify = 'token'
const secretKey = 'mySecretKey'

const decodedPayload = await verify(tokenToVerify, secretKey)
console.log(decodedPayload)
```

- The `verify` function only checks the validity of the token if you have added Payload Validation.
- The secret key should be kept secure and not exposed to the client.

- [Hono JWT Documentation](https://hono.bryntum.com/docs/classes/jwt.html)

- Verifying user authentication tokens in a web application.

#### Code Snippet

```typescript

### How it works

The `verify` function takes in three parameters: the token to be verified, the secret key used for signing the token, and an optional algorithm parameter (default is 'HS256'). It returns a promise that resolves with the decoded payload if the token is valid.

### Example

```

**Reasoning:** This rule is important as it demonstrates how to verify a JWT token using the Hono framework. JWT tokens are used for authentication and secure data transfer. Verifying the token ensures it hasn't been tampered with and is still valid, which is crucial for maintaining security in web applications.

*Source: docs/helpers/jwt.md*

### Decoding a JWT Token in Hono

This code snippet demonstrates how to decode a JWT token using the Hono framework. The `decode` function extracts and returns the header and payload from the token.

```ts
import { decode } from 'hono/jwt'

// Decode the JWT token
const tokenToDecode = 'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJzdWIiOiAidXNlcjEyMyIsICJyb2xlIjogImFkbWluIn0.JxUwx6'

const decodedToken = decode(tokenToDecode);
```

The `decode` function takes a JWT token as a string and returns an object with the header and payload.

This function does not perform signature verification. It should be used when you trust the source of the token and don't need to verify it.

- [Hono Documentation](https://hono.bryntum.com/docs/classes/jwt.html#decode)

- Extracting user information from a JWT token in an authenticated request
- Debugging JWT tokens during development

**Reasoning:** This rule is important as it demonstrates how to decode a JWT token using the Hono framework. Decoding a JWT token is a common operation in web development, especially when dealing with authentication and authorization. It allows developers to extract the header and payload from the token, which can contain useful information such as the user's role or other metadata.

*Source: docs/helpers/jwt.md*

### Decoding JWT Token in Hono Framework

This code snippet demonstrates how to decode a JWT token using Hono framework. The 'decode' function from 'hono/jwt' is used to decode the token.

```ts
import { decode } from 'hono/jwt'

// Decode the JWT token
const tokenToDecode = 'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJzdWIiOiAidXNlcjEyMyIsICJyb2xlIjogImFkbWluIn0.JxUwx6Ua1B0D1B0FtCrj72ok5cm1Pkmr_hL82sd7ELA'

const { header, payload } = decode(tokenToDecode)

console.log('Decoded Header:', header)
console.log('Decoded Payload:', payload)
```

The 'decode' function takes a JWT token as input and returns an object containing the header and payload of the token.

- The 'decode' function does not perform signature verification. It only decodes the token to extract the header and payload.

- [Hono JWT Documentation](https://hono.bosch.io/docs/api/jwt/)

- Inspecting the header and payload of a JWT token in applications.

**Reasoning:** This rule is important as it demonstrates how to decode a JWT token using Hono framework. Decoding a JWT token is a common requirement in many applications for inspecting the header and payload of the token. This rule can be used as a reference for developers to understand how to use the 'decode' function from 'hono/jwt' to decode a JWT token.

*Source: docs/helpers/jwt.md*

### Using Development Helper Methods in Hono

In Hono, you can use the development helper methods for debugging and development purposes. Here's how you can do it:

```ts
import { Hono } from 'hono'
import { getRouterName, showRoutes } from 'hono/dev'
ts
const app = new Hono()

// ...

console.log(getRouterName(app))
ts
const app = new Hono()

// ...

showRoutes(app)
```

- These methods are meant to be used in a development environment and not in a production environment.

- [Hono Documentation](https://hono.bevry.me/)

- Debugging router issues
- Visualizing the routes in your application

#### Code Snippet

```typescript

### `getRouterName()`

You can get the name of the currently used router with `getRouterName()`.

```

**Reasoning:** This rule is important as it demonstrates how to use the development helper methods provided by the Hono framework. These methods can be useful for debugging and development purposes. The `getRouterName()` function can be used to retrieve the name of the currently used router, and the `showRoutes()` function can be used to display the routes.

*Source: docs/helpers/dev.md*

### Using Helper Functions in Hono

In Hono, there are helper functions that can be used for debugging and understanding the state of your application. Two of these functions are `getRouterName()` and `showRoutes()`.

You can get the name of the currently used router with `getRouterName()`. Here is an example of how to use it:

```ts
import { Hono } from 'hono'
import { getRouterName } from 'hono/dev'

const app = new Hono()

// ...

console.log(getRouterName(app))
ts
import { Hono } from 'hono'
import { showRoutes } from 'hono/dev'

const app = new Hono().basePath('/v1')

app.get('/posts')

// ...

showRoutes(app)
```

These functions are particularly useful during the development phase of your application, as they provide insights into the state of your router and routes.

#### Code Snippet

```typescript

### `showRoutes()`

`showRoutes()` function displays the registered routes in your console. Here is an example of how to use it:

```

**Reasoning:** This rule is important as it demonstrates how to use the helper functions `getRouterName()` and `showRoutes()` in the Hono framework. These functions are useful for debugging and understanding the state of your application, as they allow you to retrieve the name of the currently used router and display the registered routes respectively.

*Source: docs/helpers/dev.md*

### Displaying Registered Routes in Hono

In Hono, you can display all the registered routes in your application using the `showRoutes()` function. This can be particularly useful for debugging and understanding the structure of your application.

Here is an example of how to use it:

```ts
const app = new Hono().basePath('/v1')

app.get('/posts', (c) => {
  // ...
})

app.get('/posts/:id', (c) => {
  // ...
})

app.post('/posts', (c) => {
  // ...
})

showRoutes(app, {
  verbose: true,
})
txt
GET   /v1/posts
GET   /v1/posts/:id
POST  /v1/posts
```

- The `showRoutes()` function takes two arguments: the Hono application instance and an options object. In this case, we're passing `{ verbose: true }` to display detailed information about each route.
- The `basePath()` function sets a base path for all routes. In this case, all routes will be prefixed with `/v1`.

- [Hono Documentation](https://hono.bespokejs.com)

- Debugging: You can use this feature to quickly check all the routes in your application and ensure they are set up correctly.
- Documentation: This can also be useful for generating documentation for your API, as it provides a clear overview of all the available endpoints.

#### Code Snippet

```typescript

When this application starts running, the routes will be shown in your console as follows:

```

**Reasoning:** This rule is important as it demonstrates how to display all the registered routes in a Hono application. This can be useful for debugging and understanding the structure of the application.

*Source: docs/helpers/dev.md*

### Defining and Displaying Routes in Hono

In Hono, routes are defined using the `app.get` or `app.post` methods. The first argument is the route path and the second argument is a callback function that handles the request and response.

```txt
app.post('/posts', (c) => {
  // ...
})
txt
showRoutes(app, {
  verbose: true,
})
txt
GET   /v1/posts
GET   /v1/posts/:id
POST  /v1/posts
```

- The callback function for a route takes a context object 'c' as an argument. This object contains information about the request and response.
- The 'verbose' option in 'showRoutes' is optional. If it is not provided, the default value is false.

- [Hono Documentation](https://hono.bike/)

- Defining routes for different HTTP methods (GET, POST, etc.)
- Displaying the routes in the console for debugging purposes

#### Code Snippet

```typescript

To display the routes in the console when the application starts, use the 'showRoutes' function. The 'verbose' option can be set to true to display more detailed information.

```

**Reasoning:** This rule is important as it demonstrates how to define routes in a Hono application and how to use the 'showRoutes' function to display the routes in the console. It also shows the usage of the 'verbose' option, which when set to true, displays more detailed information about the routes.

*Source: docs/helpers/dev.md*

### Importing and Using 'getConnInfo' in Hono

This rule demonstrates how to import and use the 'getConnInfo' helper function from the Hono framework in both Lambda@Edge and Node.js contexts.

For Lambda@Edge:

```ts
import { Hono } from 'hono'
import { getConnInfo } from 'hono/lambda-edge'
ts
import { Hono } from 'hono'
import { getConnInfo } from '@hono/node-server/conninfo'
ts
const app = new Hono()

app.get('/', (c) => {
  const info = getConnInfo(c) // info is `ConnInfo`
  return c.text(`Your remote address is ${info.remote.address}`)
})
```

The 'getConnInfo' function is imported from the appropriate module depending on the context (Lambda@Edge or Node.js). It is then used inside a route handler to retrieve connection information from the context object 'c'. The remote address of the client is then sent back in the response.

- The 'getConnInfo' function returns an object of type 'ConnInfo', which includes various properties related to the connection.
- The context object 'c' passed to route handlers in Hono includes the request and response objects, among other things.

- [Hono Documentation](https://hono.beyondnlp.com/)

- Logging client information for debugging or analytics
- Performing security checks based on client information

#### Code Snippet

```typescript

For Node.js:

```

**Reasoning:** This rule is important as it demonstrates how to import and use the 'getConnInfo' helper function from the Hono framework in both Lambda@Edge and Node.js contexts. This function is used to retrieve connection information, such as the remote address of a client, which can be useful in various scenarios like logging, debugging, or security checks.

*Source: docs/helpers/conninfo.md*

### Using 'getConnInfo()' Helper Function to Retrieve Connection Information in Hono

This code snippet demonstrates how to use the 'getConnInfo()' helper function in Hono to retrieve connection information.

```ts
const app = new Hono()

app.get('/', (c) => {
  const info = getConnInfo(c) // info is `ConnInfo`
  return c.text(`Your remote address is ${info.remote.address}`)
})
ts
type AddressType = 'IPv6' | 'IPv4' | undefined

type NetAddrInfo = {
  /**
   * Transport protocol type
   */
  transport?: 'tcp' | 'udp'
  /**
   * Transport port number
   */
  port?: number
}
```

The 'getConnInfo()' function retrieves connection information from the context object 'c'. This information includes the remote address, transport protocol type, and transport port number.

- The 'getConnInfo()' function is a helper function provided by Hono.
- The returned 'ConnInfo' object contains detailed information about the connection.

- [Hono Documentation](https://hono.beyondco.de/)

- Retrieving connection information for logging or debugging purposes.
- Displaying connection information to the user.

#### Code Snippet

```typescript

The 'getConnInfo()' function returns an object of type 'ConnInfo'. The type definitions for the values that can be obtained from this function are as follows:

```

**Reasoning:** This rule is important as it demonstrates how to use the 'getConnInfo()' helper function in Hono to retrieve connection information. It also shows the type definitions for the values that can be obtained from this function. Understanding this rule is crucial for developers to effectively use Hono's helper functions and handle connection information in their applications.

*Source: docs/helpers/conninfo.md*

### Importing and Using the testClient Function in Hono

This code snippet demonstrates how to import and use the 'testClient' function from the 'hono/testing' module in Hono framework.

```ts
import { Hono } from 'hono'
import { testClient } from 'hono/testing'
```

The 'testClient()' function takes an instance of Hono as its first argument and returns an object of the Hono Client. This allows you to define your requests for testing purposes.

- The 'testClient()' function is part of the 'hono/testing' module and must be imported before use.
- The function requires an instance of Hono as its first argument.

- Hono Client: /docs/guides/rpc#client

- Testing Hono applications: The 'testClient()' function simplifies the testing process by providing an instance of the Hono Client, which can be used to define requests.

**Reasoning:** This rule is important as it demonstrates how to import and use the 'testClient' function from the 'hono/testing' module in Hono framework. This function is crucial for testing Hono applications as it simplifies the process by returning an instance of the Hono Client, which can be used to define requests.

*Source: docs/helpers/testing.md*

### Testing Hono Applications with testClient

This code snippet demonstrates how to use the 'testClient' function from Hono's testing module to test a Hono application.

```ts
import { testClient } from 'hono/testing'

it('test', async () => {
  const app = new Hono().get('/search', (c) =>
    c.json({ hello: 'world' })
  )
  const res = await testClient(app).search.$get()

  expect(await res.json()).toEqual({ hello: 'world' })
})
```

In this example, a Hono application is created with a GET route '/search' that returns a JSON response. The 'testClient' function is then used to send a GET request to this route. The response is awaited and then checked to ensure it matches the expected output.

- The 'testClient' function takes a Hono application as its argument and returns an object that can be used to send requests to the application.
- The '$get' function is used to send a GET request to a specific route.

- [Hono Testing Documentation](https://hono.bayrell.org/docs/en/testing)

- Testing the behavior of routes in a Hono application.
- Checking the response of a route to ensure it matches the expected output.

**Reasoning:** This rule is important as it demonstrates how to use the 'testClient' function from Hono's testing module to test a Hono application. It shows how to create a Hono application, define a route, and then use the 'testClient' function to send a GET request to that route. The response is then checked to ensure it matches the expected output. This is a fundamental aspect of testing in Hono, ensuring that the application behaves as expected.

*Source: docs/helpers/testing.md*

### Importing and Using Streaming Helpers in Hono

This code demonstrates how to import and use the streaming helpers provided by the Hono framework.

```ts
import { Hono } from 'hono'
import { stream, streamText, streamSSE } from 'hono/streaming'
```

1. The `Hono` object is imported from the `hono` package. This object is the main entry point for using the Hono framework.
2. The `stream`, `streamText`, and `streamSSE` functions are imported from the `hono/streaming` module. These functions are used to create streaming responses.

- The `stream` function returns a simple streaming response as a `Response` object.
- The `streamText` function is used for streaming text responses.
- The `streamSSE` function is used for streaming Server-Sent Events (SSE).

- [Hono Documentation](https://hono.bike/docs/helpers/)

- Streaming large amounts of data in a response.
- Sending real-time updates to the client using SSE.

**Reasoning:** This rule is important as it demonstrates how to import and use the streaming helpers provided by the Hono framework. These helpers allow for streaming responses in a Hono application, which can be useful for handling large amounts of data or real-time updates.

*Source: docs/helpers/streaming.md*

### Handling Streaming Responses with Hono's stream() Function

In Hono, the `stream()` function is used to return a simple streaming response as a `Response` object. This function takes two arguments: the context `c` and an async function that handles the stream.

Here is a code snippet demonstrating its usage:

```ts
app.get('/stream', (c) => {
  return stream(c, async (stream) => {
    // Write a process to be executed when aborted.
    stream.onAbort(() => {
      console.log('Aborted!')
    })
    // Write a Uint8Array.
    await stream.write(new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]))
    // Pipe a readable stream.
    await stream.pipe(anotherReadableStream)
  })
})
```

In this snippet:

1. The `onAbort()` function is used to handle the abort event. In this case, it logs 'Aborted!' to the console.
2. The `write()` function is used to write a Uint8Array to the stream.
3. The `pipe()` function is used to pipe a readable stream.

- Make sure to handle the abort event to prevent unexpected behavior.
- The `write()` and `pipe()` functions return promises, so make sure to use `await` or handle the promises properly.

- [Hono Documentation](https://hono.balthazar.dev/docs)

- Streaming large files or data in chunks to prevent blocking the event loop.
- Streaming real-time data.

**Reasoning:** This rule is important as it demonstrates how to use the stream() function in Hono to return a simple streaming response as a Response object. It shows how to handle the abort event, write a Uint8Array to the stream, and pipe a readable stream. Understanding this rule is crucial for developers who need to handle streaming responses in their Hono applications.

*Source: docs/helpers/streaming.md*

### Streaming Text in Hono

This code demonstrates how to use the `streamText` function in Hono to return a streaming response with specific headers. It shows how to write text with and without a new line, and how to introduce a delay in the stream.

```ts
app.get('/streamText', (c) => {
  return streamText(c, async (stream) => {
    // Write a text with a new line ('\n').
    await stream.writeln('Hello')
    // Wait 1 second.
    await stream.sleep(1000)
    // Write a text without a new line.
    await stream.write(`Hono!`)
  })
})
```

The `streamText` function takes two arguments: the context `c` and a callback function. The callback function takes a `stream` object, which is used to write text to the response. The `writeln` method writes a text with a new line, while the `write` method writes a text without a new line. The `sleep` method introduces a delay in the stream.

If you are developing an application for Cloudflare Workers, a streaming may not work well on Wrangler. If so, add `Identity` for `Content-Encoding` header.

- [Hono Documentation](https://hono.boutell.com/)

- Real-time applications
- Streaming large amounts of data

**Reasoning:** This rule is important as it demonstrates how to use the streamText function in Hono to return a streaming response with specific headers. It shows how to write text with and without a new line, and how to introduce a delay in the stream. This is useful in scenarios where data needs to be streamed to the client, for example, in real-time applications.

*Source: docs/helpers/streaming.md*

### Handling Streaming in Cloudflare Workers with Hono

When developing an application for Cloudflare Workers, streaming may not work well on Wrangler. To handle this, you need to set the 'Content-Encoding' header to 'Identity'.

Here is a code snippet demonstrating this:

```ts
app.get('/streamText', (c) => {
  c.header('Content-Encoding', 'Identity')
  return streamText(c, async (stream) => {
    // ...
  })
})
```

In this code snippet, we are defining a GET route '/streamText'. Inside the route handler, we first set the 'Content-Encoding' header to 'Identity'. Then, we return a stream of text.

- Make sure to set the 'Content-Encoding' header to 'Identity' when working with streaming on Wrangler.

- [Hono Documentation](https://hono.bayrell.org/en/)

- Streaming text or other data in a Cloudflare Worker application.

**Reasoning:** This rule is important as it demonstrates how to handle streaming in Cloudflare Workers using the Hono framework. It shows the correct way to set the 'Content-Encoding' header to 'Identity' to ensure proper functioning of streaming on Wrangler.

*Source: docs/helpers/streaming.md*

### Streaming Server-Sent Events with Hono

This code snippet demonstrates how to use the `streamSSE()` function in Hono to stream Server-Sent Events (SSE). This is a common use case for real-time applications where the server needs to push updates to the client.

```ts
const app = new Hono()
let id = 0

app.get('/sse', async (c) => {
  return streamSSE(c, async (stream) => {
    while (true) {
      const message = `It is ${new Date().toISOString()}`
      await stream.writeSSE({
        data: message,
        event: 'time-update',
        id: String(id++),
      })
      await stream.sleep(1000)
    }
  })
})
```

The `streamSSE()` function takes two arguments: the context object `c` and a callback function. The callback function is called with a `stream` object that has a `writeSSE()` method. This method is used to send a Server-Sent Event to the client.

- The `writeSSE()` method takes an object with `data`, `event`, and `id` properties. The `data` property is the message to send, the `event` property is the type of event, and the `id` property is a unique identifier for the event.
- The `stream.sleep()` method is used to pause execution for a specified amount of time. This is useful for throttling the rate of events.

- [Hono Documentation](https://hono.bouzuya.net/)

- Real-time updates: Use SSE to push updates from the server to the client in real-time. For example, you could use this to push real-time stock price updates, chat messages, or game state updates.

**Reasoning:** This rule is important as it demonstrates how to use the streamSSE() function in Hono to stream Server-Sent Events (SSE). This is a common use case for real-time applications where the server needs to push updates to the client.

*Source: docs/helpers/streaming.md*

### Error Handling in Hono's Streaming Helper

In Hono, the third argument of the streaming helper is used as an error handler. This argument is optional, and if not specified, the error will be output as a console error.

Here is an example of how to use it:

```ts
app.get('/stream', (c) => {
  return stream(
    c,
    async (stream) => {
      // Write a process to be executed when aborted.
      stream.onAbort(() => {
        console.log('Aborted!')
      })
      // Write a Uint8Array.
      await stream.write(
        new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f])
      )
      // Pipe a readable stream.
      await stream.pipe(anotherReadableStream)
    },
    (err, stream) => {
      stream.writeln('An error occurred!')
      console.error(err)
    }
  )
})
```

In this code snippet, the error handler is used to write a message to the stream and output the error to the console when an error occurs.

The stream will be automatically closed after the callbacks are executed. If the callback function of the streaming helper throws an error, the `onError` event of Hono will not be triggered.

- The error handler is optional. If not specified, the error will be output as a console error.
- The stream will be automatically closed after the callbacks are executed.

- [Hono Documentation](https://hono.bouzuya.net/)

- Streaming large amounts of data
- Handling errors during streaming

**Reasoning:** This rule is important as it demonstrates how to handle errors in Hono's streaming helper. It shows how to use the third argument of the streaming helper as an error handler, and how to write a process to be executed when an error occurs or when the stream is aborted.

*Source: docs/helpers/streaming.md*

### Importing and Using Factory Helper in Hono

This code demonstrates how to import and use the Factory Helper in Hono to create an instance of the Factory class.

```ts
import { Hono } from 'hono'
import { createFactory, createMiddleware } from 'hono/factory'
ts
import { createFactory } from 'hono/factory'

const factory = createFactory()
```

The `createFactory` function is imported from 'hono/factory' and used to create an instance of the Factory class. This instance can then be used to create Hono's components such as Middleware.

- The Factory Helper is a useful tool for setting up the proper TypeScript types in Hono.
- The `createFactory` function creates an instance of the Factory class.

- Hono documentation: https://hono.boshanlu.com/

- Creating an instance of the Factory class to use in creating Hono's components such as Middleware.

#### Code Snippet

```typescript

To create an instance of the Factory class, use the `createFactory()` function.

```

**Reasoning:** This rule is important as it demonstrates how to import and use the Factory Helper in Hono, which provides useful functions for creating Hono's components such as Middleware. It also shows how to create an instance of the Factory class using the createFactory() function. This is crucial for setting up the proper TypeScript types in Hono.

*Source: docs/helpers/factory.md*

### Creating an Instance of the Factory Class and Passing Environment Types as Generics in Hono

In Hono, you can create an instance of the Factory class using the 'createFactory()' function. This function is imported from 'hono/factory'.

Here is a basic example of how to use it:

```ts
import { createFactory } from 'hono/factory'

const factory = createFactory()
ts
import { createFactory } from 'hono/factory'

type Env = {
  Variables: {
    foo: string
  }
}

const factory = createFactory<Env>()
```

- The 'createFactory()' function is a part of the 'hono/factory' module.
- You can pass environment types as Generics to the function for type safety.

- Hono Documentation: [https://hono.bespokejs.com](https://hono.bespokejs.com)

- Creating an instance of the Factory class in Hono.
- Passing environment types as Generics to the 'createFactory()' function.

#### Code Snippet

```typescript

You can also pass your environment types as Generics to the 'createFactory()' function. This is useful for ensuring type safety and correct usage of environment variables within your application. Here is an example:

```

**Reasoning:** This rule is important as it demonstrates how to create an instance of the Factory class using the 'createFactory()' function in Hono. It also shows how to pass environment types as Generics to the function, which is crucial for type safety and ensuring the correct usage of environment variables within the application.

*Source: docs/helpers/factory.md*

### Creating Factory Instance with Environment Variables in Hono

In Hono, you can create a factory instance using the 'createFactory' function. You can also pass your environment types as Generics to this function. Here is an example:

```ts
import { createFactory } from 'hono/factory'

type Env = {
  Variables: {
    foo: string
  }
}

const factory = createFactory<Env>()
```

In this code snippet, a type 'Env' is defined with a 'Variables' property. This 'Env' type is then passed as a Generic to the 'createFactory' function to create a factory instance.

The 'createFactory' function in Hono is used to create a factory instance. This function can take environment types as Generics, allowing you to define the types of your environment variables.

- The 'createFactory' function is a part of the 'hono/factory' module.
- The environment types passed as Generics should be defined before they are used.

- Hono Documentation: https://hono.bosch.io/docs/

- Defining environment variables for a Hono application.
- Creating a factory instance with specific environment variables.

**Reasoning:** This rule is important as it demonstrates how to create a factory instance in Hono with environment variables. It shows how to use the 'createFactory' function and how to pass environment types as Generics. This is a common pattern in Hono framework usage, and understanding this can help in creating more flexible and reusable code.

*Source: docs/helpers/factory.md*

### Setting Default Options for a Hono Application

This code snippet demonstrates how to set default options for a Hono application using the 'createFactory' function.

```ts
const factory = createFactory({
  defaultAppOptions: { strict: false },
})

const app = factory.createApp() // `strict: false` is applied
```

In this example, a factory is created with the default option 'strict' set to false. This factory is then used to create an application, and the 'strict' option is automatically applied to this application.

1. The 'createFactory' function is called with an object containing the default options.
2. This function returns a factory with these default options.
3. The 'createApp' method of the factory is then called to create an application with these default options.

- The 'createFactory' function can be used to set any default options for a Hono application.
- The 'createApp' method of the factory will automatically apply these default options to any applications it creates.

- [Hono Documentation](https://hono.bryntum.com/docs/)

- Setting default options for a Hono application to ensure consistent behavior across multiple instances of the application.

**Reasoning:** This rule is important as it demonstrates how to set default options for a Hono application using the 'createFactory' function. It shows how to create a factory with default options and then use this factory to create an application with these default options.

*Source: docs/helpers/factory.md*

### Creating Custom Middleware in Hono

In Hono, you can create custom middleware using the `createMiddleware()` function. This function allows you to execute code before the final request handler, thus providing a way to manage the request-response cycle.

Here is an example of how to create a custom middleware that sets a response header:

```ts
const messageMiddleware = createMiddleware(async (c, next) => {
  await next()
  c.res.headers.set('X-Message', 'Good morning!')
})
```

In this code snippet, `createMiddleware()` is used to create a middleware that sets the 'X-Message' response header to 'Good morning!'. The `next()` function is called to pass control to the next middleware function in the stack.

- The `next()` function is crucial as it passes control to the next middleware function. If it is not called, the request will hang.

- [Hono Documentation](https://hono.bike/docs/middleware/)

- Setting response headers
- Logging requests
- Authenticating users

**Reasoning:** This rule is important as it demonstrates how to create custom middleware in Hono. Middleware is a crucial part of any web application as it allows you to execute code before the final request handler, thus providing a way to manage the request-response cycle. In this case, the custom middleware is used to set a response header.

*Source: docs/helpers/factory.md*

### Creating and Using Middleware to Set Custom Response Headers in Hono

In Hono, middleware functions are used to perform operations on the request and response objects. They are functions that have access to the `context` object and the `next` middleware function in the application’s request-response cycle.

The following code snippet demonstrates how to create a middleware function that sets a custom response header. This middleware function can be reused across different routes or for all routes.

```ts
const messageMiddleware = (message: string) => {
  return createMiddleware(async (c, next) => {
    await next()
    c.res.headers.set('X-Message', message)
  })
}

app.use(messageMiddleware('Good evening!'))
```

In this code:

1. A middleware function `messageMiddleware` is created. This function takes a string `message` as an argument and returns another function that is the actual middleware.
2. The returned middleware function takes `context` and `next` as arguments. `context` is the context object that encapsulates a request and a response. `next` is a function that, when called, passes control to the next middleware function.
3. The middleware function sets a custom response header 'X-Message' with the value of `message`.
4. The middleware function is then used in the application with `app.use()`. This applies the middleware to all routes.

This pattern is useful when you need to perform the same operation for multiple or all routes, such as setting custom headers, logging, or error handling.

**Reasoning:** This rule is important as it demonstrates how to create and use middleware in Hono to set custom response headers. Middleware functions are a fundamental part of any Hono application as they have access to the request and response objects, and the next middleware function in the application’s request-response cycle. This pattern allows developers to encapsulate logic that manipulates the response object in a reusable function.

*Source: docs/helpers/factory.md*

### Creating Middleware and Handlers using Factory in Hono

This code demonstrates how to use the factory module in Hono to create middleware and handlers, and how to use them in an application.

```ts
import { createFactory } from 'hono/factory'
import { logger } from 'hono/logger'

// ...

const factory = createFactory()

const middleware = factory.createMiddleware(async (c, next) => {
  c.set('foo', 'bar')
  await next()
})

const handlers = factory.createHandlers(logger(), middleware, (c) => {
  return c.json(c.var.foo)
})

app.get('/api', ...handlers)
```

1. Import the necessary modules from Hono.
2. Create a factory instance using `createFactory()`.
3. Use the factory instance to create middleware using `createMiddleware()`. This middleware sets a variable 'foo' to 'bar'.
4. Use the factory instance to create handlers using `createHandlers()`. These handlers return a JSON response with the value of 'foo'.
5. Use the created handlers in the application's route.

- The factory module in Hono helps to organize code in a modular way.
- Middleware and handlers created using the factory can be used across different parts of the application.

- [Hono Documentation](https://hono.bevry.me/)

- Creating reusable middleware and handlers for an application.

**Reasoning:** This rule is important as it demonstrates how to use the factory module in Hono to create middleware and handlers. It also shows how to use these created elements in an application. This pattern is crucial for organizing code in a modular way, allowing for better maintainability and scalability.

*Source: docs/helpers/factory.md*

### Avoiding Redundancy in `Env` Type Definition in Hono

In Hono framework, you might need to set the `Env` type in two places when using `new Hono()` and `createMiddleware()`. This can lead to redundancy and potential errors if the `Env` type changes.

Here is an example of this scenario:

```ts
import { createMiddleware } from 'hono/factory'

type Env = {
  Variables: {
    myVar: string
  }
}

// 1. Set the `Env` to `new Hono()`
const app = new Hono<Env>()

// 2. Set the `Env` to `createMiddleware()`
const mw = createMiddleware<Env>(async (c, next) => {
  await next()
})

app.use(mw)
```

To avoid this redundancy, you can use `createFactory()` and `createApp()` to set the `Env` only in one place. This leads to cleaner and more maintainable code.

- [Hono Documentation](https://hono.bike/#/)

This pattern is commonly used when you have a complex `Env` type that is used in multiple places in your Hono application.

**Reasoning:** This rule is important as it demonstrates how to avoid redundancy in the definition of the `Env` type in Hono framework. It shows how to use `createFactory()` and `createApp()` to set the `Env` only in one place, instead of setting it in two places when using `new Hono()` and `createMiddleware()`. This leads to cleaner and more maintainable code.

*Source: docs/helpers/factory.md*

### Using `createFactory()` and `createApp()` to Set `Env` in One Place in Hono

This code snippet demonstrates how to use the `createFactory()` and `createApp()` methods in Hono to set the `Env` in one place.

```ts
import { createFactory } from 'hono/factory'

// ...

// Set the `Env` to `createFactory()`
const factory = createFactory<Env>()

const app = factory.createApp()

// factory also has `createMiddleware()`
const mw = factory.createMiddleware(async (c, next) => {
  await next()
})
```

1. Import the `createFactory` function from the 'hono/factory' module.
2. Set the `Env` to `createFactory()`.
3. Use the `createApp()` method of the factory to create an app.
4. Use the `createMiddleware()` method of the factory to create a middleware.

- `createFactory()` can receive the `initApp` option to initialize an `app` created by `createApp()`.

- [Hono Documentation](https://hono.bayrell.org/en/)

- When you want to set the `Env` in one place for better code reusability and maintainability.

**Reasoning:** This rule is important as it demonstrates how to use the `createFactory()` and `createApp()` methods in Hono to set the `Env` in one place. This is a best practice in Hono framework usage as it promotes code reusability and maintainability.

*Source: docs/helpers/factory.md*

### Initializing an Application with a Database in Hono Framework

The following code snippet demonstrates how to initialize an application with a database using the `initApp` option in the `createFactory` function in Hono framework.

```ts
// factory-with-db.ts
type Env = {
  Bindings: {
    MY_DB: D1Database
  }
  Variables: {
    db: DrizzleD1Database
  }
}

export default createFactory<Env>({ 
  initApp: (app) => {
    app.use(async (c, next) => {
      const db = drizzle(c.env.MY_DB)
      c.set('db', db)
      await next()
    })
  },
})
```

In the `createFactory` function, the `initApp` option is used to initialize the application. A middleware is set up using the `app.use` function. This middleware creates a database connection using the `drizzle` function and the `MY_DB` binding from the environment. The database connection is then set in the context using the `c.set` function.

- The `initApp` option is a common way to set up middleware in Hono framework.
- The `drizzle` function is used to create a database connection.

- [Hono Documentation](https://hono.bevry.me/)

- Setting up a database connection for an application.
- Initializing an application with other types of middleware.

**Reasoning:** This rule is important as it demonstrates how to initialize an application with a database using the `initApp` option in the `createFactory` function. This is a common pattern in Hono framework to set up middleware for the application, in this case, setting up a database connection.

*Source: docs/helpers/factory.md*

### Initializing and Accessing a Database Connection in Hono

This code snippet demonstrates how to use a factory function to initialize an application with a database connection in the Hono framework.

```ts
export default createFactory<Env>({ 
  initApp: (app) => { 
    app.use(async (c, next) => { 
      const db = drizzle(c.env.MY_DB) 
      c.set('db', db) 
      await next() 
    }) 
  }, 
})
ts
// crud.ts
import factoryWithDB from './factory-with-db'

const app = factoryWithDB.createApp()

app.post('/posts', (c) => { 
  c.var.db.insert() 
  // ...
})
```

1. The `createFactory` function is used to create a factory for the application. This factory includes an `initApp` function that sets up a middleware to create a database connection using the `drizzle` function and the `MY_DB` environment variable.
2. The middleware sets the database connection on the context object (`c`) using the `set` method.
3. In the route handler, the database connection is accessed from the context object and used to perform a database operation.

- The `drizzle` function and the `MY_DB` environment variable are placeholders and should be replaced with actual database connection logic and configuration.
- The `set` method is used to set the database connection on the context object, and the `var` property is used to access it.

- [Hono documentation](https://hono.boutique/docs/)

- Initializing a database connection when starting an application
- Accessing a database connection in route handlers

#### Code Snippet

```typescript

And accessing the database connection in a route handler:

```

**Reasoning:** This rule is important as it demonstrates how to use a factory function to initialize an application with a database connection in the Hono framework. It shows how to use middleware to set up a database connection and how to access this connection in a route handler.

*Source: docs/helpers/factory.md*

### Importing and Using the Adapter Helper in Hono

This code snippet demonstrates how to import and use the Adapter Helper from the Hono framework.

```ts
import { Hono } from 'hono'
import { env, getRuntimeKey } from 'hono/adapter'
```

1. The `Hono` object is imported from the 'hono' package.
2. The `env` and `getRuntimeKey` functions are imported from the 'hono/adapter' module.

- The `env()` function is used to retrieve environment variables across different runtimes.
- The `getRuntimeKey()` function is used to get the runtime key for the current environment.

- [Hono Documentation](https://hono.bryntum.com/docs)

- Retrieving environment variables in a unified way across different platforms.
- Getting the runtime key for the current environment.

**Reasoning:** This rule is important because it demonstrates how to import and use the Adapter Helper from the Hono framework. The Adapter Helper provides a unified interface to interact with various platforms, which is crucial for building scalable and maintainable applications. The `env()` function and `getRuntimeKey()` function are particularly useful for retrieving environment variables across different runtimes.

*Source: docs/helpers/adapter.md*

### Retrieving Environment Variables in Different Runtimes with Hono

This code snippet demonstrates how to retrieve environment variables across different runtimes using Hono's 'env' function from the 'adapter' module.

```ts
import { env } from 'hono/adapter'

app.get('/env', (c) => {
  // NAME is process.env.NAME on Node.js or Bun
  // NAME is the value written in `wrangler.toml` on Cloudflare
  const { NAME } = env<{ NAME: string }>(c)
  return c.text(NAME)
})
```

The 'env' function retrieves the value of the environment variable 'NAME'. The value that can be retrieved may be different for each runtime. For example, in Node.js or Bun, 'NAME' is process.env.NAME, while in Cloudflare, 'NAME' is the value written in `wrangler.toml`.

- The 'env' function supports different runtimes, serverless platforms, and cloud services, including Cloudflare Workers and Deno.

- [Deno.env](https://docs.deno.com/runtime/manual/basics/env_va)

- Retrieving environment variables in a unified way across different platforms
- Building scalable and portable applications

**Reasoning:** This rule is important as it demonstrates how to retrieve environment variables in different runtimes using Hono's 'env' function from the 'adapter' module. It shows how to access environment variables in a unified way across different platforms, which is crucial for building scalable and portable applications.

*Source: docs/helpers/adapter.md*

### Retrieving Environment Variables in Hono

This code snippet demonstrates how to retrieve environment variables in the Hono framework by passing the runtime key as the second argument.

```ts
app.get('/env', (c) => {
  const { NAME } = env<{ NAME: string }>(c, 'workerd')
  return c.text(NAME)
})
```

In the code snippet, `env<{ NAME: string }>(c, 'workerd')` is used to get the environment variable `NAME` for the 'workerd' runtime. The `env` function takes two arguments: the context `c` and the runtime key 'workerd'.

- The `env` function is used to manage user-defined data in Hono.
- The runtime key must be specified correctly to retrieve the appropriate environment variables.

- [Hono Documentation](https://hono.bevry.me/)

- Configuring the application based on the runtime environment
- Managing user-defined data

**Reasoning:** This rule is important as it demonstrates how to retrieve environment variables in the Hono framework by specifying the runtime key. Understanding this is crucial for managing user-defined data and configuring the application based on the runtime environment.

*Source: docs/helpers/adapter.md*

### Using `getRuntimeKey()` to Identify Runtime Environment in Hono

The `getRuntimeKey()` function in Hono is used to identify the current runtime environment. This can be useful when the application behavior needs to be adjusted based on the runtime environment.

Here is a code snippet demonstrating its usage:

```ts
app.get('/', (c) => {
  if (getRuntimeKey() === 'workerd') {
    return c.text('You are on Cloudflare')
  } else if (getRuntimeKey() === 'bun') {
    return c.text('You are on Bun')
  }
  ...
})
```

In this snippet, the `getRuntimeKey()` function is used to check if the current runtime environment is 'workerd' or 'bun'. Depending on the result, a different response is returned.

- The `getRuntimeKey()` function returns a string that represents the current runtime environment.
- The returned value can be 'workerd', 'bun', or any other string representing a supported runtime environment.

- Adjusting application behavior based on the runtime environment.
- Debugging issues that occur only in specific runtime environments.

**Reasoning:** This rule is important as it demonstrates how to use the `getRuntimeKey()` function in Hono to identify the current runtime environment. This can be useful in scenarios where the application behavior needs to be adjusted based on the runtime environment.

*Source: docs/helpers/adapter.md*

### Importing and Using Proxy Helper in Hono

This guide demonstrates how to import and use the proxy helper from the Hono framework.

```ts
import { Hono } from 'hono'
import { proxy } from 'hono/proxy'
```

The above code imports the Hono framework and the proxy helper from it. The proxy helper provides a `fetch()` API wrapper for proxy. The parameters and return value are the same as for `fetch()` (except for the proxy-specific options).

- The `proxy()` function is a `fetch()` API wrapper for proxy.
- The parameters and return value are the same as for `fetch()` (except for the proxy-specific options).

- [Hono Documentation](https://hono.bosch.io/docs/)

- Using a Hono application as a (reverse) proxy.

**Reasoning:** This rule is important as it demonstrates how to import and use the proxy helper from the Hono framework. The proxy helper provides useful functions when using a Hono application as a (reverse) proxy. Understanding how to correctly import and use this helper is crucial for developers working with Hono.

*Source: docs/helpers/proxy.md*

### Proxying Requests in Hono

This code demonstrates how to use the proxy function in Hono to handle requests and redirect them to another server.

```ts
app.get('/proxy/:path', (c) => {
  return proxy(`http://${originServer}/${c.req.param('path')}`)
})
```

The `app.get` function is used to handle GET requests to the '/proxy/:path' endpoint. The `:path` is a parameter that will be replaced by the actual path in the request. The `proxy` function is then used to create a new request to the `originServer` with the same path as the original request.

- The `originServer` variable should be the URL of the server you want to proxy the requests to.
- The `c.req.param('path')` function is used to get the path parameter from the request.

- [Hono Documentation](https://hono.bike/#/)

- Proxying requests to different services in a microservices architecture.
- Redirecting requests to a different domain.

**Reasoning:** This rule is important as it demonstrates how to use the proxy function in Hono to handle requests and redirect them to another server. This is a common use case in many applications where you need to proxy requests to different services.

*Source: docs/helpers/proxy.md*

### Using the Proxy Helper in Hono

This code snippet demonstrates how to use the proxy helper in Hono to forward requests to another server. It also shows how to handle headers, including how to forward all request data, how to set specific headers, and how to prevent certain headers from being propagated. Finally, it shows how to delete a response header before returning the response.

```ts
app.get('/proxy/:path', async (c) => {
  const res = await proxy(
    `http://${originServer}/${c.req.param('path')}',
    {
      headers: {
        ...c.req.header(), // optional, specify only when forwarding all the request data (including credentials) is necessary.
        'X-Forwarded-For': '127.0.0.1',
        'X-Forwarded-Host': c.req.header('host'),
        Authorization: undefined, // do not propagate request headers contained in c.req.header('Authorization')
      },
    }
  )
  res.headers.delete('Set-Cookie')
  return res
})
```

The proxy helper is used to forward the request to another server. The path to the other server is specified in the first argument to the proxy function. The second argument is an options object, where you can specify headers to be included in the forwarded request. You can forward all request data by spreading `c.req.header()`, set specific headers, or prevent certain headers from being propagated by setting them to `undefined`. After the request is forwarded and the response is received, you can manipulate the response headers before returning the response.

- Be careful when forwarding all request data, as it might include sensitive information like credentials.
- When setting the 'X-Forwarded-For' and 'X-Forwarded-Host' headers, make sure to use the correct values.
- Deleting a response header might affect the behavior of the client that receives the response.

- [Hono documentation](https://hono.beebotte.com/docs)

- Forwarding requests to another server in a microservices architecture.
- Implementing a reverse proxy.

**Reasoning:** This rule is important as it demonstrates how to use the proxy helper in Hono to forward requests to another server. It shows how to handle headers, including how to forward all request data, how to set specific headers, and how to prevent certain headers from being propagated. It also shows how to delete a response header before returning the response.

*Source: docs/helpers/proxy.md*

### Proxying Requests and Manipulating Headers in Hono

This code snippet demonstrates how to use a proxy in Hono to forward requests to another server. It also shows how to manipulate the headers of the request to prevent sensitive information from being propagated.

```ts
app.all('/proxy/:path', (c) => {
  return proxy(`http://${originServer}/${c.req.param('path')}`, {
    ...c.req, // optional, specify only when forwarding all the request data (including credentials) is necessary.
    headers: {
      ...c.req.header(),
      'X-Forwarded-For': '127.0.0.1',
      'X-Forwarded-Host': c.req.header('host'),
      Authorization: undefined, // do not propagate request headers contained in c.req.header('Authorization')
    },
  })
})
```

The `app.all` method is used to handle all types of HTTP requests. The `proxy` function is used to forward the request to another server. The headers of the request are manipulated by spreading the existing headers and then overriding the 'Authorization' header with `undefined` to prevent it from being propagated.

- Be careful when manipulating headers as it can lead to unexpected behavior.

- [Hono documentation](https://hono.bike/)

- Forwarding requests to another server while hiding sensitive information.

**Reasoning:** This rule is important as it demonstrates how to use a proxy in Hono to forward requests to another server, while also showing how to manipulate the headers of the request. This is particularly useful when you want to hide sensitive information like 'Authorization' from being propagated.

*Source: docs/helpers/proxy.md*

### Defining ProxyFetch Interface in Hono

This code snippet demonstrates how to define interfaces for a ProxyFetch function in Hono.

```ts
interface ProxyRequestInit extends Omit<RequestInit, 'headers'> {
  raw?: Request
  headers?:
    | HeadersInit
    | [string, string][]
    | Record<RequestHeader, string | undefined>
    | Record<string, string | undefined>
}

interface ProxyFetch {
  (
    input: string | URL | Request,
    init?: ProxyRequestInit
  ): Promise<Response>
}
```

The `ProxyRequestInit` interface extends the `RequestInit` interface but omits the 'headers' property. It defines two optional properties: 'raw' of type Request and 'headers' which can be of type HeadersInit, an array of string pairs, or a Record of RequestHeader or string to string or undefined.

The `ProxyFetch` interface defines a function that takes an input of type string, URL, or Request and an optional `ProxyRequestInit` object and returns a Promise of type Response.

- The 'headers' property is omitted from the `RequestInit` interface to allow for custom header definitions.

- [Hono Documentation](https://hono.bike/docs/)

- Defining a ProxyFetch function in Hono to handle HTTP requests.

**Reasoning:** This rule is important as it demonstrates how to define interfaces for a ProxyFetch function in Hono. It shows how to extend the RequestInit interface while omitting the 'headers' property and how to define the ProxyFetch function that takes an input and an optional ProxyRequestInit object and returns a Promise of type Response.

*Source: docs/helpers/proxy.md*

### Using the `html` Helper in Hono

The `html` helper in Hono allows you to write HTML in JavaScript template literals. This is particularly useful when you need to generate dynamic HTML content based on some variables.

Here is a code snippet demonstrating its usage:

```ts
import { Hono } from 'hono'
import { html, raw } from 'hono/html'

const app = new Hono()

app.get('/:username', (c) => {
  const { username } = c.req.param()
  return c.html(
    html`<!doctype html>
      <h1>Hello! ${username}!</h1>`
  )
})
```

In this example, the `html` helper is used to generate a simple HTML document with a greeting message that includes the username passed in the URL.

The `raw()` function can be used to render content as is. This is useful when dealing with user-generated content or any content that needs to be rendered exactly as it is without any modifications. However, you need to be careful with this function as it does not escape the content, so you have to escape these strings by yourself to prevent any potential security issues.

- [Hono Documentation](https://hono.bike/#/)

- Generating dynamic HTML content based on some variables
- Rendering user-generated content or any content that needs to be rendered exactly as it is

**Reasoning:** This rule is important as it demonstrates how to use the `html` helper in Hono to write HTML in JavaScript template literals. It also shows how to use the `raw()` function to render content as is, which is crucial when dealing with user-generated content or any content that needs to be rendered exactly as it is without any modifications.

*Source: docs/helpers/html.md*

### Using the 'html' Helper Function in Hono to Generate Dynamic HTML Content

This rule demonstrates how to use the 'html' helper function in Hono to generate HTML content dynamically. The 'html' function allows you to insert dynamic content into HTML templates.

```ts
const app = new Hono()

app.get('/:username', (c) => {
  const { username } = c.req.param()
  return c.html(
    html`<!doctype html>
      <h1>Hello! ${username}!</h1>`
  )
})
```

In the code snippet, a new Hono application is created. A route handler is defined for the path '/:username'. In the route handler, the 'username' parameter is extracted from the request parameters. The 'html' function is then used to generate an HTML response that includes the 'username' parameter.

The 'html' function allows you to insert dynamic content into HTML templates. However, it does not automatically escape the content. You need to ensure that the content is properly escaped to prevent cross-site scripting (XSS) attacks.

- [Hono Documentation](https://hono.bike/#/)

The 'html' function is commonly used in web development to generate dynamic HTML content. For example, it can be used to personalize web pages based on user input or to display data from a database.

**Reasoning:** This rule is important as it demonstrates how to use the 'html' helper function in Hono to generate HTML content dynamically. It shows how to insert dynamic content into HTML templates, which is a common requirement in web development.

*Source: docs/helpers/html.md*

### Using Hono's `html` Helper for Inline Scripts and Functional Components

This code snippet demonstrates how to use Hono's `html` helper to insert inline scripts into JSX and how it can act as a functional component.

```tsx
app.get('/', (c) => {
  return c.html(
    <html>
      <head>
        <title>Test Site</title>
        {html`
          <script>
            // No need to use dangerouslySetInnerHTML.
            // If you write it here, it will not be escaped.
          </script>
        `}
      </head>
      <body>Hello!</body>
    </html>
  )
})
```

The `html` helper allows you to insert inline scripts directly into your JSX. This means you can avoid using `dangerouslySetInnerHTML` and the potential security risks it carries. The scripts you write will not be escaped.

Since `html` returns an HtmlEscapedString, it can act as a fully functional component without using JSX. This can be a performance benefit as it can be faster than using `memo`.

- [Hono Documentation](https://hono.dev/docs)

- When you need to insert inline scripts into your JSX
- When you want to use a functional component without using JSX

**Reasoning:** This rule is important as it demonstrates how to use Hono's `html` helper to insert inline scripts into JSX and how it can act as a functional component. It shows how to avoid using `dangerouslySetInnerHTML` by writing scripts directly into the JSX, which will not be escaped. It also highlights the performance benefits of using `html` over `memo`.

*Source: docs/helpers/html.md*

### Creating Functional Components with `html` Helper Function in Hono

In Hono, the `html` helper function can be used to create fully functional components without the need for JSX. This function returns an HtmlEscapedString, which can be embedded directly into the component. This can be a more efficient way of creating components in certain situations.

Here is an example of how to use the `html` function to create a functional component:

In this example, the `html` function is used to create a `Footer` component. The HTML for the footer is embedded directly into the component using the `html` function.

- The `html` function returns an HtmlEscapedString, which can be embedded directly into the component.
- This approach can be more efficient than using JSX in certain situations.

- [Hono documentation](https://hono.bayfront.io/)

- Creating reusable components without the need for JSX.
- Embedding HTML directly into components for efficiency.

#### Code Snippet

```typescript
const Footer = () => html`
  <footer>
    <address>My Address...</address>
  </footer>
`
```

**Reasoning:** This rule is important as it demonstrates how to use the `html` helper function in Hono to create a functional component. This is a key aspect of Hono, as it allows for the creation of reusable components without the need for JSX. The rule also shows how to embed HTML directly into the component, which can be a more efficient way of creating components in certain situations.

*Source: docs/helpers/html.md*

### Using `html` Helper in Hono to Create HTML Templates with Embedded Values

The following code snippet demonstrates how to use the `html` helper in Hono to create HTML templates with embedded values. It defines a layout with props and passes these props to the layout. It also uses the `html` helper to return HTML from a route handler.

1. A `SiteData` interface is defined to type the props.
2. A `Layout` component is defined using the `html` helper. It takes a `SiteData` object as props and embeds the values in the HTML template.
3. A `Content` component is defined that takes a `SiteData` object and a `name` as props. It passes the `SiteData` to the `Layout` and embeds the `name` in a `<h1>` tag.
4. In the route handler for '/', an object with the `SiteData` and `name` is created and passed to the `Content` component. The `html` helper is used to return the resulting HTML.

- The `html` helper allows for efficient creation of HTML templates with embedded values.
- More elements slow down JSX, but not template literals.

- [Hono Documentation](https://hono.boutell.com/)

- Creating dynamic web pages with embedded values.
- Returning HTML from route handlers.

#### Code Snippet

```typescript
interface SiteData {
  title: string
  description: string
  image: string
  children?: any
}
const Layout = (props: SiteData) => html`
<html>
<head>
  <meta charset="UTF-8">
  <title>${props.title}</title>
  <meta name="description" content="${props.description}">
  <head prefix="og: http://ogp.me/ns#">
  <meta property="og:type" content="article">
  <!-- More elements slow down JSX, but not template literals. -->
  <meta property="og:title" content="${props.title}">
  <meta property="og:image" content="${props.image}">
</head>
<body>
  ${props.children}
</body>
</html>
`

const Content = (props: { siteData: SiteData; name: string }) => (
  <Layout {...props.siteData}>
    <h1>Hello {props.name}</h1>
  </Layout>
)

app.get('/', (c) => {
  const props = {
    name: 'World',
    siteData: {
      title: 'Hello <> World',
      description: 'This is a description',
      image: 'https://example.com/image.png',
    },
  }
  return c.html(<Content {...props} />)
})
```

**Reasoning:** This rule is important as it demonstrates how to use the `html` helper in Hono to create HTML templates with embedded values. It shows how to define a layout with props and how to pass these props to the layout. It also shows how to use the `html` helper to return HTML from a route handler. This is a common pattern in Hono and understanding it can help in creating dynamic web pages efficiently.

*Source: docs/helpers/html.md*

### Using the 'raw()' Function in Hono to Prevent HTML Encoding

This code snippet demonstrates how to use the 'raw()' function in Hono to prevent HTML encoding of a string.

```ts
app.get('/', (c) => {
  const name = 'John &quot;Johnny&quot; Smith'
  return c.html(html`<p>I'm ${raw(name)}.</p>`)
})
```

In this example, the string 'John &quot;Johnny&quot; Smith' is passed to the 'raw()' function. This prevents the HTML encoding of the string when it is included in the HTML template literal.

- The 'raw()' function should be used with caution as it can potentially introduce security vulnerabilities if user-supplied input is not properly sanitized.

- Hono documentation: <https://hono.boutique/>

- When you want to include special characters in your string without them being converted into their HTML encoded equivalents.

**Reasoning:** This rule is important as it demonstrates how to use the 'raw()' function in Hono to prevent HTML encoding of a string. This is useful when you want to include special characters in your string without them being converted into their HTML encoded equivalents.

*Source: docs/helpers/html.md*
